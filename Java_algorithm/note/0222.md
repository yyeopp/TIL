# 그래프

## Eclipse Debugger 활용

- 재귀 스택 쌓이는 것도 들여다볼 수 있음.

## 서로소 집합

- 서로 중복 포함된 원소가 없는 집합들. 교집합이 존재하지 않음.

- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분
  
  - 이 때 지정된 멤버를 **대표자**라고 한다. 아무거나 골라도 상관 없다.

- 표현하는 방법: 연결 리스트, 트리

- 서로소 집합 연산
  
  - Make-set(x): 최소 단위 집합을 생성 (x로만 이루어진 집합)
  
  - Find-set(x): x가 속한 집합 찾기 (x가 속한 집합의 대표자 찾기)
  
  - Union(x,y): 서로소 집합인 x와 y가 속한 집합을 합쳐서 하나로 만듦. 
    
    - 이 때 **서로소 집합**을 유지하는 게 중요

### 서로소 집합의 표현 - 연결리스트

- 같은 집합의 원소들을 하나의 연결리스트로 관리

- 연결리스트의 맨 앞 원소를 대표자로 지정

- 각 원소는 집합의 대표원소를 가리키는 **링크**를 가짐.
  
  - 각 원소가 **다음**원소의 링크를 가지는 게 기존에 사용하던 연결리스트라면,
  
  - 각 원소가 링크를 하나 더 가져서 대표원소로 향하는 링크도 가지는 상태
  
  - 대표원소는 자기 자신으로 돌아오는 링크를 가지고 있다.

#### 연산 예시

- 대표원소(rep)와 마지막원소(tail)을 기억하고 있어야 한다.

- Find의 경우 집합의 링크를 따라가면서 일치하는 원소를 찾다가, 발견 시 rep를 반환

- Union의 경우 두 집합의 tail과 rep 사이 링크를 만든 뒤, **대표원소를 잃게 된** 집합 쪽 원소들에 새로운 대표원소로의 링크를 구축하면 된다.

### 서로소 집합의 표현 - 트리

- 같은 집합의 원소들을 하나의 트리로 표현

- 자식 노드가 부모 노드를 가리키며, 루트 노드가 대표자가 됨.

- 트리는 부모 노드의 인덱스값을 기억하는 방식으로 유지될 것.

#### 연산 예시

- Make-Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산

```
Make-Set(x)
    p[x] = x;
```

- Union의 경우, 한 쪽의 집합을 다른 쪽의 자식 노드로 갖다 붙이면 됨.
  
  - 만약 합치려는 두 집합이 각각 어떤 노드의 자식 노드에 해당한다면, 이들이 속한 부모 노드끼리의 Union 연산이 된다.

```
Union(x,y)
    if Find-Set(y) == Find-Set(x)
        return;
    else
        p[Find-Set(y)] == Find-Set(x);
```

- 부모 노드가 동일한 상태(이미 합쳐진 상태)면 그대로 return.
  
  - else의 경우 y의 부모로 x를 넣는 모습.

- Find 연산 또한 해당 노드로부터 타고 올라가서 가장 위에 있는 부모 노드를 반환.

```
Find-Set(x)
    if x == p[x]
        return x;
    else
        return Find-Set(p[x]);
```

- 루트 노드면 return하고, 아니면 부모 노드로 타고 올라간다는 뜻: 재귀로 구현

### 서로소 집합에 대한 연산

#### 연산의 효율을 높이는 방법

- Rank를 이용한 Union
  
  - 각 노드는 자신을 루트로 하는 subtree의 높이를 rank값으로 저장한다.
  
  - 두 집합을 합칠 때, rank가 낮은 집합을 높은 집합에 붙인다.
    
    - 짧은 쪽에 긴 게 이어져서 결과적으로 depth가 지나치게 늘어나는 일을 방지.

- Path compression
  
  - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꿔준다.

#### Path compression

- Depth가 아무리 깊어져도, 자식 노드들은 모두 하나의 root를 가리키고 있다.

- 이 점을 이용해서, Find-Set 연산 시 루트로부터 타고 내려가는 과정에서 자식 노드의 부모를 모두 **Root**로 변환시키는 것.
  
  - 연산과 동시에 Path가 압축되는 효과.
  
  - Depth가 깊었던 것이 Flat하게 넓어지는 형태로 변화

- 완벽하지는 않다: 루트끼리만 Union시키면 자식 노드로 Find-set할 기회가 없다.

```
Find-Set(x)
    if x == p[x]
        return x;
    else
        return p[x] = Find-Set(p[x]);
```

- 기존 Find-Set에서 약간 바뀐 모습. 재귀와 함께 루트 노드를 조정



-----

## 최소 신장 트리(MST)

- 그래프에서의 최소 비용 문제
  
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  
  - 두 정점 사이의 최소 비용의 경로 찾기

- 신장 트리
  
  - n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리.
  
  - **Cycle**이 발생하지 않게 된다.

- 최소 신장 트리(Minimum Spanning Tree)
  
  - 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리.
  
  - 여러 개의 신장 트리 중에서 하나를 골라야 함.
  
  - 다르게 표현하자면, **모든 정점을 고립된 지점 없이 모두 연결하되 연결에 필요한 네트워크 비용을 최소화한 경우**에 해당.

- Greedy 알고리즘으로 풀게 된다.



### KRUSKAL 알고리즘

- 간선을 하나씩 선택에서 MST를 찾는 알고리즘
  
  1. 최소, 모든 간선을 가중치에 따라 **오름차순으로 정렬**
  
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     
     - 단, Cycle이 발생하면 continue하고 다음으로 가중치가 낮은 간선을 선택해야 함
  
  3. n-1개의 간선이 선택될 때까지 반복
     
     - 남아있는 간선들은 **무조건** 지금까지 선택된 간선들보다 비용이 크므로, n-1개가 선택 완료됐다면 그대로 종료.
     
     - **Greedy** 알고리즘의 특성을 보여준다.
  - 이걸 서로소집합 연산으로 구현된다면?
    
    - 간선의 선택 = Union 연산
      
      - Union 연산이 가능한 상황이라는 건, 둘의 루트가 다르다는 것 = **연결된 바 없다는 것**.
      
      - 즉, 간선 연결과 동시에 **Cycling**여부 판단이 가능하다.
    
    - 아까 Union 연산의 구현을 `boolean`으로 한 이유가 여기에 있다.



- 결국 KRUSKAL 알고리즘은 기본적으로 **간선중심**의 해결법이다.
  
  - 그래프를 표현하는 3가지 방법: 인접행렬, 인접리스트, 간선리스트
  
  - 그 중에서 **간선리스트**를 사용해야한다는 것.

- 간선리스트는 간선들의 묶음
  
  - 간선에는 from, to, weight 정보가 담겨있다.
  
  - 표현 방법
    
    - `int[][]`으로 사용하는 방법
    
    - Edge 객체를 따로 구현해서 `Edge[]`로 사용하는 방법
  
  - **오름차순 정렬**이 알고리즘 구현 상 필요
    
    - Comparable, Comparator 활용이 요구됨

```
G.V: 그래프의 정점 집합
G.E: 그래프의 간선 집합

MST-KRUSKAL(G,w)
    for vertex v in G.V
        Make_Set(v)
    G.E에 포함된 간선들을 가중치 w를 이용하여 오름차순 정렬
    
    for 가중치가 가장 낮은 간선(u,v)
        if(Find_Set(u) != Find_set(v)
            Union(u,v)
```



### PRIM 알고리즘

- KRUSKAL과 달리, **정점 중심**의 알고리즘.
  
  - 인접행렬이나 인접리스트를 활용하게 될 것.

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  
  1. 임의 정점을 하나 선택해서 시작
  
  2. 선택한 정점과 인접하는 정점들 중 최소 비용의 간선이 존재하는 정점을 선택
     
     - 단, 이미 연결된 정점으로 향하는 간선은 제외
     
     - 새로운 정점에 연결될 때마다 간선 정보를 죄다 저장하고 매번 그 중 최소를 고르는 방식
  
  3. 모든 정점이 선택될 때까지 반복

- 서로소인 2개의 집합 정보를 유지



##### 언제 어떤 걸 사용할까?

- 입력 기준?
  
  - 입력이 간선정보라면?
    
    - 간선리스트로 구현 후 KRUSKAL
  
  - 입력이 정점정보라면?
    
    - 인접행렬로 구현 후 PRIM
  
  - 하지만, 완전한 기준은 될 수 없다.

- 정점의 수와 간선의 수를 기준으로 하자.
  
  - 간선이 많을 때 KRUSKAL을 쓴다면?
    
    - 알고리즘 상 간선리스트를 만들고 정렬해야 함
    
    - 정점이 N개일 때 최대 간선 개수는 N-1개, 그에 대한 정렬은 약 NlogN의 연산
    
    - KRUSKAL 자체는 괜찮은데, 사전 작업인 **정렬**에서 시간복잡도 상의 문제가 발생.
  
  - 즉, 간선이 적을 때는 KRUSKAL이 적절하나, **간선이 많다면 PRIM이 적절.**
