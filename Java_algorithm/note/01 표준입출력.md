# 표준 입출력

1. 표준 입출력
   ● System,in,out,err
   ● 입출력을 기본적으로 스트림이라고 하는데, 스트림은 데이터의 흐름이다.
   ☞ 데이터는 단방향으로만 흐른다.
   ☞ 데이터 입력 → 자바 앱 → 데이터 출력의 흐름에서 그 경로를 관리하는 게 스트림.
   ☞ InputStream과 Reader / OutputStream과 Writer
   ● 표준 입출력에서 System.in은 기본적으로 byte단위를 입력하는 InputStream의 계열이다.
   ☞ 하지만 byte단위는 사용하기 어렵기 때문에 다른 스트림을 달아서 기능을 자유롭게 변경시킨다.그게 ‘필터스트림’
   ● 표준 입출력의 대상을 변경하는 메서드로 set

2. java.util.Scanner
   ● 파일, 입력 스트림 등에서 데이터를 읽어 구분자를 통해 토큰화하고, 다양한 타입으로 형변환하여 리턴해주는 클래스.
   ☞ 입력 스트림을 다루는 방법을 몰라도 쉽게 입력처리가 가능하다. 스트림이랑 별개임
   ● 데이터 형변환으로 인한 편리함이 있음
   ● 단, 대랑의 데이터를 처리할 때 수행시간이 비효율적
   ☞ 프로그램의 수행시간에서 입출력처리시간이 포함되기 때문에, 최적화가 요구되는 부분.
   ● 주요 메서드: 다 알던 것
   ☞ tip: 입력을 두 번 할 때 뒤가 nextLine()이면 첫 번째를 입력하고 엔터칠 때 개행문자가 스트링으로 인식돼서 두 번째 입력할 기회가 사라진다. 개행을 비우는 작업이 필요첫 번째와 두 번째 사이에 nextLine();을 집어넣어주면 해결됨.
   ☞ tip: scanner의 nextInt()는 구분자(“ ”)의 직전까지 읽기 때문에 혹시 그 다음이 공백 이후 nextLine()이라면 불필요한 white space가 남아있을 수 있다.
   ☞ white space를 다루는 데 주의해야 할 것.

3. java.io.BufferedReader
   ● 필터 스트림의 한 유형.
   ● 대량의 데이터를 처리할 시 수행시간이 효율적이다.
   ● 표준입력을 ISR로 변환 후 BR이 읽으면 자바 앱에 데이터가 입력되는 구조

4. java.lang.StringBuilder
   ● 문자열의 조작을 지원하는 클래스
   ● 자바에서는 문자열이 상수: 조작 시마다 새로운 문자열이 생성되는 것을 방지.
   ● append()로 String 혹은 StringBuilder를 불러올 수 있음. sb.append(“ ”).append(“ ”) 이래도 됨
   ● 만약 문자열 간 구분자로 “, ”를 넣었다면 마지막에 setLength(sb.length()-2);를 통해서 구분자를 지울 수 있다. sb의 길이를 줄이는 방식

# SW 문제 해결

1. 문제 해결 역량이란?
   ● 하나의 문제에 대해 두 개 이상의 해결법을 알고 있자

2. 문제 해결 과정
   ● 문제를 읽고 이해한다.
   ☞ 3번 이상을 읽으라고. 빠르게 확인하면서 유형 파악 → 유형을 생각하며 문제를 읽어 유형을 확신(시간복잡도 고려하기)→ 제약사항 꼼꼼히 읽으면서 코드를 설계
   ● 문제를 익숙한 용어로 재정의한다.
   ● 어떻게 해결할지 계획을 세운다.
   ● 계획을 검증한다.
   ● 프로그램으로 구현한다.
   ● 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

3. 문제 해결 전략
   ● 비슷한 문제를 풀어본 적 있는가?
   ● 문제를 단순화할 수 있을까?
   ● 수식으로 표현할 수 있을까?
   ● 뒤에서부터 생각해서 문제를 풀 수 있을까?

4. 알고리즘
   ● 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법. 어떠한 문제를 해결하기 위한 절차.

5. 알고리즘 성능: 복잡도
   ● 시간 또는 공간복잡도는 입력 크기에 대한 함수로 표기. 주로 여러 항을 가지는 다항식
   ● 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
   ● 입력 크기 n이 무한대로 커질 때 복잡도를 간단하게 표현하기 위해 사용하는 표기법.

6. 빅-오(O) 표기법
   ● 시간복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수는 생략
   ex) O(3n+2)라면 O(n)으로 표시. n이 무한정 커졌을 때만 복잡도에 영향을 준다는 것
   ☞ 계수인 3과 +2는 큰 영향이 없다.
   ex) O(2n^2+10n+100)이라면 O(n^2). O(4)라면 그냥 O(1)
   ● 흔히, 1억 번의 연산을 ‘1초’로 생각한다.
   ex) n개의 데이터 입력 후 1씩 더해서 출력: n번 입력, n번 연산, n번 출력: O(3n)이므로 O(n)
   ● Big O 시간 복잡도에서, 연산자에 따라 요소수 증가에 따른 시간복잡도 증가 속도가 다르다.
   ☞ n! > 2^n > n^2 > nlog(n) 순서.
