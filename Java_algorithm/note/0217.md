# 백트래킹

- 대표적인 예시는 N-Queen 문제.



## 백트래킹(Backtracking)

- **퇴각검색**

- 모든 조합을 시도해서, 문제의 해를 찾는다.

- 해를 얻을 때까지 모든 가능성을 시도한다.

- 모든 가능성은 하나의 트리처럼 구성할 수 있고, 가지 중에 해결책이 있다.

- 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.

- 이런 선택을 반복하다가 최종 상태에 도달한다.

- **보통 재귀 함수로 구현된다.**
  
  > 기본적으로 완전탐색이라고 볼 수 있다.



### 당첨 리프 노드 찾기

- 루트에서, 갈 수 있는 노드를 선택한다.

- 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작한다.

- 더 이상의 선택지가 없는 경우 그 이전의 선택지로 돌아가서 다른 선택을 한다.

- 루트까지 돌아갔는데도 더 이상 선택지가 없다면, 찾는 답이 없다.
  
  **tree 자료구조에 대한 dfs 탐색이라고 볼 수 있다.**



- 루트 노드에서 리프 노드까지의 경로는 해답의 후보가 되는데, 완전탐색을 하면서 그 해답후보 중에서 해답을 찾을 수 있다.

- 그러나 이 방법을 사용하면, 해답이 될 가능성이 전혀 없는 노드의 후손 노드들도 모두 검색해야 하므로 비효율적.



### 상태공간트리 (state space tree)

- 문제 해결 과정에서의 모든 중간 과정들을 노드로 표현한 트리.

- 해를 찾기 위해서 탐색해야 하는 모든 후보군을 포함하고 있는 트리.
  
  - 재귀 호출의 횟수를 따져보는 데 이용 가능
  
  - 재귀 호출의 depth를 따지는 데에도 이용 가능



### 만약 8-Queens 문제라면?

- 퀸 8개를 크기 8*8의 체스판 안에서 서로를 공격할 수 없도록 배치하는 모든 경우를 구하는 문제.

- 만약 그냥 조합으로 푼다면?
  
  - $64C8$로 풀어야 한다. 대략 44억 개의 경우의 수 발생: 지나치게 많음.
  
  > 4-Queen이였다면 16C4여서 1820개만 검사하면 된다.  근데 N이 커지면 못함.

- 4-Queen 문제로 축소하고, **같은 행에 퀸을 두지 않는 방법**으로 제한을 두어 생각하자.
  
  - **상태 공간 트리**로 표현해서 dfs 기법을 사용하면, 모든 경우의 수가 256개로 축소.
  
  - 그래도 여전히 많다 + 가망이 없는 경우의 수 탐색이 많아서 비효율적이다.



#### 백트래킹으로 푼다면?

- 모든 후보를 검사한다? *No*

- 백트래킹 기법:
  
  어떤 노드의 유망성을 점검한 후에, 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가서 다음 자식 노드로 간다.
  
  - 유망: 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 있음
  
  - 가지치기: 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음.

- 알고리즘 구성
  
  1. 상태 공간 트리의 깊이 우선 검색(dfs)을 실시한다.
  
  2. 각 노드가 유망한지를 점검한다.
  
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 다른 노드로 검색을 계속한다.

```
backtrack (node v) 
    if promising(v) == false    // 유망하지 않으면 return (가지치기)
        return;
    if there is a solution at v    // 기저조건
        write the solution
    else
        for each child u of v
            backtrack(u)       // dfs
```



### 백트래킹과 완전탐색(DFS)의 차이

- 쉽게 혼동된다: 비선형 자료구조에 대해 재귀를 사용하기 때문

- 백트래킹은, 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다.
  
  - **Pruning**. "가지치기"

- 완전탐색이 모든 경로를 추적하는 데 비해, 백트래킹은 불필요한 경로를 조기에 차단한다.
  
  - 완전탐색을 가하기에 경우의 수가 너무나 많을 때 사용하면 좋은 것.
  
  - 예를 들어 N! 가지 경우의 수를 가진 문제에서 완전탐색을 하면, 처리가 불가능

- 백트래킹을 통해 일반적으로 경우의 수가 줄어들 수 있지만, 이 또한 최악의 경우 여전히 지수함수 시간을 요하므로 처리가 불가할 수 있다.
  
  > 4-Queen 문제: DFS하면 155 노드 탐색, 백트래킹하면 27 노드 탐색.



## 백트래킹 활용 - 부분집합의 합

### 문제1

- 유한 개의 정수로 이루어진 집합이 있을 때, 그 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 몇 번이나 있는지 알아내는 문제.

- 완전검색 기법으로 풀려면, 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.

### 문제2

- 유한 개의 자연수로 이루어진 집합이 있을 때, 그 부분집합 중에서 그 집합의 원소를 모두 더한 값이 21이 되는 경우가 몇 번이나 있는지 알아내는 문제.



----------

-----------

# 그래프

- 대표적인 예시는 "친구 관계 문제"

## 그래프(Graph)

- 그래프는, 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현한다.
  
  - 기본적으로 "다 대 다" 관계를 표현할 때 사용된다.

- 정점(Vertex): 그래프의 구성요소로, 하나의 연결점. 트리에서의 node

- 간선(Edge): 두 정점을 연결하는 선

- 차수(Degree): 정점에 연결된 간선의 수.

- 그래프는, 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조다.
  
  - V: 정점의 개수, E: 그래프에 포함된 간선의 개수라고 할 때,
    
    V개의 정점을 가지는 그래프는 최대 $V*(V-1)/2$개의 간선을 가질 수 있다.
    
    > 단, "무향(양방향)" 그래프인 경우. "유향" 이면 /2가 필요없다.

- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 표현하기에 용이.



### 그래프의 유형

- 무향 그래프(Undirected Graph)

- 유향 그래프(Directed Graph)

- 가중치 그래프(Weighted Graph)

- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)



- 완전 그래프: 정점들에 대해 가능한 모든 간선들을 가진 그래프

- 부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
  
  - 완전 그래프의 부분집합에 해당



- 트리 또한 그래프이다.
  
  - 각 노드는 최대 하나의 부모 노드가 존재 
  
  - 각 노드는 자식 노드가 없거나 하나 이상이 존재
  
  - 두 노드 사이에는 유일한 경로(간선)이 존재.

### 인접 정점

- 인접: 두 개의 정점 사이에 간선이 존재하면 서로 인접해 있다고 함.
  
  - 완전 그래프에 속한 임의의 두 정점들은 서로 인접해 있다.



### 그래프 경로

- 경로(Path)란 어떤 정점 A에서 시작하여 다른 정점 B로 끝나는 순회로, 두 정점 사이를 잇는 간선들을 순서대로 나열한 것.
  
  - 트리와 달리 "루트" 같은 존재가 없음. 그 어떤 정점에서도 출발이 가능하다.
  
  - 어떤 정점에서 다른 정점으로 가는 경로는 여러 가지일 수 있다.

- 단순 경로: 시작정점과 끝 정점을 제외하고 중복된 정점이 없는 경로.

- **싸이클**: 경로의 시작 정점과 끝 정점이 같은 경우.



## 그래프 표현

- 간선의 정보를 저장하는 방식. 메모리, 성능을 고려해서 결정하게 될 것.

- 인접 행렬, 인접 리스트, 간선 리스트



### 인접 행렬

- 두 정점을 연결하는 간선의 유무를 행렬로 표현
  
  - V x V 정방형 행렬
  
  - 행 번호와 열 번호가 그래프의 정점에 대응
  
  - 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현 ( int [][] )
    
    - 이걸 boolean[][]으로 표현하고 t/f로 표현할 수도 있긴 한데, 
      
      그렇게 할 시 **가중치** 표현이 불가능하다.
    
    - 무향 그래프의 경우, 행렬 작성 시 **대칭형**으로 완성될 것.
    
    - 유향 그래프라면, 행이 *from*, 열이 *to*에 해당함을 유의

- 무향 그래프라면,
  
  - i번째 행의 합 = i번째 열의 합 = Vi 정점의 차수
  
  - 그림 상에서 n개의 간선은 행렬 상 2n개의 원소로 표현

- 유향 그래프라면,
  
  - 행 i의 합 = Vi 정점의 진출 차수
  
  - 열 i의 합 = Vi 정점의 진입 차수
  
  - 그림 상 n개의 간선은 행렬 상 n개의 원소로 표현

#### 인접 행렬의 단점

- 희소 그래프(Sparse Graph) vs 밀집 그래프(Dense Graph)
  
  - 정점에 비해 간선이 희박 vs 간선이 빽뺵
  
  - 희소 그래프의 경우 배열 상 cell의 대부분이 0. 불필요한 공간이 너무 많음. 공간복잡도 상 손해
  
  - 밀집 그래프는 같은 차원에서 공간 활용 상 인접 행렬이 효율적.



### 인접 리스트

- 각 정점에 대한 인접 정점들을 순차적으로 표현

- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 **연결 리스트**에 저장
  
  - Data필드에는 to 정점 번호와 가중치를 담는다.
  
  - Link필드에는 다음 노드의 주소를 담는다.

- 헤드에 해당하는 Node를 관리하는 Node []를 통해 전체 그래프를 통제할 수 있다.
  
  - 각 헤드 node마다 각각의 LinkedList가 존재하기 때문.

- 무향 그래프에서 노드의 수는, 간선의 수 * 2
  
  - 각 정점(head)의 노드 수는, 정점의 **차수**

- 유향 그래프에서 노드의 수는, 간선의 수
  
  - 각 정점의 노드 수는 정점의 **진출 차수**.



### 간선 리스트

- 인접행렬과 인접 리스트는, **정점을 중심으로 간선을 표현**한다.

- 간선 리스트는, 두 정점에 대한 **간선 그 자체를 객체로 표현**하여 리스트로 저장.

- 각 객체는 간선을 표현하는 두 정점의 정보를 나타내고 있다. (시작과 끝 정점)
  
  - Custom class를 하나 파서 관리하면 좋다. from, to, weight 정도를 저장

##### 언제 뭘 쓸까? - 보충 필요

- 정보 입력이 정점 위주로 2차원 배열로 들어온다면?   
  
  - 그냥 인접행렬로 표현해서 풀면 됨

- 정보 입력이 간선에 대한 정보로 들어온다면?
  
  - 인접행렬, 인접리스트 모두 만들 수 있음
  
  - 그 때 중요한 건 정점의 크기 
    
    - 정점의 개수가 지나치게 크면, 인접행렬도 너무 커진다. 공간복잡도 상의 손실이 지나침 -> 인접리스트로 풀이
