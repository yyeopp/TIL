# 문자열 패턴 매칭

- 대표적인 예시는 **문자열 찾기**

- 패턴 매칭에 사용되는 알고리즘
  
  - 고지식하게 Brute Force
  
  - 라빈-카프 알고리즘
  
  - 보이어-무어 알고리즘
  
  - **KMP 알고리즘**

### Brute Force

- 처음부터 끝까지 차례대로 순회하면서, 패턴 내의 문자들을 일일이 비교하는 방식

- 시간복잡도 O(XY)로 과도함: 비교 회수 줄이는 게 필요

## 라빈-카프 알고리즘

- 문자열 검색을 위해 해시 값 함수를 이용

- 패턴 내의 문자들을 일일이 비교하는 대신 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만을 비교

- 최악의 경우 시간복잡도가 O(XY)가 되지만 평균적으로는 선형에 가까운 효율적인 알고리즘.

### 방법

- 패턴의 해쉬값을 계산한다.
  
  - ex) 패턴이 4321이면 단순히 String 4321이 아니라 실제 int 4321이라고 해쉬값을 부여하는 식

- 찾고자 하는 문자열에서 패턴의 길이만큼씩 해쉬값을 각기 계산한다.
  
  - 단, 매번 전부를 계산하지 않도록 하는 게 핵심
  
  - 한 글자씩 이동하면서 패턴 길이를 매번 통째로 계산하는 게 아니라, 새로 추가되는 문자와 그 전에 읽었던 값을 이용해서 새로운 해쉬값을 연산+2번으로 구하는 것.
  
  - ex) 6843에서 8432로 갈 때, -6000 + 2 하자는 것

- 고려사항
  
  - 처음 해쉬 값을 구할 때는 찾고자 하는 문자열에서 패턴 길이만큼 읽어서 구한다.
  
  - 패턴의 길이가 많이 커진 경우, 일정 자리수로 맞추기 위해 나머지 연산이 불가피하다. (mod 연산)
    
    - 패턴이 너무 커서 (int 범위를 초과할 수준) 관리가 불가능할 경우, 적당히 큰 수로 나머지 연산을 취하자는 것.
  
  - 해쉬 값이 일치하더라도 실제 패턴이 일치하지 않을 수 있게 된다.
    
    - **해쉬 충돌** 상황. 문자열 일치를 다시 한 번 검사해주는 과정이 불가피하다.
    
    - ex) 15랑 25랑 35를 10으로 나누면 나머지는 모두 5다.
    
    - 되도록이면 unique한 해쉬값 도출법이 필요함.

## 보이어-무어 알고리즘

- **패턴의 오른쪽에서 왼쪽으로 비교하는 특징.**

- 패턴의 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 길이만큼 이동시킬 수 있다.

- 만약 패턴 내에 존재하는 문자를 만났다면, 그 자리만큼 맞추면서 이동한다.
  
  - 한 자리씩 이동하는 게 아니라 계속해서 **jump**할 수 있다는 점이 중요.

- 최악의 경우 O(MN)이지만, 최선의 시간 복잡도는 O(N/M). 평균적으로 선형.

- **skip 배열** 만들기
  
  - skip[ch]: 본문 ch 문자에서 패턴 불일치가 발생했을 때, 본문포인터의 skip 횟수
  
  - 패턴에 포함되지 않은 문자들은 본문포인터가 패턴 길이만큼 skip해야하므로 패턴의 길이가 skip배열의 값이 된다.
    
    - 만난 문자가 패턴 내에 없다면 그냥 패턴 길이만큼 jump할 수 있다는 뜻
  
  - 패턴 문자들의 skip 배열값은, (패턴문자열의 길이 - 1) - 각 패턴 문자의 인덱스
    
    - 패턴 내에 있는 문자라면 그 자리에 맞춰서 jump 시키는 의미

## KMP 알고리즘

- Knuth-Morris-Pratt Algorithm

- 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
  
  - 앞에서부터 비교해나갈 때 패턴의 대부분을 맞추다가 마지막쯤에 틀리면 지금까지 탐색한 게 아깝다. 그걸 재활용할 방법을 고안한 것

- 패턴을 이용하여, 부분일치 테이블 배열을 작성
  
  - 매칭이 실패했을 때 패턴 포인터가 돌아갈 곳을 계산

- 패턴의 0번째 인덱스를 제외한 각 인덱스마다 맨 앞부터 해당.

- 인덱스까지의 부분문자열 중 접두사와 접미사가 일치하는 최대 길이로 계산하여 작성
