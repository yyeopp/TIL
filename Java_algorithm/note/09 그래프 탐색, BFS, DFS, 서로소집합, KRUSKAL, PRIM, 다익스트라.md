# 그래프

## 너비 우선 탐색(BFS)

- 그래프 순회는, 비선형구조인 그래프로 표현된 모든 자료(정점)를 빠짐없이 탐색하는 것을 의미한다.

- 두 가지 방법
  
  - 너비 우선 탐색(Breadth First Search)
  
  - 깊이 우선 탐색(Depth First Search)

### BFS

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
  
  - 트리에서와 비슷하지만, "루트" 와 "자식" 같은 상하관계가 없다는 게 차이점.
  
  - 중심에 있는 시작점에서부터 동심원을 그리며 커지는 느낌

- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

```
BFS(G,v)
    큐 생성
    시작 정점 v를 큐에 삽입
    정점 v를 방문한 것으로 표시
    while(큐가 비어 있지 않은 경우) {
        t = 큐의 첫번째 원소 반환
        for (t와 연결된 모든 간선에 대해) {
            u = t의 인접 정점
            u가 방문되지 않은 곳이면,
            u를 큐에 넣고, 방문한 것으로 표시
        }
    } 
```

- tree와의 차이점: tree는 **방문 관리**를 하지 않았다는 점에서 차이점.
  
  - 계층관계가 존재하지 않기 때문에 발생하는 차이점.
  
  - tree와 달리 graph는 특정 정점으로부터 (편의상) 위쪽으로 뻗는 간선과 아래쪽으로 뻗는 간선의 의미가 **완전히 동일**하다.
  
  - tree와 달리 graph는 **다 대 다** 관계를 가지므로, 특정 정점으로 향하는 경로가 하나가 아닌 **여러 개**가 될 수 있다.

#### BFS

##### 초기상태

- 정점의 수 만큼의 크기를 가진 boolean[] visited 생성 (방문 처리)

- Queue 생성

- 시작 정점인 A를 지정하고 방문처리 + enqueue

##### 탐색 진행

- dequeue A

- A의 인접 정점(B,C)을 방문처리하고 enqueue

- dequeue B, B의 인접 정점 방문처리 및 enqueue

- dequeue C, C의 인접 정점 방문처리 및 enqueue
  
  - B에서 인접 정점으로 가지고 있어서 방문처리된 정점이라면 여기서 enqueue되지 않는다.

- 이런 방식을 계속 반복하다가 Queue가 비면 탐색이 종료된다.
  
  - 탐색 순서를 확인해보면, 철저히 **너비우선**이다.

## 깊이 우선 탐색(DFS)

- DFS 알고리즘: 재귀로 구현

```
DFS(v)
    visited[v] = true
    for each all w in adjacency(G,v)
        if visited[w] != true
            DFS(w)
```

- 방문하지 않은 인접 정점으로 연속적인 탐색을 진행하다가, 더 이상 탐색할 정점이 없으면 return.
  
  - return을 통해 탐색되는 건 가장 최근에 방문한 정점. Stack으로 생각하면 편하다.

## Eclipse Debugger 활용

- 재귀 스택 쌓이는 것도 들여다볼 수 있음.

## 서로소 집합

- 서로 중복 포함된 원소가 없는 집합들. 교집합이 존재하지 않음.

- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분
  
  - 이 때 지정된 멤버를 **대표자**라고 한다. 아무거나 골라도 상관 없다.

- 표현하는 방법: 연결 리스트, 트리

- 서로소 집합 연산
  
  - Make-set(x): 최소 단위 집합을 생성 (x로만 이루어진 집합)
  
  - Find-set(x): x가 속한 집합 찾기 (x가 속한 집합의 대표자 찾기)
  
  - Union(x,y): 서로소 집합인 x와 y가 속한 집합을 합쳐서 하나로 만듦.
    
    - 이 때 **서로소 집합**을 유지하는 게 중요

### 서로소 집합의 표현 - 연결리스트

- 같은 집합의 원소들을 하나의 연결리스트로 관리

- 연결리스트의 맨 앞 원소를 대표자로 지정

- 각 원소는 집합의 대표원소를 가리키는 **링크**를 가짐.
  
  - 각 원소가 **다음**원소의 링크를 가지는 게 기존에 사용하던 연결리스트라면,
  
  - 각 원소가 링크를 하나 더 가져서 대표원소로 향하는 링크도 가지는 상태
  
  - 대표원소는 자기 자신으로 돌아오는 링크를 가지고 있다.

#### 연산 예시

- 대표원소(rep)와 마지막원소(tail)을 기억하고 있어야 한다.

- Find의 경우 집합의 링크를 따라가면서 일치하는 원소를 찾다가, 발견 시 rep를 반환

- Union의 경우 두 집합의 tail과 rep 사이 링크를 만든 뒤, **대표원소를 잃게 된** 집합 쪽 원소들에 새로운 대표원소로의 링크를 구축하면 된다.

### 서로소 집합의 표현 - 트리

- 같은 집합의 원소들을 하나의 트리로 표현

- 자식 노드가 부모 노드를 가리키며, 루트 노드가 대표자가 됨.

- 트리는 부모 노드의 인덱스값을 기억하는 방식으로 유지될 것.

#### 연산 예시

- Make-Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산

```
Make-Set(x)
    p[x] = x;
```

- Union의 경우, 한 쪽의 집합을 다른 쪽의 자식 노드로 갖다 붙이면 됨.
  
  - 만약 합치려는 두 집합이 각각 어떤 노드의 자식 노드에 해당한다면, 이들이 속한 부모 노드끼리의 Union 연산이 된다.

```
Union(x,y)
    if Find-Set(y) == Find-Set(x)
        return;
    else
        p[Find-Set(y)] == Find-Set(x);
```

- 부모 노드가 동일한 상태(이미 합쳐진 상태)면 그대로 return.
  
  - else의 경우 y의 부모로 x를 넣는 모습.

- Find 연산 또한 해당 노드로부터 타고 올라가서 가장 위에 있는 부모 노드를 반환.

```
Find-Set(x)
    if x == p[x]
        return x;
    else
        return Find-Set(p[x]);
```

- 루트 노드면 return하고, 아니면 부모 노드로 타고 올라간다는 뜻: 재귀로 구현

### 서로소 집합에 대한 연산

#### 연산의 효율을 높이는 방법

- Rank를 이용한 Union
  
  - 각 노드는 자신을 루트로 하는 subtree의 높이를 rank값으로 저장한다.
  
  - 두 집합을 합칠 때, rank가 낮은 집합을 높은 집합에 붙인다.
    
    - 짧은 쪽에 긴 게 이어져서 결과적으로 depth가 지나치게 늘어나는 일을 방지.

- Path compression
  
  - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꿔준다.

#### Path compression

- Depth가 아무리 깊어져도, 자식 노드들은 모두 하나의 root를 가리키고 있다.

- 이 점을 이용해서, Find-Set 연산 시 루트로부터 타고 내려가는 과정에서 자식 노드의 부모를 모두 **Root**로 변환시키는 것.
  
  - 연산과 동시에 Path가 압축되는 효과.
  
  - Depth가 깊었던 것이 Flat하게 넓어지는 형태로 변화

- 완벽하지는 않다: 루트끼리만 Union시키면 자식 노드로 Find-set할 기회가 없다.

```
Find-Set(x)
    if x == p[x]
        return x;
    else
        return p[x] = Find-Set(p[x]);
```

- 기존 Find-Set에서 약간 바뀐 모습. 재귀와 함께 루트 노드를 조정

---

## 최소 신장 트리(MST)

- 그래프에서의 최소 비용 문제
  
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  
  - 두 정점 사이의 최소 비용의 경로 찾기

- 신장 트리
  
  - n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리.
  
  - **Cycle**이 발생하지 않게 된다.

- 최소 신장 트리(Minimum Spanning Tree)
  
  - 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리.
  
  - 여러 개의 신장 트리 중에서 하나를 골라야 함.
  
  - 다르게 표현하자면, **모든 정점을 고립된 지점 없이 모두 연결하되 연결에 필요한 네트워크 비용을 최소화한 경우**에 해당.

- Greedy 알고리즘으로 풀게 된다.

### KRUSKAL 알고리즘

- 간선을 하나씩 선택에서 MST를 찾는 알고리즘
  
  1. 최소, 모든 간선을 가중치에 따라 **오름차순으로 정렬**
  
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     
     - 단, Cycle이 발생하면 continue하고 다음으로 가중치가 낮은 간선을 선택해야 함
  
  3. n-1개의 간선이 선택될 때까지 반복
     
     - 남아있는 간선들은 **무조건** 지금까지 선택된 간선들보다 비용이 크므로, n-1개가 선택 완료됐다면 그대로 종료.
     
     - **Greedy** 알고리즘의 특성을 보여준다.

- 이걸 서로소집합 연산으로 구현된다면?
  
  - 간선의 선택 = Union 연산
    
    - Union 연산이 가능한 상황이라는 건, 둘의 루트가 다르다는 것 = **연결된 바 없다는 것**.
    
    - 즉, 간선 연결과 동시에 **Cycling**여부 판단이 가능하다.
  
  - 아까 Union 연산의 구현을 `boolean`으로 한 이유가 여기에 있다.

- 결국 KRUSKAL 알고리즘은 기본적으로 **간선중심**의 해결법이다.
  
  - 그래프를 표현하는 3가지 방법: 인접행렬, 인접리스트, 간선리스트
  
  - 그 중에서 **간선리스트**를 사용해야한다는 것.

- 간선리스트는 간선들의 묶음
  
  - 간선에는 from, to, weight 정보가 담겨있다.
  
  - 표현 방법
    
    - `int[][]`으로 사용하는 방법
    
    - Edge 객체를 따로 구현해서 `Edge[]`로 사용하는 방법
  
  - **오름차순 정렬**이 알고리즘 구현 상 필요
    
    - Comparable, Comparator 활용이 요구됨

```
G.V: 그래프의 정점 집합
G.E: 그래프의 간선 집합

MST-KRUSKAL(G,w)
    for vertex v in G.V
        Make_Set(v)
    G.E에 포함된 간선들을 가중치 w를 이용하여 오름차순 정렬
    
    for 가중치가 가장 낮은 간선(u,v)
        if(Find_Set(u) != Find_set(v)
            Union(u,v)
```

### PRIM 알고리즘

- KRUSKAL과 달리, **정점 중심**의 알고리즘.
  
  - 인접행렬이나 인접리스트를 활용하게 될 것.

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  
  1. 임의 정점을 하나 선택해서 시작
  
  2. 선택한 정점과 인접하는 정점들 중 최소 비용의 간선이 존재하는 정점을 선택
     
     - 단, 이미 연결된 정점으로 향하는 간선은 제외
     
     - 새로운 정점에 연결될 때마다 간선 정보를 죄다 저장하고 매번 그 중 최소를 고르는 방식
  
  3. 모든 정점이 선택될 때까지 반복

- 서로소인 2개의 집합 정보를 유지

##### 언제 어떤 걸 사용할까?

- 입력 기준?
  
  - 입력이 간선정보라면?
    
    - 간선리스트로 구현 후 KRUSKAL
  
  - 입력이 정점정보라면?
    
    - 인접행렬로 구현 후 PRIM
  
  - 하지만, 완전한 기준은 될 수 없다.

- 정점의 수와 간선의 수를 기준으로 하자.
  
  - 간선이 많을 때 KRUSKAL을 쓴다면?
    
    - 알고리즘 상 간선리스트를 만들고 정렬해야 함
    
    - 정점이 N개일 때 최대 간선 개수는 N-1개, 그에 대한 정렬은 약 NlogN의 연산
    
    - KRUSKAL 자체는 괜찮은데, 사전 작업인 **정렬**에서 시간복잡도 상의 문제가 발생.
  
  - 즉, 간선이 적을 때는 KRUSKAL이 적절하나, **간선이 많다면 PRIM이 적절.**



## PRIM 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  
  1. 임의 정점을 하나 선택해서 시작
  
  2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  
  3. 모든 정점이 선택될 때까지 반복

- 서로소인 2개의 집합 정보를 유지
  
  - 트리 정점들: MST를 만들기 위해 선택된 정점들
  
  - 비트리 정점들: 선택되지 않은 정점들

# 최단 경로

- 정의: **간선의 가중치가 있는 그래프**에서 두 정점 사이의 경로들 중에 간선의 가중치 합이 최소인 경로
  
  - 간선의 가중치가 없는 그래프에서 최단 경로는?
    
    - 거쳐오는 간선수가 최단이라는 것. **BFS**로 구하는 게 무조건 유리.
    
    - 큐에 뭐가 들어간 상태건 간에 너비 순(**간선의 개수가 적은 순**)으로 접근하다가 도착하는 순간 끝낼 수 있으니까 빠르다.
    
    - DFS는 상대적으로 불리하다. 너비 순으로 접근하지 않기 때문에 결국 모든 경우를 다 봐야한다.

- 하나의 시작 정점에서 끝 정점까지의 최단 경로
  
  - **다익스트라 알고리즘**: 음의 가중치를 허용하지 않음
  
  - 벨만-포드 알고리즘: 음의 가중치 허용

- 모든 정점들에 대한 최단 경로: 플로이드-워샬 알고리즘 (DP)

## 다익스트라(Dijkstra) 알고리즘

- 시작정점에서 다른 모든 정점으로의 최단경로를 구하는 알고리즘

- 시작 정점에서의 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
  
  - BFS의 확장된 형태라고 생각해도 나쁘지 않다.

- Greedy 기법을 사용하는 알고리즘으로, MST의 PRIM 알고리즘과 유사하다.
  
  - 기존에 선택된 정점은 더 이상 들여다보지 않고, 출발 지점에서 특정 경유지까지 다다르는 최단경로를 계속 갱신하는 방식.
  
  - 출발지에서 점점 멀어지다가 도착지에 다다르면 그게 최단경로가 될 수밖에 없음.

```
s: 시작 정점, A: 인접 행렬, D: 시작정점에서의 거리
V: 정점 집합, U: 선택된 정점 집합


Dijkstra(s,A,D)
    U = {s};
    for 모든 정점 v
        D[v] = A[s][v]
    while U != V
        D[w]가 최소인 정점 w E V-U 를 선택
        U = U u {w}
        for w에 인접한 모든 미방문 정점 v
            D[v] = min(D[v], D[w]+A[w][v])
```

- Distance 배열을 사용: PRIM에서 minEdge 배열에 해당

- 시작점 S에 대해 모든 정점까지 다다르는 직접경로까지의 거리를 D배열에 저장
  
  - 직접 도착이 불가능한 정점에 대해서는 infinity가 저장될 것

- D 배열 중 가장 작은 값을 가지는 정점을 하나 선택해서 선택된 정점 집합에 포함
  
  - 새로 추가된 정점으로부터 직접 닿을 수 있는, 아직 미방문한 정점들에 대해 거리를 산출하고, 아까 D배열에 저장된 값과 비교해서 최소비용 갱신
    
    - PRIM때 했던 거랑 비슷한 논리
    
    - ex) S에서 시작해서 A를 새로 추가했을 때, S-B 보다 S-A-B가 더 짧으면 D배열의 B값을 후자로 갱신한다.

- 이걸 끝까지 반복하면 모든 경로까지의 최소비용이 D배열에 저장된다.
