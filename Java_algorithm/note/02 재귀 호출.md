# 재귀 호출

1. 반복과 재귀
   ● 반복과 재귀는 기본적으로 유사한 작업을 수행할 수 있다.
   ☞ 기존 반복문을 재귀로 바꿔보는 것도 좋은 연습이다.
   ● 반복은 수행하는 작업이 완료될 때까지 계속 반복.
   ☞ 정확히는 ‘특정 조건을 만족할 때까지’
   ● 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법.
   ☞ 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고, 결과들을 결합.

● 반복문에서도 “단위”를 반복하게 됨
● 재귀함수에서는 그러한 단위반복의 부분이 “함수구현부”에 들어가는 것.
● 그리고 함수구현부에서 “자신의 함수를 호출”하는 것이 반복행위를 구성.

2. 재귀 함수
   ● 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
   ☞ 반복이 끝나는 조건도 당연히 필요할 것: break가 없으면 메서드 호출이 끝없이 쌓이다가 “stackoveflow”
   ☞ 특정 조건을 판별 후 재귀를 호출하지 않을 때 재귀가 끝남
   ● 기본 부분과 유도 파트로 구성
   ☞ 유도 파트가 반복단위코드에 해당. 기본 부분이 재귀호출을 끊어주는(return) 코드에 해당.기본 부분이 있어야 재귀가 끝난다. 필수적임
   ● 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다.
   ● 재귀 호출은 기본적으로 반복적인 스택의 사용을 의미하기 때문에, 반복보다는 메모리와 속도에서 성능저하가 생길 수밖에 없다.
   ☞ 그래도 기능적으로 사용할 만 하다.
   ● “Flat”한 시야를 가져라. 내가 모든 것을 다 처리할 것이 아니라, 내가 만들어 준 결과가 내가 처리하던 것과 동일하다면 재귀를 할 수 있다는 것이니까 그냥 넘겨주자.
   ☞ 정의를 명확히 할 것! 무엇을 하고 있었는지, 무엇을 할 것인지, 어떤 기능인지.
   ☞ 자신의 작업을 수행하기 위해 필요한 결정 요인(인자), 즉 매개체의 값이 무엇인지 식별하자.
   ☞ 자신이 할 수 있는 일 + 나머지로 나누고 둘의 생김새가 같도록

3. 팩토리얼 재귀 함수
   ● 대표적인 재귀함수
   int fact(int n) {
   if(n<=1) return 1; : basis part
   else { return n * fact(n-1); } : inductive part
   ● n!은 n*(n-1)!로 구현된다는 점에서 착안. n!과 (n-1)!은 근본적으로 동일한 작업이니까 “재귀”로 해결할 수 있다.

4. 재귀를 이용한 조합의 계산
   ● 3C2라면? 어쨌든 “2개”를 뽑는다는 작업은 반복
   ● nCr = n-1Cr-1 + n-1Cr 로 바꿀 수 있다는 점 파악
   ☞ 원래 요구사항인 C가 두 개의 C로 쪼개진 모습 – 재귀 이용 가능. n이랑 r만 입력받으면 된다.
   ● 그럼 기저조건은?
   ☞ 아예 뽑지 않거나 (r=0), n=r일 때. 경우의 수가 1

5. 재귀를 이용한 피보나치수열 계산
   fibo(n)
   if(n<=1) return n;
   else{ return fibo(n-1) + fibo(n-2); }

# 재귀 호출 응용: 하노이의 탑

1. 어떻게 생각?
   ● 너무 파고들지 말고, “가장 밑에 있는 원판”과 “그 위에 있는 나머지”로 생각하자.
   ☞ 그래야 가장 밑에 있는 걸 어떻게든 치웠다고 쳤을 때, 그 다음 덩어리가 위와 같은 구조가 된다.
   ☞ 위에서 어떻게 움직일지는 일단 생각하지 말자고. “flat”하게 생각
   ● “나머지” 부분을 임시 기둥에 올리고, 가장 밑에 있는 원판을 목적 기둥에 옮기고, 최종적으로 “나머지” 부분을 목적 기둥에 옮기는 과정으로 단순화
   ☞ 이렇게 하면 “나머지” 부분도 위와 같은 구조로 움직일 수 있다.
   ● “n-1개 원판을 들어올리고 n번째 원판을 움직이고 n-1개 원판을 n번째 원판 위에 올린다.”
   ☞ 기둥 3개를 각각 from, temp, to라고 할 때
   ☞ from → temp, from → to, temp → to의 과정

2. 코드로 짜보면?
   ● 이게 왜 되지?

# 완전 검색

1. 정의
   ● 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
   ● Brute-forrce 기법으로도 불린다. just do it. 사람의 지능보다는 컴퓨터의 force.
   ● 모든 경우의 수를 테스트하기 때문에 제대로만 했다면 답이 무조건 나온다.
   ● 문제 해결 자체는 빠른 시간에 가능하나, 경우의 수가 상대적으로 작을 때 유용하다.
   ● 예시로 baby-gin 게임.
2. 완전 검색으로 시작하자
   ● 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하는 과정
   ● baby-gin의 경우 6!의 순열로 숫자를 나열하고 3자리씩 잘라서 테스트해보면 된다.
   ☞ 그렇게 해봐야 720가지 경우의 수이기 때문에 이런 방법으로도 충분하다.

# 완전탐색

1. 순열
   ● 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
   ● 서로 다른 n개 중 r개를 택하는 순열은 nPr
2. 순열 생성법
   ● 나열된 수 중에 하나를 선택
   ● 기존에 선택된 수가 있다면 비교해서 중복된 것을 스킵
   ● 다음 자리 수 선택
   ☞ 나열된 수 중에 하나를 선택
   ☞ 기존에 선택된 수가 있다면 비교해서 중복된 것을 스킵
   ☞ 다음 자리 수 선택 ---- 계속 반복됨

● 만약 이걸 단순 반복문으로 구한다면?
☞ 저 반복문을 r개만큼 돌려야 한다. 똑같이 생긴 r개의 반복문.
● 재귀로 구현한다면?

numbers[] : 순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열

3. 조합
   ● 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
   ● 마찬가지로 반복문을 통해 생성할 수도 있긴 하다.
   ☞ 규칙을 찾아보자: “뽑은 자릿수”보다 더 큰 자릿수에서만 뽑으면 중복을 거를 수 있음.
   ● 재귀로 구현한다면?
   input[]
   numbers[]까지는 같은데 중복 체크하는 boolean 배열이 필요하지 않다.
   대신 매개변수가 추가됨: 현재까지 뽑은 원소 개수 count에 더해, 조합을 시도할 원소의 시작 인덱스인 start가 필요

4. 중복순열
   ● 순서가 의미 있는데, 요소의 중복이 허용
   ● nPIr의 형태

5. 중복조합
   ● 순서가 의미 없지만, 요소의 중복은 허용
   ● nHr의 형태

6. 부분집합
   ● 총 2^n개의 원소 추출 가능
   ● 메모리 초과 주의
