# 스택

1. 스택의 특성
   ● 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조.
   ● 스택에 저장된 자료는 선형 구조를 갖는다.
   ☞ 선형구조: 자료 간의 관계가 1대1의 관계를 갖는다.
   ☞ 비선형구조: 자료 간의 관계가 1대N의 관계를 갖는다. ex) tree
   ● 스택에 자료를 삽입하거나 자료를 꺼낼 수 있다.
   ● 바닥은 막혀있고 위는 뚫려있다. 자료가 들어가는 입구와 출구가 같다는 뜻
   ☞ 필연적으로 후입선출구조가 이루어짐. 마지막에 삽입한 자료를 가장 먼저 꺼낸다.

2. 스택의 구조 및 연산
   ● 후입선출 구조: 저장된 원소 중 마지막으로 들어온 원소를, top이라고 한다. 가장 먼저 나감
   ● 주요 연산: push(삽입), pop(역순으로 삭제), peek(top을 반환)

3. Stack API
   ● java.util 패키지의 Stack 클래스를 활용하면 된다.
   ☞ List로부터 상속받고 있음: 중복허용, 순서 존재
   ● 주요 메서드: push(), pop(), isEmpty(), size()

4. 스택 응용1: 괄호 검사
   ● 괄호의 종류: [], {}, ()
   ☞ 후입선출의 원리를 활용하자는 의도.
   ● 조건: 열린 괄호는 닫혀야 하고, 괄호 간의 위계 및 순서를 맞춰서 열고 닫혀야 한다는 점
   ☞ 스택을 활용하기에 적절함

● 여는 괄호는 스택에 보관, 닫는 괄호가 나타났을 때 스택 속 top을 pop해서 비교하는 방식.
● 식이 끝날 때 size를 체크해서 >0이면 오류

5. 스택 응용2: function call
   ● 프로그램에서 함수 호출 및 복귀에 따른 수행 순서를 관리.
   ● 지금까지 코드를 짜면 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 구조였음
   ☞ 자연스럽게 받아들였던 순서. 특히 재귀 때 중요

# 큐

1. 큐의 특성
   ● 스택과 마찬가지로, 선형자료구조(순차적 자료구조)
   ● 삽입과 삭제의 위치가 제한적인 자료구조라는 점에서 동일
   ● 대신 자료의 입구와 출구가 다르다. 뒤에서 삽입하면, 앞에서만 삭제가 이루어진다.
   ☞ 서비스 대기 줄을 생각하면 된다.
   ● 선입선출구조: FIFO.
   ☞ 큐에 삽입한 순서대로 원소가 저장. 먼저 삽입된 원소가 먼저 삭제된다.

2. 큐의 선입선출 구조
   ● 머리(Front): 마지막으로 삭제된 원소(가장 예전에 삽입)
   ● 꼬리(Rear): 저장된 원소 중 마지막 원소(가장 최근에 삽입)
   ☞ 삽입은 enQue, 삭제는 deQue 메서드를 사용. 각각 push, pop에 대응

3. 큐의 연산 과정
   ● 공백 큐 생성: front와 rear의 인덱스는 0도 아니고 그냥 없다. -1이라고 하면 됨.
   ☞ front와 rear가 동일하다. 당연
   ● 원소 삽입: rear가 0으로, 1로 밀린다.
   ● 원소 반환/삭제: rear가 1에 있다고 칠 때, front가 비로소 0번 인덱스로 이동한다.
   ☞ 결국 front가 가르키는 건 원래 0번 인덱스에 있다가 “삭제된” 원소이다.
   ● 계속 반복하다보면 front와 rear가 동일한 n번 인덱스를 가르키고 있을 수 있다.
   ☞ 이 때 “공백 큐” 상태라고 한다.

4. Queue API
   ● java.util.Queue: 큐에 필요한 연산을 선언해 놓은 “인터페이스”
   ☞ 인터페이스는 “약속” “규약” “spec” “사용방법”으로 인지. 실제적인 구현체가 아니다.
   ☞ Queue를 implements하고 있는 구현체를 활용해야 하는 것
   ☞ 그래서, “LinkedList” 클래스를 Queue 인터페이스의 구현체로 많이 사용하게 된다.
   ● 단, LinkedList는 Queue뿐만 아니라 List 등의 다른 인터페이스를 동시에 구현하고 있음.
   ☞ 오히려 기능이 확장돼서 더 좋다. Queue의 성질을 가지고 있다는 점은 변하지 않기 때문

5. Queue 활용: 버퍼
   ● 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
   ● 일반적으로 입출력 및 네트워크 관련된 기능에서 이용
   ● 순서대로 입력/출력/전달이 되어야하므로 FIFO 방식의 자료구조인 Queue를 활용해야 함

# 리스트 (List)

1. 리스트
   ● 순서를 가진 데이터의 집합을 가리키는 “추상자료형”
   ☞ java.util.List를 말하는 게 아니라 그런 성질을 가진 자료형 자체를 뜻함
   ● 동일한 데이터를 가지고 있을 수 있다.
   ● 구현 방법에 따라 두 가지로 나뉨
   ☞ 순차리스트(배열 기반), 연결리스트(메모리의 동적할당 기반)

2. 순차 리스트
   ● 구현 방법: 1차원 배열에 항목들을 순서대로 저장하는 방식
   ● 인덱스를 기반으로 한 탐색과 접근이 가능.
   ● 배열 기반이기 때문에 크기 변동이 어려움: 크기를 늘리고 줄이는 메서드 따로 구현
   ☞ 데이터 삽입, 삭제도 가능은 하지만 마찬가지로 인덱스와 크기의 혼동이 발생

3. 순차 리스트의 문제점
   ● 단순 배열을 이용해 순차리스트를 구현할 시 자료의 삽입/삭제 연산 과정에서 연속적 메모리 배열을 위해 원소 shifting 작업이 다수 필요
   ● 원소 개수가 많고 삽입/삭제 연산이 빈번할 시, 작업 소요 시간이 크게 증가
   ● 배열의 크기가 정해져 있는 경우, 실제 사용될 메모리보다 크게 할당하여 메모리 낭비가 초래될 우려
   ● 반대로 할당된 메모리보다 많은 자료를 사용할 경우, 새롭게 배열을 만들어 작업을 해야 하는 비표율적인 상황 초래할 우려

4. 연결 리스트
   ● 자료의 논리적인 순서와 메모리 상 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 각 원소를 연결하여 하나의 전체적인 자료구조 구성
   ● 링크를 통해 원소에 접근하므로, 순차 리스트에서처럼 물리적인 순서(인덱스)를 맞추기 위한 작업이 필요하지 않음.
   ● 자료구조의 크기를 동적으로 조정할 수 있어 메모리의 효율적인 사용이 가능

5. 연결 리스트의 기본 구조
   ● 노드: 연결 리스트에서 하나의 원소를 표현하는 building block
   ☞ 구성 요소: 데이터 필드 + 링크 필드데이터필드에 원소의 값(종류, 크기 등), 링크 필드에 다음 노드 참조값(연결)
   ☞ 노드를 구성하는 각각의 객체는 각각의 주소(레퍼런스)를 가지고 있음
   ● 헤드: 연결 리스트의 첫 노드에 대한 “참조값”을 가지고 있음
   ☞ 헤드가 가지고 있어도 그 다음 노드, 그 다음 노드가 쭉 이어져서 전체 리스트를 가져올 수 있다.
   ☞ 그 사이를 이어주는 게 링크 필드인 것.
   ● 노드에는 단순히 int값 같은 것만 들어가는 게 아니라 얼마든지 커다란 객체를 집어넣어줄 수도 있다. Class를 담는 것도 충분히 가능함

6. 연결 리스트의 종류
   ● 단순 연결 리스트: 노드마다 링크 필드가 하나씩 존재해서 선형구조 형성하는 가장 일반적인 리스트
   ☞ 장점: 구현이 매우 쉬움
   ☞ 단점: 중간에 있는 노드를 빼내고 싶을 때, 그 앞쪽 노드의 링크 필드를 수정하는 방식을 사용해야 함근데 그 빼내고자 하는 노드는 “앞쪽 노드”의 주소값을 가지고 있지 않음결국 헤드에서부터 스캔해나가면서 “앞쪽 노드”를 찾아내야 함 – 그게 Iterator 메서드
   ● 이중 연결 리스트: 노드마다 링크 필드가 두 개씩 존재하는 선형구조.
   ☞ 다음 노드의 링크뿐만 아니라 이전 노드의 주소값을 담고 있음. 덕분에 이전 노드에 대한 사용이 쉬워짐.
   ☞ 단점: 노드 간 링크가 두 개라는 점에서, 선형 구조를 유지ㆍ관리하는 게 쉽지 않음
   ● 원형 연결 리스트: 마지막 노드의 링크를 헤드에 연결하는 구조
   ☞ 특정 노드에서 탐색을 시작하면 전체 노드를 탐색할 수 있음.

# 단순 연결 리스트

1. 연결 구조
   ● 노드가 하나의 링크 필드에 의해 다음 노드가 연결되는 구조
   ● 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킴
   ● 링크 필드가 null인 노드가 마지막 노드일 것.

2. 삽입연산: 첫 번째 노드로 삽입
   ● 헤드가 첫 노드에 해당하는 단순 연결리스트를 기준으로 설명
   ● 공백 리스트의 첫 번째에 “A”노드 삽입
   ☞ 일단 null에 해당하는 헤드가 존재
   ☞ 새로운 노드 new 생성
   ☞ 새로운 노드 new의 데이터 필드에 “A” 저장
   ☞ 헤드에 새로운 노드 new의 참조값을 저장

● 이미 원소(A노드)를 가지고 있는 리스트의 첫 번째에 “C”노드 삽입
☞ 새로운 노드 new 생성
☞ 새로운 노드 new의 데이터 필드에 “C” 저장
☞ 새로운 노드 new의 링크 필드에 기존 노드 A의 주소값을 저장
☞ 헤드에 새로운 노드 new의 주소값을 저장 (원래 헤드는 A의 주소값을 저장했음)
● 정리하면, 새로운 노드 생성, 데이터 필드 작성, 링크 필드 작성, 리스트의 처음으로 지정

3. 삽입연산: 마지막 노드로 삽입
   ● C, A 원소를 갖고 있는 리스트의 마지막에 D노드를 삽입
   ☞ 새로운 노드 new 생성, 데이터 필드에 D 저장, 링크 필드에 null 저장
   ☞ 기존 리스트를 스캔해서 링크필드가 null인 마지막 노드를 찾고, 그 링크 필드에 D 노드 주소값 저장
   ● 리스트 순회가 있다는 점에서 다소 복잡. 첫 번째 노드 삽입이 좀 더 쉬움.

4. 삽입연산: 가운데 노드로 삽입
   ● C,A,D 원소를 갖고 있는 리스트의 두 번째에 B노드를 삽입
   ☞ 새로운 노드 new 생성, 데이터필드에 B 저장, 링크 필드에 null 저장
   ☞ 기존 리스트를 스캔해서, 삽입될 위치의 바로 앞에 위치한 노드의 링크 필드를 new의 링크 필드에 복사
   ☞ new의 참조값을 바로 앞 노드의 링크 필드에 저장
   ☞ 그러면 원래 C-A 이던게 C-B-A로 연결될 수 있음.

5. 삭제연산: 선행노드가 있는 경우
   ● 삭제할 노드의 선행노드를 탐색
   ● 삭제할 노드의 링크 필드를 선행노드의 링크 필드에 복사
   ☞ 삭제할 노드가 리스트에서 떨어져 나오지만, 객체 자체가 곧바로 사라지는 건 아님
   ☞ 링크 필드에 적혀있던 후행노드의 주소값을 제거하고, 데이터 필드도 초기화하는 작업은 따로 필요
   ☞ 혹은 이렇게 삭제된 노드를 모아서 재사용하는 방법도 고려해볼 수 있음.

6. 삭제연산: 선행노드가 없는 경우
   ● 헤드에 곧장 이어지는 노드여서 선행노드가 없는 경우
   ● 삭제할 노드의 링크 필드를 헤드에 복사해서 리스트에서 떨어져 나올 수 있음

7. 단순 연결 리스트의 활용
   ● 스택 자료구조에서의 활용: 헤드를 “top”으로 생각하면 된다.
   ☞ 첫 번째 노드만 삽입/삭제하는 알고리즘 = push와 pop.

# 이중 연결 리스트

1. 특성
   ● 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
   ● 두 개의 링크 필드와 한 개의 데이터 필드로 구성.
   ☞ 그 외에는 단순 연결 리스트랑 사실상 동일하기 때문에 읽어보면 안다.
