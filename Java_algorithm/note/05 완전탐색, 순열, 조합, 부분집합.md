# 완전탐색

### Comparable / Comparator

##### java.lang.Comparable

- 인터페이스에 해당
  
  - 정확히는 Functional Interface.
  
  - `int compareTo(T other)`를 기본적으로 구현하고 있지만 원하는 기능으로 오버라이딩해서 사용 가능

- 자신을 인자로 전달 받은 타 원소와 비교하여 정수를 리턴함
  
  > 앞(자신)에서 뒤(타 원소)를 뺀 결과를 따라가는 것
  
  - 음수 결과: 타 원소가 더 크다
  
  - 0 결과: 둘이 같다
  
  - 양수 결과: 자신이 더 크다

- comparable의 기본 세팅은 natural ordering: 오름차순
  
  - 목록을 순차적으로 올라갈 때, `compareTo`의 결과가 음수거나 0이면 그대로 유지
  
  - 양수 결과가 나오면 둘의 자리를 교체하는 방식으로 정렬될 것

- 만약 내림차순 혹은 그 외의 정렬방식을 사용하고자 할 시, `compareTo`를 오버라이딩해야 한다.
  
  - ex) 내림차순을 하고 싶다면 `compareTo`의 리턴값을 this-o가 아닌 o-this로 바꾸기

- tip) 빼기 연산이 이루어질 때 두 숫자의 부호가 다를 시 int 범위를 넘어서 overflow가 유발될 수 있으니 유의해야 할 것

##### java.util.Comparator

- Comparable과 달리 util 패키지에 있다는 점
  
  - 별도로 사용되는 "도우미"의 역할이라는 뜻

- 사용자가 임의로 만든 custom class의 경우 그 객체들 간의 비교가 일반적인 comparable 인터페이스로는 어려움
  
  - Comparator를 직접 구현해서 비교 연산을 수행해야 할 것.

- `int compare(T o1, T o2)` 로 사용됨
  
  - 두 원소를 비교하여 정수를 리턴함. 마찬가지로 음수와 0, 양수 결과를 리턴

---

### 순열 응용 - 비트마스킹 순열

##### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것. 순서가 의미 있다.

- nPr로 표현. Factorial 연산이 활용됨

##### 순열 생성법: 재귀 호출 - boolean[] 사용

```
input[] : 숫자 배열
numbers[] : 순열 저장 배열
isSelected[] : 인덱스에 해당하는 원소가 선택되었는지 저장하는 배열
// 사용 중인지 여부를 모든 수를 순회하면서 검색하는 게 아니라 (N번)
// 딱 한 번만 검색할 수 있도록 추가적인 메모리를 사용한 것 (1번)
perm(cnt)
    if cnt == N
        순열 생성 완료 (기저 조건)
        원하는 작업 구현
        return;
    else    // 반복될 부분
        for i from 0 to N-1    // 가능한 수 모두 시도
            if isSelected[i] == true    then continue;
            numbers[cnt] = input[i]
            isSelected[i] = true
            perm(cnt+1)
            isSelected[i] = false        // flag 초기화 필수
        end for
end perm()
```

- isSelected[]를 사용한 결과, 메모리 사용량은 올라가고 시간은 줄어드는 경향 발생
  
  - 시간복잡도 down, 공간복잡도 up
  
  - 일반적으로는 시간에 focus가 집중되는 편이므로 꽤 좋은 방법.

##### 비트 연산자

- 전에 배운 적은 있다.

- AND, OR, XOR, 비트 반전, 열 이동 연산자
  
  - & | ^ ~ << >>
  
  - 이 중 &, |, <<를 활용할 것

- **value << n**
  
  - value를 n비트 만큼 왼쪽으로 shift, 남는 오른쪽 자리는 0으로 채움
  
  - ex) 1<<2는 001에서 100으로 변환시키는 연산
  
  - 효과는 2개
    
    - value를 2배로 만드는 효과
    
    - 1을 원하는 비트열로 shift시키는 효과: 비트마스킹 때 활용

- **value1 & value2**
  
  - 각 비트열을 비교하여, 두 비트 모두 1이면 1, 아니면 0으로 처리하는 연산
  
  - ex) 10 & 3은 1010과 0011을 비교해서 0010으로 만들고 십진법으로는 2로 출력
  
  - ex) 10 & 1<<3 은?
    
    - 비트마스킹 기법에 해당. 1<<3을 통해 1을 원하는 비트열로 이동시켜놓고, 비교할 대상인 10에 대해 해당 비트열에 1이 존재하는 지 여부를 확인하고자 하는 것
    
    - 1<<3에 의해 원하는 비트열 말고 모든 자리는 0으로 초기화되므로, 비교 대상(10)이 무엇이든 간에 연산 결과에서 나머지 자리는 모두 0이 된다.
    
    - 해당 예제의 경우 1000으로 도출됨.
      
      - 즉, 2^n이거나 0이거나. 2^n이면 해당 비트열이 1이였던 것. 0이면 0

- **value1 | value2**
  
  - 각 비트열을 비교하여, 두 비트 모두 0이면 0, 아니면 1로 처리하는 연산
  
  - 마찬가지로 비트마스킹 기법에 활용

##### 순열 생성법: 비트마스킹

- 정수와 비트연산자를 사용
  
  - int는 32개 bit로 구성 - flag 32개로 인식
  
  - bit가 0이라면 false, 1이라면 true라고 인식

```
perm(cnt,flag)
    if cnt == N

    else    
        for i from 0 to N-1
            if(flag & 1<<i) !=0    then continue;
            // 이 부분에서 t/f를 판단하는 것. 0일 때만 진행하도록
            numbers[cnt] = input[i]
            perm(cnt+1, flag | 1<<i)   
            // cnt가 이루어졌다면 t를 넣기 위해 | 연산자 활용.
        end for
end perm()
```

- 재귀의 구조 자체는 동일하되 boolean[]를 사용하지 않은 점만 다르다.

- 하나 더 다른 점: flag를 명시적으로 false로 초기화하는 부분이 재귀 이후에 없다는 점
  
  - `flag | 1<<i`로 연산을 했을 때, flag 그 자체는 변화하지 않기 때문.

---

### 순열 응용 - Next Permutation

##### NextPermutation

- 현 순열에서 사전 순으로 다음 순열을 생성하는 방법

- 알고리즘
  
  - 배열을 오름차순으로 정렬한 후 시작
  
  - 아래 과정을 반복하여, 사전 순으로 다음으로 큰 순열 생성 (가장 큰 내림차순 순열을 만들 때까지)
    
    > 123에서 시작해서 NP하면 132가 나오고, 반복하다가 321이 나오면 끝난다는 뜻
    
    - 뒤쪽부터 탐색하며 교환위치 (i-1) 찾기 (i는 꼭대기)
    
    - 뒤쪽부터 탐색하며 교환위치와 교환할 큰 값 위치(j) 찾기
    
    - 두 위치 값 (i-1, j) 교환
    
    - 꼭대기위치(i) 부터 맨 뒤까지 오름차순 정렬



## 조합 응용 - Next Permutation

### 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것.

- 조합을 재귀 호출로 생성할 때, 중복 체크를 별도로 활용하지 않고 start라는 인덱스로 시작점을 통제하는 방법을 사용했었다.

- 당연히 반복문으로 조합 생성하는 것도 가능.

### 조합 생성법: NextPermutation 활용

- 원소 크기와 같은 크기의 int 배열 P를 생성하여, r개 크기만큼 뒤에서 0이 아닌 값(예를 들어 1)으로 초기화한다.
  
  - ex) 5-C-3 은 00111로 초기화하고 시작

- 만든 배열에 대해 nextPermutation 알고리즘을 활용
  
  - 00111은 01011, 01101, 01110으로 점차 바뀜

- 이 때 1의 위치가 곧 flag가 되는 것. 원래의 원소 (예를 들어 12345)에 대해 0이 아닌 값을 갖고 있는 위치에 해당하는 원소를 조합으로 선택하면 그게 결과물로 도출됨.
  
  - 345, 245, 235, 234, ...

---

## 부분집합 응용 - 바이너리 카운팅

### 부분집합

- 집합에 포함된 원소들을 선택하는 것

- 다수의 중요 알고리즘들은, 원소들의 그룹에서 최적의 부분집합을 찾는 것.

- N개의 원소를 포함한 집합에 대해, 자기 자신과 공집합을 포함한 모든 부분집합의 개수는 2^n 개.
  
  - "지수적"으로 증가 - 시간 및 공간복잡도 폭발을 주의해야 함

### 부분집합 생성법: 바이너리 카운팅

- 부분집합 생성 시 반복문, 재귀 모두 사용 가능 (이미 다뤘던 내용)

- **바이너리 카운팅: 사전석 순서로 생성하는 방법**
  
  - 원소 수에 해당하는 N개의 비트열을 이용.
    
    ex) 원소가 4개면, 0부터 15까지의 10진수를 이진수로 변환한 16개의 비트열을 사용한다는 것
  
  - 이 때 n번째 비트값이 1이면, n번째 원소를 포함시킨다는 의미가 될 것
    
    ex) {A,B,C,D}에 대해 0000이면 subset은 {}, 1011이면 {A,B,D}.
  
  - **비트연산자**의 사용이 필요할 것: &, << 를 사용해서 특정 비트열에 1이 존재하는 지 여부를 검증하게 된다.

---
