## 조합 응용 - Next Permutation



### 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것.

- 조합을 재귀 호출로 생성할 때, 중복 체크를 별도로 활용하지 않고 start라는 인덱스로 시작점을 통제하는 방법을 사용했었다.

- 당연히 반복문으로 조합 생성하는 것도 가능.

- 

### 조합 생성법: NextPermutation 활용

- 원소 크기와 같은 크기의 int 배열 P를 생성하여, r개 크기만큼 뒤에서 0이 아닌 값(예를 들어 1)으로 초기화한다.
  
  - ex) 5-C-3 은 00111로 초기화하고 시작

- 만든 배열에 대해 nextPermutation 알고리즘을 활용
  
  - 00111은 01011, 01101, 01110으로 점차 바뀜

- 이 때 1의 위치가 곧 flag가 되는 것. 원래의 원소 (예를 들어 12345)에 대해 0이 아닌 값을 갖고 있는 위치에 해당하는 원소를 조합으로 선택하면 그게 결과물로 도출됨.
  
  - 345, 245, 235, 234, ...

-------------

## 부분집합 응용 - 바이너리 카운팅



### 부분집합

- 집합에 포함된 원소들을 선택하는 것

- 다수의 중요 알고리즘들은, 원소들의 그룹에서 최적의 부분집합을 찾는 것.

- N개의 원소를 포함한 집합에 대해, 자기 자신과 공집합을 포함한 모든 부분집합의 개수는 2^n 개.
  
  - "지수적"으로 증가 - 시간 및 공간복잡도 폭발을 주의해야 함



### 부분집합 생성법: 바이너리 카운팅

- 부분집합 생성 시 반복문, 재귀 모두 사용 가능 (이미 다뤘던 내용)

- **바이너리 카운팅: 사전석 순서로 생성하는 방법**
  
  - 원소 수에 해당하는 N개의 비트열을 이용.
    
    ex) 원소가 4개면, 0부터 15까지의 10진수를 이진수로 변환한 16개의 비트열을 사용한다는 것
  
  - 이 때 n번째 비트값이 1이면, n번째 원소를 포함시킨다는 의미가 될 것
    
    ex) {A,B,C,D}에 대해 0000이면 subset은 {}, 1011이면 {A,B,D}.
  
  - **비트연산자**의 사용이 필요할 것: &, << 를 사용해서 특정 비트열에 1이 존재하는 지 여부를 검증하게 된다.
  
  

-----------

# 탐욕 기법



## 탐욕(Greedy) 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법
  
  - 지금 현재 시점에서 가장 유리한 것이 "확실"한 방법을 사용하고, 차선책은 전혀 고려하지 않으며, 지나간 선택을 전혀 되돌아보지 않음

- 최적화 문제란, 가능한 해들 중에서 가장 좋은 해를 찾는 문제.

- 즉, 일반적으로 머릿속에서 떠오르는 생각을 검증 없이 바로 구현하면 그것이 바로 Greedy 접근이 된다.
  
  - 탐욕 알고리즘 접근 대신 완전탐색을 사용하면 경우의 수가 비효율적인 수준으로 늘어날 수 있다. 충분히 거를 수 있는 말도 안 되는 경우를 모두 검사해야하기 때문.

- 여러 경우 중 하나를 선택할 때 마다 그 순간의 최적이라고 생각되는 것을 선택해나가는 방식으로 진행, 최종적인 해답에 도달한다.

- 단, 각 선택 시점에서 이루어지는 결정이 지역적으로는 최적이여도 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 **그것이 최적이라는 보장은 없다.**

- 어쨌든 한번 선택된 것은 번복하지 않는다.
  
  - 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순한 편이고, 제한적인 문제들에 적용된다. 



### 예시: 배낭 짐싸기(Knapsack) 유형

- 두 가지의 세부 유형
  
  - 0-1: 배낭에 물건을 통째로 담아야 하는 문제. 물건을 쪼갤 수 없음
  
  - Fractional Kanpsack: 배낭에 물건을 부분적으로 담는 것이 허용되는 문제. 물건을 쪼갤 수 있음

- 0-1 Knapsack에 대한 **완전검색** 방법
  
  - 완전검색으로 물건들의 집합 S에 대한 모든 부분집합을 구함
  
  - 부분집합의 총 무게가 W를 초과하면 버리고, 나머지 중 값이 가장 큰 집합을 선택
  
  - 시간 복잡도는 **지수적**으로 증가.

- 0-1 Knapsack에 대한 **탐욕적** 방법
  
  - 값이 비싼 물건부터 채우기?
    
    - 무게와 값이 따로 책정되기 때문에 최적해를 도출할 수 없음
  
  - 무게가 가벼운 물건부터 채우기?
    
    - 마찬가지로 최적해를 도출할 수 없음
  
  - 무게 당 값(값/kg)이 높은 순서로 물건을 채우기?
    
    - 일견 타당하지만 0-1이기 때문에 최적해 도출에는 실패한다.
  
  > 0-1에 대해 Greedy 접근을 사용하면, 반례가 계속 발생한다.
  
  > 탐욕 접근으로 푸는 게 **불가능**하다.

- 대신 Fractional이 가능하다면 풀 수 있을 것.



### 예시: 활동 선택 문제

- 시작시간과 종료시간이 있는 n개의 활동들의 집합 A에서 서로 겹치지 않는 최대 개수의 활동들의 집합인 S를 구하는 문제.
  
  - S는 A의 부분집합 중 하나가 될 것.

- 풀이 과정
  
  - 우선, 종료 시간 순으로 활동들을 정렬하는 것으로 시작
    
    - 같은 종료 시간이라면 시작 시간 순으로 한 번 더 정렬
  
  - 가장 빠른 종료 시간을 가지고, 그 중 시작 시간이 가장 빠른 (가장 위에 있는) 활동을 선택
  
  - 선택된 활동과 시간이 겹치는 활동들은 모두 포기
  
  - 제외된 것 이후 가장 위에 있는 활동을 선택
  
  - 계속 반복하면 최적선택이 종료됨.

- 전형적인 탐욕 알고리즘에 해당한다.

- n번째 활동을 선택할 때, 1~n-1번째 활동을 모두 검증할 필요가 없이 바로 직전의 n-1번째 활동에 대해서만 검증하면 된다.
  
  - 시간복잡도가 O(1)까지 줄어들 수 있다는 것.



### 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성: 탐욕적 선택이 최적해로 갈 수 있음.
  
  - 탐욕적 선택은 항상 안전하다

- 최적 부분 구조: 최적화 문제를 정형화하라
  
  - 하나의 선택을 하면, 풀어야 할 하나의 하위 문제가 남는다.

- **원문제의 최적해는 탐욕적 선택과 하위문제의 최적해의 합**임을 증명하자.



---------

# 분할 정복 기법

- 대표적인 문제는 "가짜 동전 찾기"
  
  - 핵심은, 큰 문제를 작은 문제로 쪼개가면서 동일한 풀이법을 적용시킨다는 점.
  
  - 재귀 적용도 가능할 것
  
  

## 분할 정복

- 나폴레옹이 사용한 전략에서 유래했다고.



### 설계 전략: Top-down approach

- **분할**: 해결할 문제를 여러 개의 작은 부분으로 나눈다.

- **정복**: 나눈 작은 문제를 각각 해결한다.

- **통합**: (필요하다면) 해결된 해답을 모은다.



### 예시: 거듭 제곱의 계산

- 반복(Iterative) 알고리즘: O(n)으로 계산 가능
  
  - 만약 n이 10억쯤 된다면, 시간이 터지거나 overflow 유발

- 분할 정복 기반의 알고리즘: O(log2 n)으로 계산 가능
  
  - n이 10억이어도 단 30으로 해결 가능
  
  - 최대 Heap 계산했던 것과 유사
  
  

### 거듭 제곱: 분할 정복

- C^8을 구할 때 C를 8번 곱하는 건 단순 반복

- 대신, C^8을 C^4와 C^4의 곱으로 보고 C^4를 한 번만 수행한 뒤 그대로 갖다 쓰자는 것

- 같은 논리를 반복하다보면 연산 회수가 크게 줄어든다.

```
Recursive_power(x,n)
    if n==1: return x;
    if n is even    // n이 짝수
        y = Recursive_power(x, n/2)
        return y*y;
    else        // n이 홀수
        y = Recursive_power(x, (n-1)/2)
        return y*y*x;
```



## 분할 정복 활용 - 이진 검색

- 대표적인 문제는 "Up-down 게임"



### 개요

- 자료의 **가운데**에 있는 항목의 키 값과 비교하여, 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
  
  - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써, 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행한다.

- 이진 검색을 하기 위해서는 자료가 **정렬된 상태**여야 한다는 점.
  
  - 그래야 "가운데"를 찾고 다음 범위를 한정하는 게 의미있어진다.



### 검색 과정

1. 자료의 중앙에 있는 원소를 고른다.

2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.

3. 중앙 원소의 값과 찾고자 하는 목표 값이 일치하면 탐색을 끝낸다.

4. 대소 관계에 따라 자료의 왼쪽, 오른쪽 반을 골라서 새로 검색을 수행한다.

5. 위의 과정을 반복



### 알고리즘

- 반복구조로도 짤 수 있다.

```
binarySearch(S[], n, key)
    start = 0
    end = n-1
    
    while start <= end
        mid = (start+end)/2
        if S[mid] == key
            return mid;
        else if S[mid] < key
            start = mid + 1
        else if S[mid] > key
            end = mid - 1
    end while
    return -1
```

- 재귀로 짜면 보다 간단하다.

```
binarySearch(S[], n, key)

    if start > end
    // start<= end 일 때 정상적으로 돌아가므로.
        return -1    

   else
        mid = (start + end) /2
        
        if S[mid] == key
            return mid;
        else if S[mid] < key
            return binarySearch(S[], mid + 1, end, key)
        else if S[mid] > key
            return binarySearch(S[], mid - 1, end, key)

```

### 이진 검색 API

- java.util.Arrays.binarySearch
  
  - 이진탐색 API. 자바에서 지원하고 있다.
  
  - 주의할 점: 반드시 배열을 미리 정렬한 다음에 넘길 것. 정렬은 안 해준다.
  
  - `int binarySearch(int[] a, int key)`
    
    -  key와 일치하는 값을 a 배열에서 찾으면 그 인덱스를 리턴한다.
    
    - 못 찾으면 삽입 지점의 인덱스 - 1 값이 나온다. 이것도 활용 가능함
  
  - `int binarySearch(int[] a, int fromIndex, int toIndex, int key)`
    
    - 주어진 인덱스 범위 안에서만 이진탐색하는 코드


