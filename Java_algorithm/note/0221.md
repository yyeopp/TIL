# 그래프

## 너비 우선 탐색(BFS)

- 그래프 순회는, 비선형구조인 그래프로 표현된 모든 자료(정점)를 빠짐없이 탐색하는 것을 의미한다.

- 두 가지 방법
  
  - 너비 우선 탐색(Breadth First Search)
  
  - 깊이 우선 탐색(Depth First Search)

### BFS

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
  
  - 트리에서와 비슷하지만, "루트" 와 "자식" 같은 상하관계가 없다는 게 차이점.
  
  - 중심에 있는 시작점에서부터 동심원을 그리며 커지는 느낌

- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

```
BFS(G,v)
    큐 생성
    시작 정점 v를 큐에 삽입
    정점 v를 방문한 것으로 표시
    while(큐가 비어 있지 않은 경우) {
        t = 큐의 첫번째 원소 반환
        for (t와 연결된 모든 간선에 대해) {
            u = t의 인접 정점
            u가 방문되지 않은 곳이면,
            u를 큐에 넣고, 방문한 것으로 표시
        }
    } 
```

- tree와의 차이점: tree는 **방문 관리**를 하지 않았다는 점에서 차이점.
  
  - 계층관계가 존재하지 않기 때문에 발생하는 차이점.
  
  - tree와 달리 graph는 특정 정점으로부터 (편의상) 위쪽으로 뻗는 간선과 아래쪽으로 뻗는 간선의 의미가 **완전히 동일**하다.
  
  - tree와 달리 graph는 **다 대 다** 관계를 가지므로, 특정 정점으로 향하는 경로가 하나가 아닌 **여러 개**가 될 수 있다.

#### BFS

##### 초기상태

- 정점의 수 만큼의 크기를 가진 boolean[] visited 생성 (방문 처리)

- Queue 생성

- 시작 정점인 A를 지정하고 방문처리 + enqueue

##### 탐색 진행

- dequeue A

- A의 인접 정점(B,C)을 방문처리하고 enqueue

- dequeue B, B의 인접 정점 방문처리 및 enqueue

- dequeue C, C의 인접 정점 방문처리 및 enqueue
  
  - B에서 인접 정점으로 가지고 있어서 방문처리된 정점이라면 여기서 enqueue되지 않는다.

- 이런 방식을 계속 반복하다가 Queue가 비면 탐색이 종료된다.
  
  - 탐색 순서를 확인해보면, 철저히 **너비우선**이다.



## 깊이 우선 탐색(DFS)

- DFS 알고리즘: 재귀로 구현

```
DFS(v)
    visited[v] = true
    for each all w in adjacency(G,v)
        if visited[w] != true
            DFS(w)
```

- 방문하지 않은 인접 정점으로 연속적인 탐색을 진행하다가, 더 이상 탐색할 정점이 없으면 return.
  
  - return을 통해 탐색되는 건 가장 최근에 방문한 정점. Stack으로 생각하면 편하다.
