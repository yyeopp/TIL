# Dynamic Programming

## 피보나치 수열

```
fibo(n)
    if n<2 : return n;
    else : return fibo(n-1) + fibo(n-2)
```

위와 같은 재귀함수의 문제점: **엄청난 중복 호출이 존재한다는 점**

피보나치 수열의 Call Tree(상태공간트리)를 그려서 확인할 수 있다.

**같은 input에 같은 output이 나온다는 점이 보장되고** 그러한 같은 input이 계속 반복된다면, **재사용**을 할 수 있지 않을까?

## 메모이제이션(memoization)

이전에 계산한 값을 메모리에 저장해서, 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 동적 계획법의 핵심이 되는 기술이다.

피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면, 실행시간을 O(n)으로 줄일 수 있다.

- 시간을 줄이기 위해 **메모리**를 사용한다는 점에서 시간복잡도와 공간복잡도가 교환되는 성격이 있다.

```
memo를 위한 배열을 할당하고, 모두 0으로 초기화한다.
메모되어 있는 값인지 아닌지를 구분하기 위한 초기화에 해당.

fibo(n)
    if (n>=2 && memo[n]==0) {
       memo[n] = fibo(n-1)+fibo(n-2)
    }
    return memo[n];
```

n이 2 이상이고 메모된 적이 없다면, 계산 후 저장하고 return.

n<2 이거나, 메모가 이미 되어있었다면 그 값을 return

## 동적 계획법

그리디 알고리즘과 같이, **최적화 문제**를 해결하는 알고리즘

먼저 작은 부분 문제들의 해들을 구하고, 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하며, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법.

기본적으로 재귀랑 유사한 접근

- 재귀가 하향식이라면, DP는 상향식 접근.

### 동적 계획법의 적용 요건

#### 중복 부분문제 구조

DP는 작은 문제들의 최적해를 이용하여 **순환적으로** 큰 문제를 해결한다.

그 순환 관계를 명시적으로 표현하기 위해, 일반적으로 수학적 도구인 **점화식**을 사용한다.

이러한 순환적인 성질 때문에, 이전에 계산되었던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데, 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(table)에 저장하게 된다.

저장된 해들이 필요할 때, 다시 계산하는 게 아니고 table의 참조를 통해 중복 계산을 피한다.

#### **최적 부분문제 구조**

동적 계획법은 주어진 문제가 **최적화의 원칙**을 만족해야만 효율적으로 적용될 수 있다.

최적화의 원칙이란, 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이여야한다는 것.

동적 계획법 방법 자체가 큰 문제의 최적해를 작은 문제의 최적해들로 구하는 구조기 때문에, 큰 문제의 최적해가 작은 문제들의 최적해로 구성되지 않는다면 동적 계획법을 적용할 수가 없다.

### 분할 정복과 동적계획법의 비교

#### 분할 정복

**연관 없는** 부분 문제로 분할 하고,

그 부분 문제를 재귀적으로 해결하여,

부분 문제의 해를 결합하는 과정. 물론 결합이 없을 수도 있다.

- 그냥 단순히 나눠서, 분업하는 것에 가깝다.

#### DP

부분 문제들이 서로 연관이 없으면 적용 자체가 불가하다. 부분 문제들은 더 작은 부분 문제들을 공유한다.

모든 부분 문제를 한 번만 계산하고 결과를 저장해 재사용한다.

#### 상세

DP에는 부분 문제들 사이의 의존적 관계가 존재한다. 상위 문제 해결에 하위 문제 해결이 필요하다.

이러한 관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 **함축적인 순서**라고 한다.

분할 정복은 하향식 방법으로, DP는 **상향식 방법**으로 접근하게 된다.

### 3단계 DP 적용 접근 방법

#### 최적해 구조의 특성을 파악하라

#### 최적해의 값을 재귀적으로 정의하라 (점화식)

#### 상향식 방법으로 최적해의 값을 계산하라.

#### 피보나치 수 DP 적용 알고리즘

```
fibo_dp(n)
    f[0] = 0
    f[1] = 1
    for(i, 2->n)
        f[i] = f[i-1]+f[i-2]
    return f[i]
```

### 예시문제: 이항 계수 구하기

```
bino(n,k)
    B[][]
    for i in 0 -> n
        for j in 0 -> minimum(i,k)
            if j==0 || j==i
                B[i][j] = 1
            else
                B[i][j] = B[i-1][j-1] + B[i-1][j]
        return B[n][k]
```

## 동적 계획법 활용 - 0/1 Knapsack

### 문제 제시

> 10kg 용량의 배낭에 4가지 선물을 선택해서 넣을 때, 최대 가치가 되도록 선택하려면?
> 
> - 5kg인데 10만원이고, 4kg인데 40만원이고, 6kg인데 30만원이고, ...

만약 **fractional** 상황이라면, **무게 당 가치가 큰 순서**로 Greedy하게 풀면 된다.

하지만 0/1의 조건이라면? DP가 필요.

### DP 접근

문제의 주어진 조건: 물건, 물건의 무게, 물건의 가치, 배낭의 용량

#### 부분문제 정의

> W = 배낭의 용량
> 
> (vi, wi) = i번 물건의 가치, 무게
> 
> K[i,w] = 물건 1~i까지만 고려하고 (담는 것이 아니라 따져보는), (임시) 배낭의 용량이 w일 때 (w<=W)의 최대 가치.

재귀적으로 정리하면

```
K[i,w]
    if(i==0 || w==0)
        0
    if(wi > w)    // 담지 못하는 상황
        K[i-1, w]
    if(i > 0 && wi <= w)    // 담을 수 있는 상황.
        max(vi + K[i-1, w-wi], K[i-1,w])    // 실제로 담거나, 담지 않거나
```

i번째 물건을 고려할 때,

- 담지 못하는 상황: 최적해는 물건 i를 포함하지 않는다.
  
  - 전체 가치는 그 전 (i-1까지)와 동일하다.

- 담을 수 있는 상황: 최적해는 물건 i를 포함한다.
  
  - 전체 가치는 물건 i의 가치와 그 전까지를 고려해, 배낭의 용량이 w-wi인 경우의 최대 가치

2개의 부분문제, K[i-1, w-wi]와 K[i-1,w]가 미리 계산되어 있어야만 K[i,w]를 계산할 수 있다.

## 최장 증가 수열

> 어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있을 때,
> 
> `3, 2, 6, 4, 5, 1`
> 
> 이 배열 순서를 유지하면서 크기가 점진적으로 커지는 **가장 긴** 부분수열의 길이는?
> 
> > 답은 **3**

### Brute-force 접근 방법

수열의 모든 부분집합을 구하여 각각이 증가수열인지 모두 판별하는 것. 그 중 가장 길이가 긴 값을 구한다.

부분수열의 길이가 긴 것부터 조사하는 것이 유리할 것.

문제는, 부분집합의 시간복잡도가 2^N이라는 점

### DP 접근 방법 1

`LIS[i]`: i 원소가 수열의 마지막일 때 최장길이 값을 저장하는 1차원 배열

### DP 접근 방법 2 - 이진 검색 활용

> 이진 검색: 분할정복에서 활용했던 알고리즘!
> 
> **정렬된 데이터**에 대해 center를 기준으로 data를 절반으로 나눠 탐색해나감으로써 시간복잡도를 줄이는 방법.
> 
> 이진검색의 시간복잡도는 logN에 불과함

`C[k]`: 길이 k의 증가 수열에 대하여, 가장 작은 원소값을 저장하는 배열

각 위치에서 `C[]`를 갱신하기 위해 이진 검색을 수행한다.

답은 끝까지 탐색한 이후 **찍어본 적 있는 최장길이**. 배열에 들어있는 값 자체는 아무 의미가 없다.

이진탐색이 활용되는 지점은, 새로운 원소를 고려할 때 **삽입 위치를 찾는 부분**.

최종 시간복잡도는 **NlogN**

## 모든 쌍 최단 경로

> 각 정점 사이의 최단 경로를 구하되, **음의 가중치가 있고**, **모든 정점을 출발점으로 고려해야 한다.**
> 
> -> 다익스트라로는 풀기 다소 어려운 문제.

### 최단 경로 문제

가중치가 있는지 여부, 음의 가중치가 있는지 여부, 방향성이 있는지 여부를 잘 고려해야 함.

### Brute-force 접근

한 정점에서 다른 정점으로의 모든 경로를 구하고 그 중 최단 경로를 찾는다.

n개의 정점에 대해 완전그래프를 가정하면, 시간복잡도가 절대적으로 비효율적.

### DP 접근

> 각 정점을 시작 정점으로 하여, **다익스트라** 알고리즘을 수행하면 된다. 인접행렬 사용 시 N^3의 시간복잡도 발생. 
> 
> 플로이드-워샬 알고리즘이라고 하여 다익스트라 대신 간단하게 구현 가능한 tool이 있다. 나중에 배울 것.

동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면, 먼저 부분문제들을 찾아야 한다.

그래프 정점을 3개로 축소해서 생각할 때, 정점 i에서 j까지의 최단 경로를 찾으려면

- 정점 i에서 정점 j로 직접 가는 경로와

- 정점 1을 경유하는 경로 중 짧은 것을 선택하면 된다.

즉, 직접가냐 vs 경유하냐의 문제로 일반화가 가능하다는 뜻

모든 정점을 경유 가능한 정점들로 고려하면서, 모든 쌍의 최단 경로의 거리를 계산

#### 부분문제 정의

`D_ij_k` : 정점 {1~k}만을 경유 가능한 정점들로 **고려**하여, 정점 i로부터 j까지의 모든 경로 중에서 가장 짧은 경로의 거리. **2차원배열**로 구현하게 될 것 (인접행렬과 비슷하게 생김)

- 정점 1에서 k까지 모든 정점들을 **반드시 경유하는 경로를** 의미하는 것이 아니고, **고려**했다는 개념.

제대로 구현했다면, 알고리즘 종료 후 D 배열은 매 칸에서 모든 쌍 최단경로를 저장하고 있을 것

> i와 j 정점이 있고 새로 k 정점을 경유지로 고려할 때,
> 
> - i에서 j로 직접 가는 비용
> 
> - i에서 j를 k를 경유해서 가는 비용을 비교해
> 
> 보다 작은 값을 배열에 저장하는 것이 일반식이 된다.

삼중 for문으로 구현하게 될 것. 바깥부터 **경유지 -> 출발지 -> 도착지**


