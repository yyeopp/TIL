# Dynamic Programming

## 피보나치 수열

```
fibo(n)
    if n<2 : return n;
    else : return fibo(n-1) + fibo(n-2)
```

위와 같은 재귀함수의 문제점: **엄청난 중복 호출이 존재한다는 점**

피보나치 수열의 Call Tree(상태공간트리)를 그려서 확인할 수 있다.

**같은 input에 같은 output이 나온다는 점이 보장되고** 그러한 같은 input이 계속 반복된다면, **재사용**을 할 수 있지 않을까?

## 메모이제이션(memoization)

이전에 계산한 값을 메모리에 저장해서, 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 동적 계획법의 핵심이 되는 기술이다.

피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면, 실행시간을 O(n)으로 줄일 수 있다.

- 시간을 줄이기 위해 **메모리**를 사용한다는 점에서 시간복잡도와 공간복잡도가 교환되는 성격이 있다.

```
memo를 위한 배열을 할당하고, 모두 0으로 초기화한다.
메모되어 있는 값인지 아닌지를 구분하기 위한 초기화에 해당.

fibo(n)
    if (n>=2 && memo[n]==0) {
       memo[n] = fibo(n-1)+fibo(n-2)
    }
    return memo[n];
```

n이 2 이상이고 메모된 적이 없다면, 계산 후 저장하고 return.

n<2 이거나, 메모가 이미 되어있었다면 그 값을 return

## 동적 계획법

그리디 알고리즘과 같이, **최적화 문제**를 해결하는 알고리즘

먼저 작은 부분 문제들의 해들을 구하고, 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하며, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법.

기본적으로 재귀랑 유사한 접근

- 재귀가 하향식이라면, DP는 상향식 접근.

### 동적 계획법의 적용 요건

#### 중복 부분문제 구조

DP는 작은 문제들의 최적해를 이용하여 **순환적으로** 큰 문제를 해결한다.

그 순환 관계를 명시적으로 표현하기 위해, 일반적으로 수학적 도구인 **점화식**을 사용한다.

이러한 순환적인 성질 때문에, 이전에 계산되었던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데, 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(table)에 저장하게 된다.

저장된 해들이 필요할 때, 다시 계산하는 게 아니고 table의 참조를 통해 중복 계산을 피한다.

#### **최적 부분문제 구조**

동적 계획법은 주어진 문제가 **최적화의 원칙**을 만족해야만 효율적으로 적용될 수 있다.

최적화의 원칙이란, 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이여야한다는 것.

동적 계획법 방법 자체가 큰 문제의 최적해를 작은 문제의 최적해들로 구하는 구조기 때문에, 큰 문제의 최적해가 작은 문제들의 최적해로 구성되지 않는다면 동적 계획법을 적용할 수가 없다.

### 분할 정복과 동적계획법의 비교

#### 분할 정복

**연관 없는** 부분 문제로 분할 하고,

그 부분 문제를 재귀적으로 해결하여,

부분 문제의 해를 결합하는 과정. 물론 결합이 없을 수도 있다.

- 그냥 단순히 나눠서, 분업하는 것에 가깝다.

#### DP

부분 문제들이 서로 연관이 없으면 적용 자체가 불가하다. 부분 문제들은 더 작은 부분 문제들을 공유한다.

모든 부분 문제를 한 번만 계산하고 결과를 저장해 재사용한다.

#### 상세

DP에는 부분 문제들 사이의 의존적 관계가 존재한다. 상위 문제 해결에 하위 문제 해결이 필요하다.

이러한 관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 **함축적인 순서**라고 한다.

분할 정복은 하향식 방법으로, DP는 **상향식 방법**으로 접근하게 된다.

### 3단계 DP 적용 접근 방법

#### 최적해 구조의 특성을 파악하라

#### 최적해의 값을 재귀적으로 정의하라 (점화식)

#### 상향식 방법으로 최적해의 값을 계산하라.

#### 피보나치 수 DP 적용 알고리즘

```
fibo_dp(n)
    f[0] = 0
    f[1] = 1
    for(i, 2->n)
        f[i] = f[i-1]+f[i-2]
    return f[i]
```

### 예시문제: 이항 계수 구하기

```
bino(n,k)
    B[][]
    for i in 0 -> n
        for j in 0 -> minimum(i,k)
            if j==0 || j==i
                B[i][j] = 1
            else
                B[i][j] = B[i-1][j-1] + B[i-1][j]
        return B[n][k]
```



## 동적 계획법 활용 - 0/1 Knapsack

### 문제 제시

> 10kg 용량의 배낭에 4가지 선물을 선택해서 넣을 때, 최대 가치가 되도록 선택하려면?
> 
> - 5kg인데 10만원이고, 4kg인데 40만원이고, 6kg인데 30만원이고, ...

만약 **fractional** 상황이라면, **무게 당 가치가 큰 순서**로 Greedy하게 풀면 된다.

하지만 0/1의 조건이라면? DP가 필요.

### DP 접근

문제의 주어진 조건: 물건, 물건의 무게, 물건의 가치, 배낭의 용량

#### 부분문제 정의

> W = 배낭의 용량
> 
> (vi, wi) = i번 물건의 가치, 무게
> 
> K[i,w] = 물건 1~i까지만 고려하고 (담는 것이 아니라 따져보는), (임시) 배낭의 용량이 w일 때 (w<=W)의 최대 가치.


재귀적으로 정리하면

```
K[i,w]
    if(i==0 || w==0)
        0
    if(wi > w)    // 담지 못하는 상황
        K[i-1, w]
    if(i > 0 && wi <= w)    // 담을 수 있는 상황.
        max(vi + K[i-1, w-wi], K[i-1,w])    // 실제로 담거나, 담지 않거나
```

i번째 물건을 고려할 때,

- 담지 못하는 상황: 최적해는 물건 i를 포함하지 않는다.
  
  - 전체 가치는 그 전 (i-1까지)와 동일하다.

- 담을 수 있는 상황: 최적해는 물건 i를 포함한다.
  
  - 전체 가치는 물건 i의 가치와 그 전까지를 고려해, 배낭의 용량이 w-wi인 경우의 최대 가치

2개의 부분문제, K[i-1, w-wi]와 K[i-1,w]가 미리 계산되어 있어야만 K[i,w]를 계산할 수 있다.


