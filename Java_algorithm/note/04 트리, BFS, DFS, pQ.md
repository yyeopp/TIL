# 트리

1. 트리의 개념
   ● 비선형 구조
   ☞ 비선형 자료구조로 그래프와 트리가 있는데, 그래프는 n:n이고 그걸 제한한 게 트리라고 보면 됨
   ● 원소들 간에 1:n 관계를 가지는 자료구조
   ● 원소들 간에 계층관계를 가지는 계층형 자료구조 – 상위, 하위 관계 존재
   ● 상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조

2. 트리 – 용어 정의
   ● 노드: 트리의 원소. 트리의 구성요소.
   ☞ 트리는 노드들로 이루어진다.
   ● 한 개 이상의 노드로 이루어진 유한집합이다.
   ● 노드 중 최상위 노드를 루트라고 한다.
   ☞ 루트만 찾으면 전체 트리를 전부 찾아낼 수 있다. LinkedList의 헤드와 동일한 기능.
   ● 나머지 노드들은 n개의 분리집합 T1~~TN으로 분리될 수 있다.
   ☞ T1~~TN에 대해 루트에 대한 연결을 끊으면 그 자체가 또 하나의 트리가 된다.
   ☞ 재귀적 정의라고 볼 수 있음. 이를 루트의 부 트리(subtree)라고 한다.
   ● 각 노드의 가장 끝에 있는 노드를 leaf node, 단말노드라고 한다.
   ☞ 루트에서 leaf까지 가는 거리는 당연히 트리마다 제각각이다.
   ● 노드와 노드를 연결하는 선을 간선(edge)라고 부른다.

● 형제 노드(sibling node): 같은 부모 노드의 자식 노드들
● 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
● 서브트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 subtree
● 자손 노드: 서브 트리에 있는 하위 레벨의 노드들.

● 차수
☞ 노드의 차수: 노드에 연결된 자식 노드의 수 = 노드 하방에 달려있는 간선의 수
☞ 트리의 차수: 트리에 있는 노드의 차수 중 가장 큰 값cf）이진 트리: 모든 노드의 차수가 최대 2 이하인 트리
☞ 단말 노드: 차수가 0인 노드. 자식 노드가 없는 노드
● 높이
☞ 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 “레벨”
☞ 트리의 높이: 트리에 있는 노드의 높이 중 가장 큰 값. “최대 레벨”

# 이진트리

1. 정의
   ● 최대 차수가 2인 트리
   ● 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있다.
   ☞ 아예 왼쪽과 오른쪽 자식 노드라고 말할 수 있어짐.
   ☞ 탐색이나 구현 과정이 일반적인 1:n 트리에 비해 편리해진다. 배열로도 구현이 가능하다고.

2. 이진트리 – 특성
   ● 높이 i(레벨 i)에서의 노드 최대 개수는 2^i개.
   ● 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개. 최대 개수는 2^(h+1)-1개.
   ☞ 최소는 그냥 하나씩만 줄 세운 경우. 최대는 노드당 2개씩 꽉 채운 경우.
   ☞ 알고리즘 문제에서 depth가 주어진다면 배열의 크기를 그에 맞춰서 최대로 잡으면 된다.

3. 이진트리 – 종류
   ● 포화 이진 트리: 모든 레벨에서 노드가 포화 상태로 꽉 차 있는 이진 트리
   ☞ 높이가 h일 때 최대 노드 개수인 2^(h+1)-1개의 노드를 가진다.
   ☞ 루트를 1번으로, 각 노드마다 정해진 위치에 대한 노드 번호를 가진다.
   ☞ 인덱스가 뚜렷하고 규칙적으로 증가하므로 배열 구현이 쉬움.
   ● 완전 이진 트리: 포화 이진 트리의 노드 1번부터 n번까지 빈 자리가 없는 이진 트리.
   ☞ 포화 이진 트리 노드 개수가 무조건 2^n라고 한다면 완전 이진 트리는 그게 아닌 것
   ☞ 현재 존재하는 노드까지만 포화 이진 트리의 조건을 만족시켰으면 된다.
   ● 편향 이진 트리: 높이에 대한 최소 개수의 노드를 가지면서, 한쪽 방향의 자식 노드만을 가진 이진 트리.
   ☞ 왼쪽 편향, 오른쪽 편향 이진 트리로 분류 가능
   ☞ 트리보다는 선형 자료구조에 가까워지긴 함.

4. 이진트리의 표현: 배열
   ● 루트에 번호 1을 부여하고, 각 자식 노드의 번호를 순서대로 부여
   ● 레벨 n에 있는 노드는 왼쪽부터 2^n부터 2^(n+1)-1까지의 번호가 차례로 부여됨.
   ● 논리적으로는 비선형 자료구조인데 물리적 구현은 선형 자료구조, 배열이 되는 것.루트를 빼고는, 배열 상 바로 뒤에 있는 자료가 자신의 자식이 아니라는 점이 중요
   ● 인덱스 계산이 철저해야 함: 현재 노드를 기준으로 인덱스에 2를 곱하면 왼쪽, *2+1하면 오른쪽 자식 노드의 인덱스 도출이 가능한 점.

5. 배열을 이용한 이진트리
   ● 노드 번호의 성질
   ☞ 노드 번호가 n인 노드의 부모 노드 번호는 n/2
   ☞ 노드 번호 n의 자식 노드 번호는 2*n과 2*n+1
   ☞ 레벨 n의 노드 번호 시작은 2^n부터. 끝은 2^(n+1)-1
   ● 높이가 h인 이진 트리를 위한 배열의 크기는?
   ☞ 레벨 n의 최대 노드 수는 2^n
   ☞ 모든 노드의 수는 2^(n+1)-1
   ☞ 배열 크기는 2^(n+1). 0번 인덱스를 제외할 필요가 있으므로
   ● 편향 이진트리라면?
   ☞ 완전 이진트리처럼 배열에 넣는 게 아무래도 일반적.
   ☞ 하지만 필연적으로, 사용하지 않는 배열 원소에 대한 메모리 공간 낭비가 발생
   ☞ 트리 중간에 새로운 노드를 삽입하거나 기존 노드를 삭제할 경우 배열의 크기 변경이 어렵다.근데 배열을 사용하는 이상 해결이 불가능

6. 비선형 자료구조 완전탐색
   ● 비선형구조인 트리, 그래프의 각 노드를 중복되지 않게 전부 방문하는 것.
   ● 비선형구조는 선형구조와 달리 선후 연결 관계를 알 수 없기 때문에, 특별한 방법이 필요
   ● 너비 우선 탐색(BFS), 깊이 우선 탐색(DFS)으로 나뉨

# 트리 탐색 – BFS

1. BFS
   ● 너비 우선 탐색. 트리에 대한 완전 탐색
   ● 루트 노드의 자식 노드들을 모두 차례로 방문한 후, 방문했던 자식 노드들을 기준으로 다시 해당 노드의 자식 노드들을 차례로 방문하는 방식.
   ● 인접한 노드들에 대해 탐색한 후 “다시” 차례로 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 queue를 활용해야 한다.
   ● 자식노드 ABCD를 방문했으면 큐에 그걸 담아뒀다가 A의 자식노드, B의 자식노드 ... 순서로 방문하는 것

2. BFS 알고리즘
   ● 큐 생성
   ● 루트 노드를 큐에 삽입: 다른 노드들과 차별화할 필요 없이 같은 로직을 적용. 대신 반복문 밖에서.
   ● while(큐가 비어있지 않은 경우) 반복 시작: 방문해야 할 노드가 있다면
   ☞ poll로 큐의 첫 원소(t)를 반환 및 방문
   ☞ for(t와 연결된 모든 간선에 대해): t의 자식노드들을 큐에 삽입하고 end

● 결과적으로 레벨(높이, 너비) 순서대로 모든 노드 탐색이 가능해짐.

# DFS(Depth First Search)

1. DFS
   ● 깊이 우선 탐색
   ● 루트 노드에서 출발, 한 방향으로 갈 수 있는 경로가 있는 곳까지 (리프 노드까지) 깊이 탐색해 나가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 노드로 되돌아와서 다른 방향의 노드로 탐색을 계속 반복, 결국 모든 노드를 방문하게 되는 순회방법.
   ● 가장 마지막에 만났던 갈림길의 노드로 되돌아가서 다시 깊이 우선 탐색을 반복해야하므로, 재귀적으로 구현하거나 후입선출 구조의 스택을 사용해서 구현.
   ☞ flat하게 생각했을 때, 각 노드의 기능은 어디까지나 해당 노드의 자식 노드를 탐색하는 데 멈춘다.
   ☞ 이걸 활용해서 재귀로 구현

2. DFS 알고리즘
   DFS(v)
   v 방문;
   for(v의 모든 자식노드 w) {
   
   ```
   DFS(w);        // 이걸로 재귀.
   ```
   
   }
   end DFS();
   ● BFS에서 while에 해당하던 알고리즘이랑 아주 많이 다르지는 않다.
   ☞ 문제에 따라서 BFS, DFS 중 아무거나 사용해도 되는 문제가 있는데, 완전탐색이 중요할 뿐 순서가 중요하지 않으면 그렇다. 가독성과 속도, 메모리를 고려해서 취사선택하면 될 것.

# 이진트리 – 순회(traversal)

1. 순회
   ● 순회: 트리의 노드들을 체계적으로 방문하는 것
   ● 3가지 기본적인 순회방법
   ☞ 전위순회(VLR): 부모노드 방문 후, 자식노드를 좌우 순서로 방문
   ☞ 중위순회(LVR): 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순서로 방문
   ☞ 후위순회(LRV): 자식노드를 좌우 순서로 방문한 후, 부모노드를 방문

2. 수식트리
   ● 수식을 표현하는 이진트리: 수식 이진 트리라고도 함.
   ● 연산자는 루트 노드이거나 가지 노드
   ● 피연산자는 모두 leaf node, 부모 노드에는 모두 연산자가 위치

3. 수식트리의 순회
   ● 중위, 후위, 전위 순회가 모두 가능. 식의 표기법이 달라지는 효과.

# 힙(heap)

1. 힙
   ● “완전 이진트리”에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
   ● 자바에서는 PriorityQueue라는 객체로 힙이 구현되어 있음.
   ☞ 무슨 우선순위? “최대”나 “최소”가 우선순위. 그걸 기준으로 자료를 뽑아내는 queue라는 뜻
   ● 최대 힙: 키 값이 가장 큰 노드를 찾기 위한 완전 이진트리
   ☞ 부모 노드의 키 값이 자식 노드의 키 값보다 무조건 커야 한다.
   ☞ 결국 키 값이 가장 큰 노드는 “루트 노드”가 됨.
   ● 최소 힙: 키 값이 가장 작은 노드를 찾기 위한 완전 이진트리
   ☞ 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작아야 한다.
   ☞ 키 값이 가장 작은 노드는 “루트 노드”.

2. 힙 연산 – 삽입
   ● 완전 이진트리가 기존의 힙으로 주어진 상황
   ● 새로 추가할 원소 – 일단 추가할 자리를 리프노드에 만듦
   ● 원소를 일단 추가하고, 그 부모랑 비교
   ☞ 부모가 더 크다면, 그대로 유지
   ☞ 부모가 더 작다면, 추가된 원소와 부모 원소의 자리를 교체부모 노드가 더 클 때까지 반복
   ☞ 혹시 가장 크다면 루트 노드까지 연속적으로 교체. (이게 최악의 상황)
   ● 노드 7개짜리 힙에 키 값이 가장 큰 원소가 새로 들어갈 때, 단 2번의 연산으로 최대 힙을 완성할 수 있다.
   ☞ 연산이 대략 logN으로 줄어드는 효과가 나타난다는 것. (log의 밑은 2)

3. 힙 연산 – 삭제
   ● 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
   ● 루트 노드의 원소를 삭제해서 반환
   ☞ poll()을 활용하는 것.
   ● 힙의 종류에 따라, 최대값 또는 최소값을 구할 수 있다.

최대힙에서의 삭제:
● 루트의 원소값 삭제
● 마지막 노드(리프 노드 중 인덱스 상 마지막)를 삭제해서 루트에 삽입
● 루트 노드에 들어간 값이 최대일 가능성은 없음
☞ 자식 노드의 값과 비교해서 자리 바꾸기를 연속적으로 수행.
☞ 이 때 비교 대상은 “우측” 자식 노드가 우선. 그래야 가장 마지막 노드를 찾을 수 있음
● 결과적으로, 이 때도 연산이 대략 logN으로 줄어들 수 있다.

4. 힙의 활용1: 우선순위 큐(Priority Queue)
   ● 우선순위 큐를 구현하는 가장 효율적인 방법이, 힙을 사용하는 것.
   ☞ 노드 하나를 추가/삭제할 때의 시간복잡도가 O(logN)이고 최대값/최소값은 O(1)에 구현 가능
   ☞ 완전 정렬보다 관리비용이 적다.
   ● 힙은 어디까지나 완전 이진트리이므로 배열을 통해 트리 형태를 쉽게 구현할 수 있음.
   ☞ 부모나 자식 노드를 O(1) 연산으로 쉽게 찾음
   ☞ n위치에 있는 노드의 자식은 2n과 2n+1에 존재한다는 점
   ☞ 완전 이진트리의 특성에 의해, 추가/삭제의 위치 또한 인덱스로 쉽게 판단할 수 있다는 점.
   ● 우선순위 큐의 특성: 우선순위를 가진 항목들을 저장하는 큐.

● java.util.PriorityQueue: 자바에서 지원하는 Heap 자료구조. 생성자에 매개변수를 어떻게 넣는지에 따라 구현 방식이 다를 수 있음.
☞ (): 원소들의 natural ordering에 따라 heap이 유지됨.원소들이 스스로 타원소와 자신을 비교하는 기능을 갖고 있다는 뜻그게 가능하려면, 반드시 모든 원소가 “Comparable“ 인터페이스를 구현해야 한다.
☞ (Comparator comparator): 명시된 Comparator의 구현에 따라 원소들의 순서를 유지.comparable 인터페이스를 구현할 필요가 없다. comparator가 도와주기 때문
