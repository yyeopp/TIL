# JavaScript

## JavaScript 소개

### JavaScript 개요

- 프로토타입 기반의 스크립트 프로그래밍 언어로, **객체지향** 개념을 지원한다.

- 웹 브라우저가 JS를 HTML과 함께 다운로드 하여 실행한다.

- 브라우저가 HTML 문서를 읽어들이는 시점에 JS engine이 실행된다.

- 대부분의 JS engine은 ECMAScript 표준을 지원한다.

### ECMAScript

- IE와 Netscape 양강 시절 JS 엔진을 각기 만들어서 지원함

- JS 표준화 요구가 커지다가, ECMAScript 기술 규격이 표준화됨

### JS의 특징

- HTML, CSS와 함께 웹을 구성하는 요소 중 하나. 웹 브라우저에서 동작하는 유일한 프로그래밍 언어.

- 개발자가 별도의 컴파일 작업을 수행하지 않는, 인터프리터 언어이다.
  
  - 상단부터 차례로 실행되는 언어라는 뜻

- 각 브라우버 별 JS 엔진은 인터프리터와 컴파일러의 장점을 결합하여, 비교적 처리속도가 느린 인터프리터의 단점을 해결함

- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.

------

## JavaScript 시작

### JavaScript 선언

- HTML에서 JS를 사용하려면, <script>태그를 사용
  
  - 태그 안쪽에 JS 코드를 직접 작성하는 것도 가능
  
  - head나 body 안 어느 곳에서나 선언 가능함

- script 태그는 src와 type 속성을 사용해서 JavaScript를 선언.

- src 속성은 외부의 JS 파일을 html 문서에 포함할 때 사용

- type 속성은 미디어 타입 지정 시 사용. text/javascript로 지정

- script 태그는 body 안, 끝부분에 둘 것이 권장된다.
  
  - head 부분에 JS를 두면 head를 다운로드하는 시간이 길어져서 사용자가 느리다고 느낀다.

-----

## JavaScript 기본문법

### 주석

- `//`로 주석다는 거 java랑 똑같다.

### 변수(variable)

- 변수 선언 시 **타입 명시하지 않고 var를 사용**

- JS는 **동적타입(Dynamic / Weak type) 언어**. 변수의 타입 지정 없이, 값이  할당되는 과정에서 **자동으로** 변수의 타입이 결정
  
  - 같은 변수에 여러 타입의 값을 할당 가능하다.
  
  - x를 10으로 초기화했다가 "java"로 초기화하는 것도 가능하다는 것 - 솔직히 단점에 가까움

- 변수 이름은 함수 이름과 혼동되지 않도록, 유일한 이름을 사용하자.
  
  - 변수[형용사, 명사], 함수[동사] 사용

- JS는 ECMA 표준에 따라 낙타 표기법(camel case) 사용
  
  - 낙타 표기법: 기본적으로 소문자, 2개 이상 단어 조합 시 첫 글자 대문자 표기

- 특수문자는 _와 $를 허용.

### 자료형(data type)

- 프로그램은 정적인 데이터 값을 동적으로 변환해가면서 우너하는 정보를 얻는다.

- JS에서는 자료형을 원시형(primitive)과 객체타입(object)으로 분류

- 원시타입에는 5가지가 있다.
  
  - 숫자형(number), 문자열형(string), boolean형,(boolean) undefined(undefined), null(object)
    
    - 자바와 다른 점: string이 primitive, undefined의 존재
    
    - undefined는, 변수가 선언되었지만 초기화가 되지 않은 경우에 해당
  
  - 이를 제외한 모든 값은 객체 타입.

#### 숫자

- 정수와 실수를 나누어 구분하지 않고 있다.
  
  - 모든 숫자를 8byte의 실수 형태로 처리..
  
  - 편의성을 위해 정수 리터럴과 실수 리터럴은 제공

- 언더플로우, 오버플로우, 0으로 나누는 연산에 대해 예외를 발생시키지 않는다.

- 숫자와 관련된 특별한 상수가 존재한다.
  
  - Infinity: 무한대를 나타내는 상수
    
    - ex) -100을 0으로 나누면 -Infinity라는 결과값이 출력된다.
  
  - NaN: 계산식의 결과가 숫자가 아님을 나타내는 상수

- `console.log()`에 parseInt 메서드를 실행시킬 수 있는데, 이 또한 앞에서부터 실행되고 있기 때문에 "1A"를 집어넣어도 잘 돌아간다.
  
  - "A1" 넣으면 NaN으로 뜬다.

#### 문자열

- 16비트의 unicode 문자를 사용한다.

- char 문자형은 따로 없다. '와 ''를 혼용할 수 있다.

- 자바에서 사용했던 \ 관련 특수문자들 모두 사용 가능하다.

- ES6부터 `을 활용하는 문자열도 지원하게 됐다.
  
  - 긴 문자열을 표현할 때 "으로만 표현하면 불편한 점이 발생하는 것을 해결.
  
  - 변수는 $표시로 접근할 수 있다.

#### boolean, null, undefined

- boolean을 T나 F 중 하나의 값을 가진다.

- **비어 있는 문자열, null, undefined, 숫자 0은 false로 간주된다.**
  
  - ex) if() 안쪽에 null에 해당하는 string을 넣어도 작동한다는 것

- null은 값이 없거나 비어 있음을 뜻하고,

- undefined는 값이 초기화되지 않았음을 의미.
  
  - 둘의 의미가 비슷하지만, 값을 할당하지 않은 변수에는 undefined가 할당되고 **(시스템레벨)**, 코드에서 명시적으로 값이 없음을 나타낼 때 **(프로그램 레벨)** 는 null을 사용.
  - 사용자가 undefined라는 값을 스스로 코딩하는 것은 불가능하다.

#### 자동 형 변환

- 자료형에 대해 매우 느슨한 규칙이 적용되고 있음.

- 어떤 자료형이든 var에 전달할 수 있고, 그 형을 필요에 따라 변환 가능.

- 서로 다른 자료형 간의 연산도 가능.
  
  - 변수 선언은 쉽지만, 혼란을 쉽게 야기한다.

#### 변수 호이스팅(variable hoisting)

- var 키워드를 사용한 변수는 중복 선언이 가능

- **호이스팅**: var 선언문이나 function 선언문 등 **모든 선언문이 해당 scope의 처음으로 옮겨진 것처럼 동작**하는 특성.
  
  - 즉 JS는 모든 선언문이 선언되기 이전에 참조가 가능하다.

- 변수의 생성 과정
  
  - **선언** 단계: 변수 객체에 변수를 등록
  
  - **초기화** 단계: 변수 객체에 등록된 변수를 메모리에 할당. **undefined**로 초기화됨.
    
    - 위 두 단계는 호이스팅에 의해 한번에 이루어짐.
  
  - **할당** 단계: undefined로 초기화된 변수에 실제 값을 할당.

```javascript
console.log(num);    // undefined
var num = 123;
console.log(num);    // 123
```

- num이 선언되지 않았기 때문에 error가 발생하는 게 아니고, **undefined라고 출력된다**.

#### 상수(constant)

- ES6 이후 지원하기 시작됨

- let과 const 키워드가 추가되어, var와 구분해서 사용 가능하다.
  
  - var: 전역 스코프에서 선언, 재선언 가능
  
  - let: 변수, 지역 스코프에서 선언, 재선언 불가능
  
  - const: 상수, 지역 스코프에서 선언, 재선언 불가능
    
    - const는 값 변경도 불가능.

- var보다는 let을 사용하는 게 좀더 편리하다. java에서 하던 문법과 보다 비슷해지기 때문

### 연산자

- 산술, 비교, 논리, 기타 연산자 제공

- 우선순위 존재, 괄호로 조절 가능

- 딱 하나 눈여겨 볼 것: **delete**
  
  - JS는 이미 만들어진 객체의 속성을 동적으로 추가/제거할 수 있다.
  
  - delete 연산은 객체의 프로퍼티를 제거하는 연산.

- 연산자는 연산의 대상이 되는 값(타입)에 따라서 동작이 결정된다.

- 특히 '+' 연산자.
  
  - 값이 모두 숫자면 산술 연산을 수행
  
  - 대상 중에 문자열이 포함된 경우, **모든 연산 대상을 문자열로 변환하고** 문자열끼리 결합.

- 타입 간 형변환이 하도 flexible하기 때문에, ===랑 !== 연산자가 추가되어 있다.
  
  - **타입포함** 일치하는지 여부를 검사하는 연산자.

### 조건문

- if, switch 모두 java랑 동일하다.

### 반복문

- while, do~while 모두 java랑 동일하다.

- for문에서 하나 눈여겨 볼 부분이 있음

```javascript
for(var 변수 in 배열 or 객체) {
}
```

- 객체의 property를 순회하면서 동작하는 게 가능하다는 점

### 객체

#### 개요

- 객체는 이름과 값으로 구성된 **프로퍼티의 집합**
  
  - key와 value로 이루어져 있다.

- primitive data type을 제외한 모든 값은 객체.

- 전역 객체를 제외한 JS 객체는, 프로퍼티를 동적으로 추가하거나 삭제할 수도 있다.

- JS의 함수는 **일급 객체**이므로 **값으로 사용할 수 있다.**
  
  - JS에서는 함수(method)도 객체다.
  
  - 프로퍼티의 값으로 함수를 사용 가능하다.

#### 생성방식

- **객체 리터럴**
  
  - 가장 일반적인 방법
  
  - {} 안에다가 내용을 구성한다. 자바에서 class 만드는 거랑 같음
    
    - 대신 자료형이 여전히 var라는게 특이한 점.
  
  - 프로퍼티를 채울 때 그 중에 **함수**를 넣어줘도 된다.
    
    - 객체 안에 객체를 넣는다고 생각하면 어색하지 않다.

- **Object 생성자 함수**
  
  - new Object(); 라고 하면서 empty object를 생성하는 방식.
  
  - 그러고 나서 .name 같은 식으로 프로퍼티를 하나씩 추가해줄 수 있다.
    
    - object 내부에 name이라는 속성을 만든 적이 없지만 알아서 생성되어 들어간다. 
    
    - 반대로 삭제도 가능

- **생성자 함수**
  
  - 자바에서 생성자 만들 듯이 해주는 것.
  
  - **JS에서는 함수도 객체다!**
    
    - 자바에서는 객체 -> 생성자 순서였지만,
    
    - JS에서는 생성자 -> 객체 순서로 가도 무방하다는 것

#### 속성 값 조회

- 객체는 .을 이용하거나 []를 사용해서 속성값에 접근한다.
  
  - `member.age`랑 `member["age"]`랑 같은 효과다.
  
  - 단, 속성명에 연산자(- 같은 것)가 포함되면 JS 특성 상 [] 표기법으로만 접근 가능하다.

- 객체에 없는 속성에 접근하면 undefined를 띄운다.

#### 속성 값 변경, 추가, 제거

- 변경 시 .이나 [] 사용
  
  - 생성하는 문법이 따로 없기 때문에, 변경을 목적으로 사용했을 때 해당 속성이 없으면 그 속성이 **알아서 추가된다.**

- **delete 연산자**를 이용해서 속성 제거도 가능하다.
  
  - 변경이나 생성도 자유롭게 가능하니까 삭제도 못할 이유가 없다.

#### 참조

- 객체는 복사되지 않고 참조된다.
  
  - 자바에서 *call by reference*와 같은 내용

- JS에서 primitive 데이터 타입이 아닌 모든 값은 참조 타입.
  
  - error 같은 것도 모두 포함

### 함수

#### 선언, 호출

- JS에서 함수는 **일급** 객체이다.

- 함수를 **변수, 객체, 배열** 등에 저장할 수 있고, 다른 함수에 전달하는 **매개변수** (전달인자, **콜백함수**) 또는 **return 값**으로 사용 가능하다.
  
  - 자바에서도 `calc()` 메서드의 return값이 int라면 다른 메서드인 `num()`에서 `num(calc())` 같이 활용은 가능하지만,
  
  - `num(calc)`는 말이 안 된다.
  
  - JS는 둘다 가능하다는 뜻. 물론 둘의 기능은 다르다.

- 함수는 프로그램 실행 중에 동적으로 생성도 가능하다.

#### 함수 호이스팅

- 함수 선언문의 경우 함수 선언의 위치와 관계없이 코드 내 어느 곳에서든지 호출 가능

- JS는 모든 선언(var, function)을 Hoisting한다.

- 함수 선언문으로 정의된 함수는 JS 엔진이 로딩되는 시점에 변수객체에 저장된다. 함수의 **선언, 초기화, 할당이 한번에 이루어진다.**
  
  - `function() {}` 으로 선언한 경우를 말함

- 함수 표현식의 경우, 함수 호이스팅이 아니라 **변수 호이스팅이 발생한다.**
  
  - `var f = function() {}` 으로 선언한 경우를 말함

- 이 둘을 잘 구분할 수 있어야 한다!
  
  - 함수 표현식 구문에 도달하기 전까지, JS 엔진은 `f`를 함수가 아니라 **undefined로 초기화된 변수라고 인식하고 있다.**

#### 

#### 매개변수

- 함수의 정의 부분에 외부로부터 전달받은 변수를 **매개변수**라 함

- 함수를 호출할 때 전달하는 값을 **전달인자**라고 함

- JS에서 함수 정의 시, 매개변수에 대한 타입은 명시하지 않는다.

- 함수를 호출할 때 정의된 매개변수와 전달인자의 개수가 일치하지 않더라고 호출 가능.
  
  - 알아서 자르거나, undefined로 넣어서 옮겨준다.

#### 콜백 함수

- 함수를 명시적으로 호출하는 방식이 아니라, 특정 이벤트가 발생했을 때, **시스템에 의해 호출되는** 함수를 말한다.
  
  - ex) click 이벤트 발생 시 호출
  - 명시적으로 호출하면 *이벤트 발생 시*가 아니라 즉시 시행되는 상황이 나타날 수 있음.

- 일반적으로 콜백 함수는 매개변수를 통해 전달되고, 전달받은 함수의 내부에서 어느 특정시점에 실행된다.
  
  - 특정 메서드에 조건이 되는 이벤트의 종류와 함수를 넣어주는 것이 대표적인 활용 방식

- 주로 비동기식 처리 모델에서 사용된다.
  
  - 호출될 함수를 미리 매개변수에 전달하고 처리가 종료되면 콜백함수를 호출한다.

- `setTimeout` 함수 잘 기억해두자.

-----

## Web Browser와 Window 객체

### Window 객체 개요

- Window 객체는 웹 브라우저에서 작동하는 JS의 최상위 전역객체이다.

- Window 객체에는 브라우저와 관련된 여러 객체와 속성, 함수가 있다.

- JS에서 기본으로 제공하는 프로퍼티와 함수도 포함

- BOM으로 불리기도 함. (Browser Object Model)

### Window 객체 사용

#### alert, confirm, prompt

- window 객체의 함수롤 호출하면 브라우저에서 open되는 창들

- alert(): 브라우저의 알림창

- confirm(): 브라우저의 확인/취소 선택창

- prompt(): 브라우저의 입력 창

#### navigator

- 브라우저의 정보가 내장된 객체

- navigator의 정보로 서로 다른 브라우저를 구분할 수 있으며, 브라우저 별로 다르게 처리 가능
  
  - PC와 모바일 환경을 구분해서 처리하는 데 사용

- HTML5에서는 위치 정보를 알려주는 역할 가능.

#### location, history

- location 객체를 이용하여, 현재 페이지 주소(URL)와 관련된 정보들을 알 수 있다.
  
  - location.href: 프로퍼티에 값을 할당하지 않으면, 현재 URL을 조회하고 할당된 URL로 페이지 이동
  
  - location.reload(): 현재 페이지를 새로고침

- history 객체는 브라우저의 페이지 이력을 담는 객체
  
  - back()과 forward()는 뒤/앞으로 가는 동작

### 새 창 열기

- window 객체의 open() 함수를 사용하면 새 창을 열 수 있다.

- `window.open('페이지 URL', '창이름', '특성', '히스토리 대체여부');`
  
  - 창이름(string): open할 대상. 창의 이름. 중복 open을 방지
  
  - 특성: 창의 너비, 높이 등 특성 지정
  
  - 히스토리 대체여부: 현재 페이지 히스토리에 덮어쓸 지 여부

- 이벤트를 이용해 특정 시점에 창을 열 수도 있다.
  
  - close() 함수 사용

- window 객체의 opener 속성을 이용하면 부모 창(새 창을 연 창)을 컨트롤할 수 있다.
  
  - 부모 창에 값을 전달하거나, 새로고침하거나, 페이지 이동
  
  - 즉, opener 객체는 **부모 창의 window 객체**이다.

### window 객체 프로퍼티

- window 객체는 웹 브라우저에서 구동되는 JS의 전역 객체

- 뒤에 보게 될 document 객체는 HTML 문서 관련 객체

- scrren 객체는 화면의 가로, 세로 크기 정보를 알려줌

- self, history, location, opener, document 등등

### window 객체 함수

- 버튼으로 제공하는 기능인 find, stop, print 같은 함수들

- resize 함수는 현재 열려있는 창의 크기 조절

- 순수 JS에서 필요한 객체나 함수도 존재
  
  - setTimeouot이나 setInterval 같은 함수들





----

## HTML과 DOM

### DOM 개요

- Document Object Model.

- HTML과 XML 문서의 구조를 정의하는 API를 제공

- 문서 요소 집합을 트리 형태의 계층 구조로, HTML을 표현

- HTML 계층 구조의 제일 위에는 document 노드가 있다.
  
  - document. 으로 접근하는 상황이 굉장히 잦다.

- 그 아래로는 HTML 태그나 요소(element)들을 표현하는 노드와, 문자열을 표현하는 노드가 있다.



### 문서 객체 만들기

- text node를 갖는 객체와 갖지 않는 객체로 나뉜다.

- `createElement(tagName)`, `createTextNode(test)`, `appendChild(node)`
  
  - 이름 그대로 node를 생성하는 메서드들

- `setAttribute(name,value)`, `getAttribute(name)`
  
  - 객체의 속성을 설정하는 메서드들

- `innerHTML`, `innerText`.
  
  - 문자열을 HTML 태그 또는 text node로 삽입한다.



### 문서 객체 가져오기

#### 객체 가져오기

- 다양한 기능과 목적의 메서드들이 있으니 적절히 활용해야 함

- 주의할 점: `getElement`인 경우가 있고 `getElements`인 경우가 있다.
  
  - s가 붙은 경우 element의 **배열**을 얻어오는 방식이다.

#### 객체 제거

- `removeChild(childnode)`로 객체의 자식 노드 제거가 가능

#### 요약

- DOM은 HTML 문서의 내용을 **조작할 수 있는** API로 HTML을 계층구조 형식의 객체로 표현한다.

- DOM으로 HTML문서의 검색과 조작(추가, 수정, 삭제)을 할 수 있다.
  
  - **dynamic**한 웹페이지를 만드는 방법이라고 볼 수 있다.



----

## Event

### 이벤트

- 웹 페이지에서 여러 종류의 상호작용이 있을 때마다 이벤트가 발생
  
  - 사용자가 마우스를 클릭했을 때나 키보드를 눌렀을 때 등

- JS를 사용하여 DOM에서 발생하는 이벤트를 감지, 이벤트에 대응하는 여러 작업을 수행

- 이벤트는 일반적으로 함수와 연결이 되고, 이 함수는 **이벤트가 발생되기 전에는 실행되지 않다가** 이벤트가 발생
  
  - **이벤트 핸들러(Handler)** 또는 **이벤트 리스너(Listener)** 라 하며, 이 함수이 이벤트 발생 시 실행해야 하는 코드를 작성한다.

##### 이벤트 발생의 종류

- 페이지 로딩되었을 때 

- 페이지 스크롤 

- 브라우저 창 크기 조절

- 마우스 클릭 

- 키보드 입력

- Form이 submit 되었을 때 

- input의 내용이 변경되었을 때

- 마우스를 움직여서 element를 이동할 때



### 이벤트의 종류

#### 마우스 이벤트

- 웹 어플리케이션에서 가장 많이 사용하는 이벤트

- 마우스 이벤트 핸들러에 전달되는 **이벤트 객체**에는 마우스 위치와 버튼 상태 등의 정보를 담고있다.
  
  - `onclick` 같은 이벤트들

#### 키보드 이벤트

- 키보드의 커서가 웹 브라우저에 나타나는 지점에서 키보드를 조작할 때 이벤트가 발생
  
  - `onkeypress`, `onkeydown`, `onkeyup` 등의 이벤트들
  
  - `onkeydown`은 누르는 순간 keycode 기반으로 발생
  
  - `onkeypress`는 키보드가 눌려졌을 때 ASCII 기반으로 발생
    
    - Ctrl이나 Backspace 같은 것은 ASCII가 없다. 발생하지 않을 가능성이 큼
    
    - 그래서 아예 `onkeyup`이 확실하다.

#### Frame(UI) 이벤트

- 요즘은 자주 사용하지 않는 편

- `onload` 정도를 기억하자

#### 폼 (Form) 이벤트

- 웹 브라우저에서 가장 안정적으로 동작하는 이벤트

- 자주 사용하는 이벤트로는, form이 전송될 때의 **Submit** 이벤트.

- Form을 초기화할 때는 reset 이벤트가 발생

- submit과 reset은 이벤트 핸들러에서 취소할 수 있다.

- `onsubmit`이 제일 중요할 것



### 이벤트 핸들러 등록

- 이벤트를 감지하고 대응하는 작업을 등록하는 방법은 여러가지

- 어떤 이벤트를 처리할 작업을 등록하는 것을, **이벤트 핸들러를 등록한다**라고 표현

#### 인라인 이벤트 핸들러

- JS 초기에는 HTML 요소 내부에서 직접 이벤트 핸들러를 등록.

- HTML 코드를 JS 코드가 침범한다는 문제가 있다.
  
  - 디자이너의 영역을 개발자가 침범하는 느낌

- 여러 개의 함수를 한번에 호출 가능하다는 장점

- 최근 관심받고 있는 CBD 방식의 Angular, React, Vue.js 같은 프레임웤에서는 인라인 방식으로 이벤트를 처리하기 때문에, 요즘은 다시 중요해졌다.

#### 이벤트 핸들러 프로퍼티 방식

- HTML에 직접 이벤트 핸들러를 등록하는 방법 대신, JS에서 이벤트 핸들러를 등록하는 방법

- JS에 등록함으로써 **HTML 코드와 JS 코드를 분리할 수 있다.**

- 이벤트 대상이 되는 특정 DOM을 선택하고, 이벤트 핸들러를 등록

- 단, 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 단점을 가진다.



#### addEventListener 메소드 방식

- 좀더 세밀한 이벤트 제어가 가능하게 됨

- `addEventListener (arg1, arg2[,arg3])`를 이용
  
  - 전달 인자의 첫번째에는 이벤트 이름, 두 번째에는 이벤트 핸들러, 세 번째에는 캡쳐링 여부를 사용
  
  - 첫번째 전달인자의 이벤트 이름에는, 'on'을 제거한 이벤트 이름을 사용

- 대상 DOM 요소에 이벤트를 바인딩하고, 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정한다.

- 장점
  
  - 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러 추가할 수 있다.
  
  - 캡처링과 버블링을 지원
  
  - HTML 외의 DOM에서도 동작

- 공통 규칙에 해당하는 값을 상수로 만들고,  



### 버블링과 캡쳐링



-----



## Web Storage

### Web Storage - localStorage

- 데이터를 사용자 로컬에 보존하는 방식

- 데이터를 저장, 덮어쓰기, 삭제 등 조작 가능

- **JS로만 조작 가능**

- 모바일에서도 사용 가능

##### Cookie와의 차이점

- 유효 기간이 없고 영구적으로 이용 가능

- 5MB까지 사용 가능 (쿠기는 4KB까지)

- 쿠키와는 다르게, 네트워크 요청 시 서버로 전송되지 않음

- 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없음

- 웹스토리지는, origin(프로토콜, 도메인, 포트)이 다르면 접근 불가능.



#### 기본 구성

- 키와 값 (key, value)를 하나의 세트로 저장

- 도메인과 브라우저별로 저장

- 값은 반드시 문자열로 저장됨

#### 공통 메소드와 프로퍼티

- `setItem(key, value)`, `getItem(key)`, `removeItem(key)`, `clear()` , `key(index)`, `length`등



### Web Storage - sessionStorage

- 현재 떠 있는 탭에서만 유지. 같은 페이지라도, 탭이 다르면 다른 곳에 저장

- 페이지 새로고침 시에는 데이터 유지, 탭을 닫고 새로 열 때 제거

- localStorage와 사용방법은 완전히 동일함
