# JavaScript

## JavaScript 소개

### JavaScript 개요

- 프로토타입 기반의 스크립트 프로그래밍 언어로, **객체지향** 개념을 지원한다.

- 웹 브라우저가 JS를 HTML과 함께 다운로드 하여 실행한다.

- 브라우저가 HTML 문서를 읽어들이는 시점에 JS engine이 실행된다.

- 대부분의 JS engine은 ECMAScript 표준을 지원한다.



### ECMAScript

- IE와 Netscape 양강 시절 JS 엔진을 각기 만들어서 지원함

- JS 표준화 요구가 커지다가, ECMAScript 기술 규격이 표준화됨



### JS의 특징

- HTML, CSS와 함께 웹을 구성하는 요소 중 하나. 웹 브라우저에서 동작하는 유일한 프로그래밍 언어.

- 개발자가 별도의 컴파일 작업을 수행하지 않는, 인터프리터 언어이다.

- 각 브라우버 별 JS 엔진은 인터프리터와 컴파일러의 장점을 결합하여, 비교적 처리속도가 느린 인터프리터의 단점을 해결함

- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.



------

## JavaScript 시작

### JavaScript 선언

- HTML에서 JS를 사용하려면, <script>태그를 사용
  
  - 태그 안쪽에 JS 코드를 직접 작성하는 것도 가능
  
  - head나 body 안 어느 곳에서나 선언 가능함

- script 태그는 src와 type 속성을 사용해서 JavaScript를 선언.

- src 속성은 외부의 JS 파일을 html 문서에 포함할 때 사용

- type 속성은 미디어 타입 지정 시 사용. text/javascript로 지정



- script 태그는 body 안, 끝부분에 둘 것이 권장된다.
  
  - head 부분에 JS를 두면 head를 다운로드하는 시간이 길어져서 사용자가 느리다고 느낀다.



-----

## JavaScript 기본문법

### 주석

- `//`로 주석다는 거 java랑 똑같다.

### 변수(variable)

- 변수 선언 시 **타입 명시하지 않고 var를 사용**

- JS는 **동적타입(Dynamic / Weak type) 언어**. 변수의 타입 지정 없이, 값이  할당되는 과정에서 **자동으로** 변수의 타입이 결정
  
  - 같은 변수에 여러 타입의 값을 할당 가능하다.
  
  - x를 10으로 초기화했다가 "java"로 초기화하는 것도 가능하다는 것 - 솔직히 단점에 가까움

- 변수 이름은 함수 이름과 혼동되지 않도록, 유일한 이름을 사용하자.
  
  - 변수[형용사, 명사], 함수[동사] 사용

- JS는 ECMA 표준에 따라 낙타 표기법(camel case) 사용
  
  - 낙타 표기법: 기본적으로 소문자, 2개 이상 단어 조합 시 첫 글자 대문자 표기

- 특수문자는 _와 $를 허용.



### 자료형(data type)

- 프로그램은 정적인 데이터 값을 동적으로 변환해가면서 우너하는 정보를 얻는다.

- JS에서는 자료형을 원시형(primitive)과 객체타입(object)으로 분류

- 원시타입에는 5가지가 있다.
  
  - 숫자형(number), 문자열형(string), boolean형,(boolean) undefined(undefined), null(object)
    
    - 자바와 다른 점: string이 primitive, undefined의 존재
    
    - undefined는, 변수가 선언되었지만 초기화가 되지 않은 경우에 해당
  
  - 이를 제외한 모든 값은 객체 타입.

#### 숫자

- 정수와 실수를 나누어 구분하지 않고 있다.
  
  - 모든 숫자를 8byte의 실수 형태로 처리..
  
  - 편의성을 위해 정수 리터럴과 실수 리터럴은 제공

- 언더플로우, 오버플로우, 0으로 나누는 연산에 대해 예외를 발생시키지 않는다.

- 숫자와 관련된 특별한 상수가 존재한다.
  
  - Infinity: 무한대를 나타내는 상수
    
    - ex) -100을 0으로 나누면 -Infinity라는 결과값이 출력된다.
  
  - NaN: 계산식의 결과가 숫자가 아님을 나타내는 상수

- `console.log()`에 parseInt 메서드를 실행시킬 수 있는데, 이 또한 앞에서부터 실행되고 있기 때문에 "1A"를 집어넣어도 잘 돌아간다.
  
  - "A1" 넣으면 NaN으로 뜬다.

#### 문자열

- 16비트의 unicode 문자를 사용한다.

- char 문자형은 따로 없다. '와 ''를 혼용할 수 있다.

- 자바에서 사용했던 \ 관련 특수문자들 모두 사용 가능하다.

- ES6부터 `을 활용하는 문자열도 지원하게 됐다.

#### boolean, null, undefined

- boolean을 T나 F 중 하나의 값을 가진다.

- **비어 있는 문자열, null, undefined, 숫자 0은 false로 간주된다.**
  
  - ex) if() 안쪽에 null에 해당하는 string을 넣어도 작동한다는 것

- null은 값이 없거나 비어 있음을 뜻하고,

- undefined는 값이 초기화되지 않았음을 의미.
  
  - 둘의 의미가 비슷하지만, 값을 할당하지 않은 변수에는 undefined가 할당되고 **(시스템레벨)**, 코드에서 명시적으로 값이 없음을 나타낼 때 **(프로그램 레벨)** 는 null을 사용.

#### 자동 형 변환

- 자료형에 대해 매우 느슨한 규칙이 적용되고 있음.

- 어떤 자료형이든 var에 전달할 수 있고, 그 형을 필요에 따라 변환 가능.

- 서로 다른 자료형 간의 연산도 가능.
  
  - 변수 선언은 쉽지만, 혼란을 쉽게 야기한다.

#### 변수 호이스팅(variable hoisting)

- var 키워드를 사용한 변수는 중복 선언이 가능

- **호이스팅**: var 선언문이나 function 선언문 등 모든 선언문이 해당 scope의 처음으로 옮겨진 것처럼 동작하는 특성.
  
  - 즉 JS는 모든 선언문이 선언되기 이전에 참조가 가능하다.

- 변수의 생성 과정
  
  - **선언** 단계: 변수 객체에 변수를 등록
  
  - **초기화** 단계: 변수 객체에 등록된 변수를 메모리에 할당. **undefined**로 초기화됨.
    
    - 위 두 단계는 한번에 이루어짐.
  
  - **할당** 단계: undefined로 초기화된 변수에 실제 값을 할당.

```javascript
console.log(num);
var num = 123;
```

- num이 선언되지 않았기 때문에 error가 발생하는 게 아니고, **undefined라고 출력된다**.



#### 상수(constant)

- ES6 이후 지원하기 시작됨

- let과 const 키워드가 추가되어, var와 구분해서 사용 가능하다.
  
  - var: 전역 스코프에서 선언, 재선언 가능
  
  - let: 해당 스코프에서 선언, 재선언 불가능
  
  - const: 해당 스코프에서 선언, 재선언 불가능
    
    - const는 값 변경도 불가능.

- var보다는 let을 사용하는 게 좀더 편리하다. java에서 하던 문법과 보다 비슷해지기 때문



### 연산자

- 산술, 비교, 논리, 기타 연산자 제공

- 우선순위 존재, 괄호로 조절 가능

- 딱 하나 눈여겨 볼 것: **delete**
  
  - JS는 이미 만들어진 객체의 속성을 동적으로 추가/제거할 수 있다.
  
  - delete 연산은 객체의 프로퍼티를 제거하는 연산.



- 연산자는 연산의 대상이 되는 값(타입)에 따라서 동작이 결정된다.

- 특히 '+' 연산자.
  
  - 값이 모두 숫자면 산술 연산을 수행
  
  - 대상 중에 문자열이 포함된 경우, **모든 연산 대상을 문자열로 변환하고** 문자열끼리 결합.

- 타입 간 형변환이 하도 flexible하기 때문에, ===랑 !== 연산자가 추가되어 있다.
  
  - **타입포함** 일치하는지 여부를 검사하는 연산자.



### 조건문

- if, switch 모두 java랑 동일하다.



### 반복문

- while, do~while 모두 java랑 동일하다.

- for문에서 하나 눈여겨 볼 부분이 있음

```javascript
for(var 변수 in 배열 or 객체) {
}
```

- 객체의 property를 순회하면서 동작하는 게 가능하다는 점



### 객체

#### 개요

- 객체는 이름과 값으로 구성된**프로퍼티의 집합**
  
  - key와 value로 이루어져 있다.

- primitive data type을 제외한 모든 값은 객체.

- 전역 객체를 제외한 JS 객체는, 프로퍼티를 동적으로 추가하거나 삭제할 수도 있다.

- JS의 함수는 **일급 객체**이므로 값으로 사용할 수 있다.
  
  - JS에서는 함수(method)도 객체다.
  
  - 프로퍼티의 값으로 함수를 사용 가능하다.



#### 생성방식

- **객체 리터럴**
  
  - 가장 일반적인 방법
  
  - {} 안에다가 내용을 구성한다. 자바에서 class 만드는 거랑 같음
    
    - 대신 자료형이 여전히 var라는게 특이한 점.
  
  - 프로퍼티를 채울 때 그 중에 **함수**를 넣어줘도 된다.
    
    - 객체 안에 객체를 넣는다고 생각하면 어색하지 않다.

- **Object 생성자 함수**
  
  - new Object(); 라고 하면서 empty object를 생성하는 방식.
  
  - 그러고 나서 .name 같은 식으로 프로퍼티를 하나씩 추가해줄 수 있다.
    
    - object 내부에 name이라는 속성을 만든 적이 없지만 알아서 생성되어 들어간다. 
    
    - 반대로 삭제도 가능

- **생성자 함수**
  
  - 자바에서 생성자 만들 듯이 해주는 것.
  
  - **JS에서는 함수도 객체다!**
    
    - 자바에서는 객체 -> 생성자 순서였지만,
    
    - JS에서는 생성자 -> 객체 순서로 가도 무방하다는 것

#### 속성 값 조회

- 객체는 .을 이용하거나 []를 사용해서 속성값에 접근한다.
  
  - `member.age`랑 `member["age"]`랑 같은 효과다.
  
  - 단, 속성명에 연산자(- 같은 것)가 포함되면 JS 특성 상 [] 표기법으로만 접근 가능하다.

- 객체에 없는 속성에 접근하면 undefined를 띄운다.



#### 속성 값 변경, 추가, 제거

- 변경 시 .이나 [] 사용
  
  - 생성하는 문법이 따로 없기 때문에, 변경을 목적으로 사용했을 때 해당 속성이 없으면 그 속성이 **알아서 추가된다.**

- **delete 연산자**를 이용해서 속성 제거도 가능하다.
  
  - 변경이나 생성도 자유롭게 가능하니까 삭제도 못할 이유가 없다.



#### 참조

- 객체는 복사되지 않고 참조된다.
  
  - 자바에서 *call by reference*와 같은 내용

- JS에서 primitive 데이터 타입이 아닌 모든 값은 참조 타입.
  
  - error 같은 것도 모두 포함



### 함수

#### 선언, 호출

- JS에서 함수는 **일급** 객체이다.

- 함수를 **변수, 객체, 배열** 등에 저장할 수 있고, 다른 함수에 전달하는 **매개변수** (전달인자, **콜백함수**) 또는 **return 값**으로 사용 가능하다.
  
  - 자바에서도 `calc()` 메서드의 return값이 int라면 다른 메서드인 `num()`에서 `num(calc())` 같이 활용은 가능하지만,
  
  - `num(calc)`는 말이 안 된다.
  
  - JS는 둘다 가능하다는 뜻. 물론 둘의 기능은 다르다.

- 함수는 프로그램 실행 중에 동적으로 생성도 가능하다.



#### 함수 호이스팅

- 함수 선언문의 경우 함수 선언의 위치와 관계없이 코드 내 어느 곳에서든지 호출 가능

- JS는 모든 선언(var, function)을 Hoisting한다.

- 함수 선언문으로 정의된 함수는 JS 엔진이 로딩되는 시점에 변수객체에 저장된다. 함수의 **선언, 초기화, 할당이 한번에 이루어진다.**
  
  - `function() {}` 으로 선언한 경우를 말함

- 함수 표현식의 경우, 함수 호이스팅이 아니라 **변수 호이스팅이 발생한다.**
  
  - `var f = function() {}` 으로 선언한 경우를 말함

- 이 둘을 잘 구분할 수 있어야 한다!
  
  - 함수 표현식 구문에 도달하기 전까지, JS 엔진은 `f`를 함수가 아니라 **undefined로 초기화된 변수라고 인식하고 있다.**

#### 

#### 매개변수

- 함수의 정의 부분에 외부로부터 전달받은 변수를 **매개변수**라 함

- 함수를 호출할 때 전달하는 값을 **전달인자**라고 함

- JS에서 함수 정의 시, 매개변수에 대한 타입은 명시하지 않는다.

- 함수를 호출할 때 정의된 매개변수와 전달인자의 개수가 일치하지 않더라고 호출 가능.
  
  - 알아서 자르거나, undefined로 넣어서 옮겨준다.



#### 콜백 함수

- 함수를 명시적으로 호출하는 방식이 아니라, 특정 이벤트가 발생했을 때, **시스템에 의해 호출되는** 함수를 말한다.
  
  - ex) click 이벤트 발생 시 호출

- 일반적으로 콜백 함수는 매개변수를 통해 전달되고, 전달받은 함수의 내부에서 어느 특정시점에 실행된다.
  
  - 특정 메서드에 조건이 되는 이벤트의 종류와 함수를 넣어주는 것이 대표적인 활용 방식

- 주로 비동기식 처리 모델에서 사용된다.
  
  - 호출될 함수를 미리 매개변수에 전달하고 처리가 종료되면 콜백함수를 호출한다.

- `setTimeout` 함수 잘 기억해두자.
