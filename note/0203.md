# 표준 입출력
1. 표준 입출력
● System,in,out,err
● 입출력을 기본적으로 스트림이라고 하는데, 스트림은 데이터의 흐름이다.
☞ 데이터는 단방향으로만 흐른다.
☞ 데이터 입력 → 자바 앱 → 데이터 출력의 흐름에서 그 경로를 관리하는 게 스트림.
☞ InputStream과 Reader / OutputStream과 Writer
● 표준 입출력에서 System.in은 기본적으로 byte단위를 입력하는 InputStream의 계열이다.
☞ 하지만 byte단위는 사용하기 어렵기 때문에 다른 스트림을 달아서 기능을 자유롭게 변경시킨다.그게 ‘필터스트림’
● 표준 입출력의 대상을 변경하는 메서드로 set

2. java.util.Scanner
● 파일, 입력 스트림 등에서 데이터를 읽어 구분자를 통해 토큰화하고, 다양한 타입으로 형변환하여 리턴해주는 클래스.
☞ 입력 스트림을 다루는 방법을 몰라도 쉽게 입력처리가 가능하다. 스트림이랑 별개임
● 데이터 형변환으로 인한 편리함이 있음
● 단, 대랑의 데이터를 처리할 때 수행시간이 비효율적
☞ 프로그램의 수행시간에서 입출력처리시간이 포함되기 때문에, 최적화가 요구되는 부분.
● 주요 메서드: 다 알던 것
☞ tip: 입력을 두 번 할 때 뒤가 nextLine()이면 첫 번째를 입력하고 엔터칠 때 개행문자가 스트링으로 인식돼서 두 번째 입력할 기회가 사라진다. 개행을 비우는 작업이 필요첫 번째와 두 번째 사이에 nextLine();을 집어넣어주면 해결됨.
☞ tip: scanner의 nextInt()는 구분자(“ ”)의 직전까지 읽기 때문에 혹시 그 다음이 공백 이후 nextLine()이라면 불필요한 white space가 남아있을 수 있다.
☞ white space를 다루는 데 주의해야 할 것.

3. java.io.BufferedReader
● 필터 스트림의 한 유형.
● 대량의 데이터를 처리할 시 수행시간이 효율적이다.
● 표준입력을 ISR로 변환 후 BR이 읽으면 자바 앱에 데이터가 입력되는 구조

4. java.lang.StringBuilder
● 문자열의 조작을 지원하는 클래스
● 자바에서는 문자열이 상수: 조작 시마다 새로운 문자열이 생성되는 것을 방지.
● append()로 String 혹은 StringBuilder를 불러올 수 있음. sb.append(“ ”).append(“ ”) 이래도 됨
● 만약 문자열 간 구분자로 “, ”를 넣었다면 마지막에 setLength(sb.length()-2);를 통해서 구분자를 지울 수 있다. sb의 길이를 줄이는 방식

# SW 문제 해결
1. 문제 해결 역량이란?
● 하나의 문제에 대해 두 개 이상의 해결법을 알고 있자

2. 문제 해결 과정
● 문제를 읽고 이해한다.
☞ 3번 이상을 읽으라고. 빠르게 확인하면서 유형 파악 → 유형을 생각하며 문제를 읽어 유형을 확신(시간복잡도 고려하기)→ 제약사항 꼼꼼히 읽으면서 코드를 설계
● 문제를 익숙한 용어로 재정의한다.
● 어떻게 해결할지 계획을 세운다.
● 계획을 검증한다.
● 프로그램으로 구현한다.
● 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

3. 문제 해결 전략
● 비슷한 문제를 풀어본 적 있는가?
● 문제를 단순화할 수 있을까?
● 수식으로 표현할 수 있을까?
● 뒤에서부터 생각해서 문제를 풀 수 있을까?

4. 알고리즘
● 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법. 어떠한 문제를 해결하기 위한 절차.

5. 알고리즘 성능: 복잡도
● 시간 또는 공간복잡도는 입력 크기에 대한 함수로 표기. 주로 여러 항을 가지는 다항식
● 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
● 입력 크기 n이 무한대로 커질 때 복잡도를 간단하게 표현하기 위해 사용하는 표기법.

6. 빅-오(O) 표기법
● 시간복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수는 생략
ex) O(3n+2)라면 O(n)으로 표시. n이 무한정 커졌을 때만 복잡도에 영향을 준다는 것
☞ 계수인 3과 +2는 큰 영향이 없다.
ex) O(2n^2+10n+100)이라면 O(n^2). O(4)라면 그냥 O(1)
● 흔히, 1억 번의 연산을 ‘1초’로 생각한다.
ex) n개의 데이터 입력 후 1씩 더해서 출력: n번 입력, n번 연산, n번 출력: O(3n)이므로 O(n)
● Big O 시간 복잡도에서, 연산자에 따라 요소수 증가에 따른 시간복잡도 증가 속도가 다르다.
☞ n! > 2^n > n^2 > nlog(n) 순서.

# 재귀 호출
1. 반복과 재귀
● 반복과 재귀는 기본적으로 유사한 작업을 수행할 수 있다.
☞ 기존 반복문을 재귀로 바꿔보는 것도 좋은 연습이다.
● 반복은 수행하는 작업이 완료될 때까지 계속 반복.
☞ 정확히는 ‘특정 조건을 만족할 때까지’
● 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법.
☞ 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고, 결과들을 결합.

● 반복문에서도 “단위”를 반복하게 됨
● 재귀함수에서는 그러한 단위반복의 부분이 “함수구현부”에 들어가는 것.
● 그리고 함수구현부에서 “자신의 함수를 호출”하는 것이 반복행위를 구성.

2. 재귀 함수
● 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
☞ 반복이 끝나는 조건도 당연히 필요할 것: break가 없으면 메서드 호출이 끝없이 쌓이다가 “stackoveflow”
☞ 특정 조건을 판별 후 재귀를 호출하지 않을 때 재귀가 끝남
● 기본 부분과 유도 파트로 구성
☞ 유도 파트가 반복단위코드에 해당. 기본 부분이 재귀호출을 끊어주는(return) 코드에 해당.기본 부분이 있어야 재귀가 끝난다. 필수적임
● 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다.
● 재귀 호출은 기본적으로 반복적인 스택의 사용을 의미하기 때문에, 반복보다는 메모리와 속도에서 성능저하가 생길 수밖에 없다.
☞ 그래도 기능적으로 사용할 만 하다.
● “Flat”한 시야를 가져라. 내가 모든 것을 다 처리할 것이 아니라, 내가 만들어 준 결과가 내가 처리하던 것과 동일하다면 재귀를 할 수 있다는 것이니까 그냥 넘겨주자.
☞ 정의를 명확히 할 것! 무엇을 하고 있었는지, 무엇을 할 것인지, 어떤 기능인지.
☞ 자신의 작업을 수행하기 위해 필요한 결정 요인(인자), 즉 매개체의 값이 무엇인지 식별하자.
☞ 자신이 할 수 있는 일 + 나머지로 나누고 둘의 생김새가 같도록

3. 팩토리얼 재귀 함수
● 대표적인 재귀함수
int fact(int n) {
	if(n<=1) return 1;				: basis part
	else { return n * fact(n-1); }			: inductive part
● n!은 n*(n-1)!로 구현된다는 점에서 착안. n!과 (n-1)!은 근본적으로 동일한 작업이니까 “재귀”로 해결할 수 있다.

4. 재귀를 이용한 조합의 계산
● 3C2라면? 어쨌든 “2개”를 뽑는다는 작업은 반복
● nCr = n-1Cr-1 + n-1Cr 로 바꿀 수 있다는 점 파악
☞ 원래 요구사항인 C가 두 개의 C로 쪼개진 모습 – 재귀 이용 가능. n이랑 r만 입력받으면 된다.
● 그럼 기저조건은?
☞ 아예 뽑지 않거나 (r=0), n=r일 때. 경우의 수가 1

5. 재귀를 이용한 피보나치수열 계산
fibo(n)
	if(n<=1) return n;
	else{ return fibo(n-1) + fibo(n-2); }

# 재귀 호출 응용: 하노이의 탑
1. 어떻게 생각?
● 너무 파고들지 말고, “가장 밑에 있는 원판”과 “그 위에 있는 나머지”로 생각하자.
☞ 그래야 가장 밑에 있는 걸 어떻게든 치웠다고 쳤을 때, 그 다음 덩어리가 위와 같은 구조가 된다.
☞ 위에서 어떻게 움직일지는 일단 생각하지 말자고. “flat”하게 생각
● “나머지” 부분을 임시 기둥에 올리고, 가장 밑에 있는 원판을 목적 기둥에 옮기고, 최종적으로 “나머지” 부분을 목적 기둥에 옮기는 과정으로 단순화
☞ 이렇게 하면 “나머지” 부분도 위와 같은 구조로 움직일 수 있다.
● “n-1개 원판을 들어올리고 n번째 원판을 움직이고 n-1개 원판을 n번째 원판 위에 올린다.”
☞ 기둥 3개를 각각 from, temp, to라고 할 때
☞ from → temp, from → to, temp → to의 과정

2. 코드로 짜보면?
● 이게 왜 되지?

# 2차원 배열
● 델타를 이용한 2차원 배열의 4방, 8방 탐색

# 완전 검색
1. 정의
● 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
● Brute-forrce 기법으로도 불린다. just do it. 사람의 지능보다는 컴퓨터의 force.
● 모든 경우의 수를 테스트하기 때문에 제대로만 했다면 답이 무조건 나온다.
● 문제 해결 자체는 빠른 시간에 가능하나, 경우의 수가 상대적으로 작을 때 유용하다.
● 예시로 baby-gin 게임.
2. 완전 검색으로 시작하자
● 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하는 과정
● baby-gin의 경우 6!의 순열로 숫자를 나열하고 3자리씩 잘라서 테스트해보면 된다.
☞ 그렇게 해봐야 720가지 경우의 수이기 때문에 이런 방법으로도 충분하다.