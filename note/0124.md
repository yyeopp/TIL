# 추상 클래스
● 상속 관계를 통해 중복되는 메서드를 겹치고, 부모 클래스의 메서드를 자식 클래스에서 좀더 적합하게 오버라이딩하는 기법을 배웠다.
● 근데 자식 클래스에서 반드시 재정의해서 사용되기 때문에 부모 클래스에서 구현하는 것이 무의미한 메서드가 있다면??
1. 정의
● 메서드의 선언부만 남기고, 구현부는 ;으로 대체
● 구현부가 없다는 의미로, abstract 키워드를 선언부에 추가
● 객체를 생성할 수 없는 클래스라는 의미로, 클래스 또한 선언부에 abstract 추가할 필요
● 이런 형태를, “abstract method design pattern”

2. 특징
● abstract 클래스는, 상속 전용 클래스다.
☞ 구현부가 없는 메서드가 있으므로, 객체 생성이 불가능한 클래스.
● 하지만 부모 클래스로써 자식을 참조할 수는 있다. 다형성을 활용!!!
☞ 자식 클래스에서 객체를 대신 생성하는 느낌

3. 사용하는 이유
● “구현의 강제”를 통해 프로그램의 안정성 향상.
● 부모 추상클래스로부터 상속을 받은 자식클래스는 부모의 추상메서드를 모두 오버라이딩하도록 “강제”된다.
☞ 새로 객체를 추가할 때, 실수가 방지됨

# 인터페이스
1. 정의
● 인터페이스 사전적 정의: 두 소프트웨어를 서로 이어 주는 부분.
● 프로그램과 사용자 사이의 접점.
☞ 파일을 저장할 때 나는 저장키를 입력만 하고, 어떻게 저장하는지는 궁금하지 않다.
☞ 프로그램 입장에서는 저장키가 입력되면 저장프로세스를 밟을 뿐, 그 전에 어쨌는지 궁금하지 않다.
● 인터페이스를 사이에 두고 한쪽은 사용에, 한쪽은 구현에만 관심을 가지게 되는 것.

2. 인터페이스 작성
● 최고 수준의 추상화 단계이다. 모든 메서드가 abstract 형태.
● 형태는 클래스랑 유사하게, “interface”를 선언한다.
● 모든 멤버변수는 “public static final”이며, 너무 당연하기 때문에 생략 가능하다.
● 모든 메서드는 “public abstract”이며, 이 또한 생략 가능하다.
public interface MyInter {
	public static final int m1 = 10;
	int m2 = 10;
☞ 위 둘은 동일한 효과

	public abstract void me1(int param);
	void me2(int param);
☞ 마찬가지로 위 둘은 동일한 효과.
● 오버라이딩 시 접근제한자도 당연히 public만 가능하다. (더 넓거나 같은 것만 가능하단 점)

3. 인터페이스 상속
● extends를 이용해 상속이 가능.
● 클래스랑 다른 점은, “다중 상속”이 가능하다는 점
☞ 왜? 메서드 구현에서 헷갈릴 일이 없다. 

4. 인터페이스 구현과 객체 참조
● 클래스에서 인터페이스를 구현할 시, implements 키워드를 사용
● 인터페이스 구현 시, 모든 abstract 메서드를 override하는 게 의무
☞ 물론 그냥 abstract 클래스로 표시하면서 구현하지 않는 것도 가능은 함.
● 여러 개의 인터페이스를 implements할 수도 있다.
● 다형성도 여전히 활용할 수 있다.
☞ “하나의 객체를 여러 가지 타입으로 참조할 수 있다”

5. 인터페이스의 필요성
● 구현의 강제로 표준화 처리: abstract 메서드를 사용한 결과
● 인터페이스를 통한 간접적인 클래스 사용 – 손쉬운 모듈 교체 지원
● 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계를 부여해 다형성 확장
● 모듈 간 독립된 프로그래밍 가능 – 시간 단축

6. default method
● 인터페이스에 선언된, 구현부가 있는 일반 메서드
● 메서드 선언부에 default modifier를 추가한 후 작성해야 함. 실제로 동작하는 코드를 입력
● 기존에 interface 기반으로 동작하는 라이브러리의 인터페이스에 추가해야 하는 기능이 생겼을 때,기존 방식대로라면 모든 구현체들이 추가되는 메서드를 오버라이드해야 함.
● 디폴트 메서드를 활용하면, 그건 abstract가 아니니까 반드시 오버라이드할 필요가 없음
● 문제점: body가 생겨버려서 막 갖다 쓰는 게 껄끄러워짐.동일한 이름을 가지는 구현부가 있는 메서드가 충돌할 우려. 우선순위가 존재
☞ 상속과 implement를 각각 한 경우: super class의 메서드가 우선. 인터페이스의 것은 무시됨
☞ implement를 여러 개 한 경우: 반드시 override를 해야 함.

7. static method
● 인터페이스에서도 선언 가능.
● 별도의 객체가 필요 없고, 인터페이스 이름으로 메서드에 접근해서 사용 가능

# Generics
1. 정의
● 다양한 타입의 객체를 다루는 메서드.
● 컬랙션 클래스에서, “컴파일 시에” 타입을 체크한다.
☞ instanceof 연산자는 메모리에 있는 객체의 타입을 “컴파일 시”가 아니라 “런타임 시”에 체크한다.
● 미리 사용할 타입을 명시해서 형변환을 하지 않아도 되게 한다.
☞ 객체 타입에 대한 안전성 향상 및 형변환의 번거로움을 감소시킴
● 예시
☞ 그 전에 다형성 활용 방식은, 일단 뭐든지 담을 수 있는 Object[]에 커다랗게 담고 나서다시 빼서 쓸 때 instanceof 로 재분류해서 활용하는 방식
☞ generics에서는 박스에 라벨링을 한다. instanceof로 재분류하는 과정이 필요가 없음물론 담을 때가 다소 번거롭다.

2. 표현
● 클래스 또는 인터페이스를 선언할 시 <>에 타입 파라미터를 표시한다.
☞ public class Class Name<T> {}이 때 Class_Name까지를 Raw Type, <T>까지를 Generic Type이라고 본다.
☞ public interface Interface_Name<T> {}
● 타입 파라미터는 단순히 임의의 참조형 타입을 말함.
☞ T, E, K, V 같은 거 많이 쓰는데 맘대로 다른 걸 써서 표시해도 된다.
● 객체 생성 시, 변수 쪽과 생성 쪽의 타입이 반드시 같아야 함

3. 사용
● 컴파일 시에 타입 파라미터들이 대입된 타입으로 대체된다.

4. Type parameter의 제한
● 필요에 따라서 구체적인 타입을 제한할 필요가 있다.
☞ 계산기 구현 시 Number 이하 타입으로만 제한될 필요
☞ T extends Number 이런 식으로 제한될 상위 타입을 명시하는 것이 가능

5. Generic type 객체 할당받을 때 와일드 카드를 이용하는 방식
● 구체적인 타입 대신에 사용
● Generic type<?>은 타입 제한이 없음<? extends T>: T 또는 T를 상속받은 타입들만 사용 가능<? super T>: T 또는 T의 조상 타입만 사용 가능

6. 클래스가 아닌 메서드에서의 사용
● 메서드의 리턴 타입 앞에 타입 파라미터 변수를 선언하는 방식
● 아니 시발 수업 너무빠르잖아


class NormalBox {
	private object some;
	public Object getSome() {
		return some;
	}
	public void setSome(Object some) {
		this.some = some;
	}