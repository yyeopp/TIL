# 0121
>
public class B extends A {}

A a = new A();
B b = new B();
● 여기까지는 원래 하던 건데
A a = new B();
● 이게 가능하다는 게 다형성.

>
● 추상클래스는 자신의 생성자로 객체를 생성할 수 없다
☞ 이유: 객체를 만드는 이유 자체가 객체 사용을 위해서인데,미완성 객체는 사용할 수도 없다.추상 클래스의 객체는 미완성품이라서 못 쓴다.
☞ 그래도 완성해서 쓰면 되지 않냐? 하는데 여전히 문제다.ex) 추상 클래스에 메서드 x가 있을 때 이 메서드를 각기 다른 용도로 쓰고 싶다면.메서드의 기능을 비워두고, 다른 클래스에서 오버라이딩하도록 유도하는 것
☞ 메서드를 선언만 해버린다. {} body를 비워버리고 ; 로 끊어버림
☞ 그걸 사용하려면 ‘무조건’ 오버라이드를 해야 한다. 강제성을 발생시키는 것.
☞ 실습 예시에서 Calendar, Format 클래스 둘다 abstract였다.얘네는 생성자가 뭐든 간에 어차피 객체 생성을 못하는 애들이다.
● 그럼 어떻게 할까?
☞ API 상에서 Direct Known Subclass가 주어진다.
☞ 걔네가 정상적으로 존재한다는 건, 해당 클래스에서는 부모가 되는 추상클래스를 제대로 오버라이딩 해놨다는 뜻.
☞ 객체를 만들 수도 있고, 메서드도 정상적으로 구현된다.

> Car 예제를 활용해보자
Car car = new Car();
● Heap 메모리 상에 Car 객체가 생성됨.
● 객체가 생성되는 시점 = 객체가 메모리에 올라가는 시점그게 언제: 단순히 생성자 호출만으로 만들어지는 게 아니다.생성자 호출이 끝났을 때 비로소 메모리에 올라감. 괄호가 닫혔을 때.
● new Car();는public Car () { }로 이어지고그 내부에 숨어있는 super(); 에 의해public Object() { } 로 이어진다.Object 블록이 끝나면 이 때는 “Object” 객체가 생성된다.그럼 다시 Car () {}로 돌아가서 마저 블록을 끝내고비로소 “Car“ 객체가 생성된다.
● 객체가 두 개 생성되는 것. 주소도 두 개.
● 그러면 Car car라는 변수에는 주소 두 개가 이론 상 모두 들어갈 수 있다.근데 저장되는 주소는 Car 객체의 주소.
● 왜? car 변수가 Car 타입으로 선언됐기 때문.
● 즉,car에 직접 연결되어있는 건 Car 객체이지만메모리에 올라와있는 건 Object 객체까지 있기 때문에car 변수를 통해서 Object 객체의 메서드까지 모두 활용 가능

Taxi t = new Taxi();
● Taxi 타입의 t라는 변수가 만들어진다.
● = 는 대입연산자니까 마지막에 실행된다고 생각
● new Taxi(); 에 의해 public Taxi () { 시작그 안에 있는 super(); 가 실행.Taxi 객체를 위한 영역이 메모리에 잡히긴 하지만아직 Taxi 객체가 생성된 것은 아님!!!
● super();에 의해 public Car() { 시작.그 안에 있는 super();가 실행마찬가지로 메모리에 Car 객체를 위한 영역이 메모리에 잡힘
● super();에 의해 public Object() { 시작.super(); 없음. } 끝남드디어 Object 객체 생성
● 이제 Car } 닫히면서 Car 객체 생성
● Taxi } 닫히면서 Taxi 객체 생성
● 만들어진 건 결국 3개의 객체. 주소도 각기 잡힘
● 마지막으로 대입연산자 작동, Taxi 타입의 t는 Taxi 객체의 주소를 참조한다.
● Taxi 객체를 만들 때 Car와 Object 객체가 모두 메모리에 올라갔으므로, t는 그 메서드를 죄다 사용할 수 있다.

> 다형성?
● 상위 클래스의 객체를 생성할 때 하위 클래스를 참조하여 생성할 수 있음.
● 상위 클래스 Car, 하위 클래스 Taxi
Car car = new Taxi();
● Car 타입의 변수 car가 생성. 대입연산자는 일단 무시
● new Taxi();가 실행
● 아까랑 마찬가지로 super();를 따라서 Taxi와 Car, Object 영역이 잡히고,Object, Car, Taxi 순서로 객체가 생성된다.객체 3개, 주소 3개.
● 그럼 이제 car 변수는 어떤 주소를 참조한다?? 이게 결국 핵심!!Car 객체의 주소를 참조한다. Car 타입이니까!!그럼 이제??
car.carName = “쏘나타”
● 가능한가? 당연히 된다. car는 Car 객체를 참조하고 있으니까.
car.speedUp();
● 가능하다. 마찬가지로 Car 객체의 메서드니까
car.price = 1000;
● 가능한가? 불가능!!!
● Taxi 객체가 메모리에 올라와있는 것은 사실이지만,car는 엄연히 Car 타입이기 때문에 Taxi 클래스의 메서드 호출이 불가능하다.

--------------------
☞ Car 클래스의 speedUp은 상한선이 없었지만, Taxi 클래스에서 그걸 오버라이드 해놨음
car.speedUp();
● 놀랍게도 이건 Taxi 클래스에서 오버라이딩된 speedUp()를 호출해서 speed 상한선이 존재.
● 결론: 기본적으로 변수의 타입에 맞춰서 각자 가지고 있는 메서드를 따라가지만,(메서드 이름이 같은) 오버라이딩이 되어있는 메서드라면 하위 클래스의 메서드가 호출된다.

sysout(c);
● 일단 자동으로 toString()이 실행된다.
● Car와 Taxi 클래스 모두에서 toString()을 오버라이드해놓은 상태
● 결국 Taxi 클래스의 toString()이 실행된다.
● 모든 자바 클래스가 사용되려면 메모리에 올라가야 한다.
● 지금처럼 다형성을 이용해서, 하위 클래스를 참조해서 상위클래스 객체를 생성하면,
● 변수 자체는 상위 타입이기 때문에 하위 클래스에 있는 것들 사용이 불가능하고
● 예외적으로 오버라이딩된 메서드들은 자기 클래스에 있는 것을 호출해도 알아서 하위 클래스의 것이 호출된다는 점.

> UML 보기
● C는 constructor
● C 없이 초록 동그라미는 public 메서드
● 빨간색은 private
● 파란삼각형은 default


> SingleTon
● 생성자를 private으로 만드는 게 첫 번째외부에서 해당 클래스의 객체를 생성할 수 없도록
● private static으로 자기자신의 변수를 만들어라.
● 외부에서 접근가능하도록 public static으로 자기자신을 리턴하는 getter를 만들어라그리고 그 안에서, 객체가 null일 경우에만 객체를 만들도록 지시한다.아까 만들었던 ref변수에 대해 new생성자로 객체를 만들어줌.이제 ref변수가 null이 아니라면, ref변수가 참조하고 있는 이미 만들어진 객체를 리턴하도록 만들자