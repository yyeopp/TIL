# 상속

1. 상속
● 기존 클래스의 멤버를 자식 클래스에서 재사용.
☞ 단, 부모의 생성자와 초기화 블록은 상속하지 않음
● 장점: 코드 절감. 유지 보수성 향상
● 적용: extends 키워드.
☞ 상속관계를 그림 상에서는 실선 화살표로 나타낸다는 점.
● 여러 용어: 부모, 상위, 슈퍼 클래스 / 자식, 하위, 서브 클래스
● 상속은 ‘is a’ 관계이다. 자식클래스 is a 부모클래스.

2. Object 클래스
● 모든 클래스의 조상클래스. 별도 extends 없이도 상속받는다.
● 즉, 모든 클래스는 Object 클래스에 정의된 메서드가 당연히 있다.
☞ hashCode, equals, getClass, toString 같은 것들 계속 사용하게 됨
● 새로운 객체를 정의할 때, toString, equals, hashCode 이 3개는 자주 오버라이딩하게 된다.

3. 단일 상속
● 하나의 자식 클래스는 하나의 부모 클래스로부터만 상속을 받는 것.
● 다중 상속으로 여러 클래스로부터 상속받을 가능성은 있으나, 동일한 이름의 메서드가 여러 부모 클래스에게 중복되어 있어 혼동을 유발할 우려가 있어서 자바에서는 지원하지 않음

4. 포함 관계
● 상속 이외에 클래스를 재활용하는 방법. 멤버 변수로 처리하는 것
☞ 그림 상에서 단순 실선으로 표시
● boolean 같은 변수를 활용해서, 다른 클래스의 객체를 생성한 뒤 그로부터 메서드를 뽑아내는 것
● 

# 메서드 재정의

1. 메서드 오버라이딩
● 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것.
● 조건
☞ 메서드 이름이 같아야 함 / 매개변수의 개수, 타입, 순서가 같아야 한다 / 리턴 타입이 같아야 한다.이건 그냥 메서드 선언부가 동일해야 한다는, 어찌 보면 당연한 내용
☞ 접근 제한자는 부모보다 범위가 넓거나 같아야 한다.
☞ 조상보다 더 큰 예외를 던질 수 없다.

2. Annotation
● 주석. 소스코드에 메타데이터를 삽입하는 형태.
☞ 컴파일러, JVM, 프레임워크 등이 본다. 코드에 대한 정보를 추가해서, 소스 코드 구조 변경이나 환경 설정 정보 추가 등의 작업 진행
● 작동: @Deprecated, @Override 등
● 철저히 ‘각주’이지만 코드를 꾸며주면서도 에러를 방지하는 기능

3. toString() 메서드
● toString 메서드: 객체를 문자열로 변경하는 메서드.
☞ 원래는 단순히 주소값을 리턴하는 메서드. 오버라이딩으로 좀 더 쓸 만하게 만들 수 있다.

4. equals() 메서드
● 두 객체가 같은지를 비교하는 메서드.두 개의 레퍼런스 변수가 같은 객체를 가리키고 있는지.
String s1 = new String(“Hello”);
String s2 = new String(“Hello”);
sysout((s1==s2) + “ : ” + s1.equals(s2));  // false : true
☞ s1==s2는 false다. s1과 s2는 String객체이고, 각각 새로 만들어진 것이기 때문에 주소값이 다르기 때문.내용은 같지만, s1과 s2를 비교하면 엄밀히 객체 간 비교이기 때문에 내용은 따지지 않는다.
☞ equals를 사용하면 비로소 내용인 Hello를 비교하게 됨.
☞ 근데 equals도 오버라이딩이 필요하긴 하다고 함. 왜?

5. hashCode() 메서드
● 객체의 해시코드: 시스템에서 객체를 구별하기 위해 사용되는 정수 값.
☞ HashSet, HashMap 등에서 객체의 동일성을 확인하기 위해 사용.
● toString()을 오버라이딩하지 않고 객체를 집어넣었을 때 나오는 값이 hashCode.

6. super 키워드
● super를 통해, 부모 클래스의 멤버에 접근할 수 있다.
☞ this로 본인 클래스의 멤버에 접근한 것과 동일
● 변수의 scope: 사용된 위치에서 점점 확장해가며 처음 만난 선언부에 연결.
☞ 별도의 접두사 없이 변수를 호출하면, 가장 가까운 게 연결됨
☞ this.를 붙였다면 소속된 클래스 중 가장 가까운 클래스의 변수에 연결됨.
☞ super.를 붙였다면 this.보다 밖에 있는 클래스의 변수에 연결됨.
☞ 결론은 blank.와 this.와 super. 가 상대적이라는 뜻
● super()는 조상 클래스의 생성자를 호출할 수 있음
☞ 자식 클래스의 생성자 선언부에서 첫 줄에서만 super()를 쓸 수 있음
☞ 결국 this()랑 super()는 같이 쓸 수 없음
● 명시적으로 this나 super를 호출하지 않는 경우 컴파일러가 알아서 super()를 삽입.
☞ 진짜 아무것도 걸쳐져 있는 게 없다면 superclass인 Object 클래스까지 닿는 것
☞ 결론적으로, “완전한 상속”이 구현됨.
● 파라미터 생성자를 만들면 기본 생성자도 명시적으로 정의해야한다!

# Package와 Import
1. Package
● 일종의 폴더. 클래스가 모여서 구성된 하나의 계층
● 일반적인 naming 룰: 소속.프로젝트.용도
☞ (com.ssafy.)(homework.)(commit)

2. import
● 다른 패키지에 선언된 클래스를 사용하기 위한 키워드
● 선언 방법: 패키지와 클래스 선언 사이에 위치. 여러 번 선언 가능
☞ import 패키지명.클래스명;
☞ import 패키지명.*;
☞ java.lang.*; 는 default로 import 되어있다는 점

# 접근 제한자 및 데이터 은닉과 보호

1. 제한자(modifier)
● 클래스, 변수, 메서드 선언부에 함께 사용, 부가적인 의미 부여
● 종류: 접근 제한자, 그 외 제한자.
☞ 접근 제한자: public, protected, default, private
☞ 그 외: static, final, abstract, synchronizedstatic을 잘 기억하자. “메모리에 올라가라!”
● 접근 제한자는 하나만 사용 가능. 순서는 무관. 일반적으로 접근 제한자가 맨 앞

2. final
● 더 이상 바뀔 수 없다는 뜻. “상수”를 선언
● 용도 
☞ class에 붙일 시 상속을 금지(오버라이드를 금지)ex) math 클래스 같은 것. 무조건 그대로만 써야 함. 안전하게
☞ method에 붙일 시 재정의를 금지(오버라이드를 금지)
☞ variable에 붙일 시 값을 바꿀 수 없음. 상수화ex) 파이는 3.14

3. 접근 제한자(Access modifier)
● 멤버 등에 사용되어 해당 요소를 외부에서 사용할 수 있는지 설정.

제한자
용도
접근 가능 범위
클래스
생성자
멤버
같은 클래스
같은 패키지
다른 패키지의 자손 클래스
전체
public
o
o
o
o
o
o
o
protected

o
o
o
o
o

default
o
o
o
o
o


private

o
o
o




☞ protected는 다른 패키지에서 상속받은 자식클래스인 경우라는 뜻.
● 메서드 오버라이드의 경우
☞ 부모의 제한자 범위의 같거나 넓은 범위로만 사용 가능.ex) 부모클래스에서 default였다면, 자식 클래스에서 오버라이드할 때 private로 선언할 수 없음. public은 가능

4. 데이터 은닉과 보호
● 특정한 정보는 밖에서 접근하면 안 된다.
● 정보 보호를 위해서 private을 선언하되, 공개되는 메서드를 통해 접근 통로를 마련
☞ setter와 getter 메서드. 정보 보호 로직에 해당
☞ private 변수와 같은 레벨에서 public 메서드로 setter, getter를 만들어서, 사용자가 설정한 제약 조건 하에 private 변수에 접근할 수 있도록 설정하는 것.
☞ 이클립스에서 자동으로 generate할 수 있음

5. 객체의 생성 제어와 Singleton 디자인 패턴
● 객체의 생성을 제한해야 하는 상황이라면?
☞ 특정 객체의 기능은 필요하되 ‘멤버변수’인 상태와 성질은 관심이 없는 경우.그런 경우 stateless 객체라고 함.
☞ 객체를 생성하고 삭제하는 데 비용이 꽤 큰 경우. 재사용이 유리
● Singleton 디자인 패턴?
☞ 외부에서 생성자에 접근을 못하도록 private를 접근 제한자로 설정.
☞ 내부에서는 접근 가능하므로 직접 객체를 생성하고 private로 설정
☞ 외부에서 접근 가능하도록 static한 getter를 생성.객체 없이도 접근할 수 있도록 static으로. setter는 필요없음

# 다형성	완전히 이해하고 가자!!!
1. 다형성(Polymorphism)
● 하나의 객체가 여러 가지의 type을 가질 수 있는 성질.
● 상속 관계에 있을 때, 조상 클래스의 타입으로 자식 클래스의 객체를 레퍼런스할 수 있다.

2. 다형성의 활용: 다른 타입의 객체를 다루는 배열
● 다른 타입의 데이터를 하나의 배열에서 관리.
● 각 타입마다 배열을 하나씩 만들면 비효율적이기 때문
☞ 부모 타입의 배열을 정의한 뒤 거기에 자식클래스 객체도 싹 다 저장하는 것
● 만약 Object의 배열을 만든다? 어떤 타입의 객체라도 다 저장 가능함

3. 다형성의 활용: 매개변수의 다형성
● 조상을 파라미터로 처리한다면, 타입에 따라 여러개의 메서드를 만들 필요가 없다.
● 물론 필요할 시 하위 클래스에서 오버라이딩은 필요

4. 다형성과 참조형 객체의 형 변환
● 메모리에 있는 것과 사용할 수 있는 것은 다르다.
☞ 자식 클래스 속 객체는 메모리에 부모 클래스의 메서드들을 담고 있지만..
● 참조형 객체의 형 변환
☞ 작은 집에서 큰 집으로: 묵시적 캐스팅. 형변환 연산자가 생략될 수 있다.
☞ 큰 집에서 작은 집으로: 명시적 캐스팅. 형변환 연산자를 반드시 넣어야 한다.
● 조상을 무작정 자손으로 바꿀 수는 없으므로, instanceof 연산자를 활용

5. 참조 변수의 레벨에 따른 객체의 멤버 연결
● 상속 관계에서 객체의 멤버 변수가 중복될 때, 참조 변수의 타입에 따라 연결이 달라짐
☞ 관리는 편리하게 하면서 기능은 원하는 대로 쓰는 것
● 상속 관계에서 객체의 메서드가 중복될 때 무조건 자식 클래스의 메서드가 호출된다!!!

6. 보론
● 문자열을 만드는 두 가지 방법.String s1 = “Java“;String s2 = “Java“;String s3 = new String(“Java“);String s4 = new String(“Java“);
☞ String s3에 의해 객체가 생성되면 heap이라는 메모리 영역 안에,새로운 영역이 만들어지고 Java라는 문자열이 안에 적힌다.그리고 s3이 해당 영역을 참조한다.
☞ String s4에 의해 객체가 생성되면 heap이라는 메모리 영역 안에새로운 영역이 만들어지고 Java라는 문자열이 안에 적힌다.그리고 s4가 해당 영역을 참조한다.
☞ Heap과 별개로 문자열 저장소라는 별도의 공간이 있다고 볼 수 있다.
☞ s1을 선언하면, 문자열 저장소 안에 “Java”라는 게 만들어진다.정확히는 “Java”라는 값이 문자열 저장소에 있는지 먼저 확인한 후 만든다.그리고 그걸 s1이 참조한다.
☞ s2를 선언하면 또 문자열 저장소 안에 “Java”가 있는지 검사한다. 근데 s1에 의해 이미 있음그러면 s2는 문자열 저장소에 있는 Java를 직접 찌르는 게 아니라s1이 달고 있는 Java의 주소값을 참조한다. s2 -> s1
☞ 보다 정확하게 하면, 아까 s3과 s4가 참조한 heap 속 영역은문자열 저장소 속 Java를 참조하고 있다.
☞ 정리하면,
☞ s1과 s2는 완전히 같은 것을 참조하고 있다. 문자열 저장소 속 “Java“. 주소가 같음그래서 ==를 사용해도 원하는 결과가 나옴하지만 이건 String이라서 발생하는 특수 케이스이기 때문에,equals를 사용하는 게 가장 안전함
☞ 만약 print(s1 + “안녕”)을 썼다면?s1에 의해 만들어졌던 문자열 저장소 속 “Java“를 바꾸는 게 아니다.String 클래스이기 때문에 내용이 불변
☞ 그 대신 “Java안녕”을 새로 만들어서 문자열 저장소에 집어넣고 출력하는 것.
☞ 메모리를 더 잡아먹는다
☞ 보다 정확하게는, +연산이 String을 buffer라는 클래스 안에 append 시키고 매번 toString() 함으로써 새로운 String을 만들어내는 구조.+가 많으면 그만큼 append나 toString 연산이 반복된다. 처리 속도가 느려질 수밖에
☞ 그 대신 사용하는 StringBuilder라는 클래스는,build 안에 조합의 대상이 되는 문자열들을 차곡차곡 쌓아뒀다가 (append를 사용)toString()으로 한번에 뽑아낸다.메모리 절약 가능