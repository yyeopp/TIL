# 객체지향 프로그래밍

1. 객체, 객체지향 프로그래밍
● 객체: 주체가 아닌 것. 주체가 활용하는 것.
● 객체지향 프로그래밍은 주변의 사물을 객체화하여 프로그래밍하는 것.

2. 장점: 블록 형태의 모듈화된 프로그래밍
● 신뢰성 높은 프로그래밍
● 추가/수정/삭제 용이
● 높은 재사용성

3. 현실의 객체와 프로그램의 객체
● 현실 객체의 속성과 기능이 추상화되어 클래스에 정의됨.
● 클래스가 구체화 되어 프로그램의 객체(instance, object)가 됨

● 실생활이라면: 같은 객체를 만들기 위해 설계도를 사용
☞ 붕어빵 틀은 설계도, 붕어빵은 객체.
● 프로그램에선 설계도=Type, 제품=Object.

4. 예시
현실세계의 객체인 사람
● 상태, 속성 = 이름: 철수 / 나이: 40 / 배고픔: X
● 기능, 행위 = 먹는다 / 일한다
추상화하여 프로그래밍에 응용: 클래스를 만들기
● Person 클래스에 대해,
● 멤버변수 = String name / int age / boolean isHungry
● 멤버메서드 = void eat() / void work()
구체화: 객체를 만들기
● Person p = new Person();
● p.name = “철수”;	p.age = 40;	p.isHungry = false;
● p.eat();	p.work();

5. 클래스와 객체
● 클래스: 객체를 정의해놓은 것. 객체의 설계도
☞ 직접 사용할 수 없고 객체를 만들기 위한 틀
● 객체: 클래스를 데이터 타입으로 메모리에 생성한 것.

6. 객체 생성과 메모리
# JVM의 메모리 구조를 알아야 함.
● class area: 클래스 원형을 로딩
☞ Field 정보, Method 정보, 타입 정보, 상수 풀.
● method stack: 메서드들의 실행 공간.
☞ thread 별로 별도 관리. 메서드의 호출 순서대로 쌓이는 구조
☞ 메서드 프레임에 로컬변수도 쌓이는데, 로컬변수는 선언된 영역을 벗어날 시 삭제
● heap: 객체를 저장하기 위한 영역
☞ thread에 의해 공유. 생성된 객체는 사용되지 않을 때 GC가 알아서 삭제

7. 객체의 생성과 메모리 할당
Person p1 = new Person();
● 클래스영역에
☞ Person {name, age, ishungry, eat(), work()}
☞ PersonTest{main()}
● 스택 영역에		
☞ Person p1	// 힙 영역에 있는 객체 주소인 0x100을 참조.
● 힙 영역에			// 디폴트 초기화가 먼저 이루어짐.
☞ name(null), age(0), ishungry(false)	// 주소 0x100 이라 가정
p1.name = “홍길동”;	p1.ishungry = true;
☞ 힙 영역에 “홍길동” 생성		// 주소 0x200이라 가정
● 힙 영역의 name이 홍길동이라는 이름의 주소 0x200을 참조 (String 클래스)
● 힙 영역의 ishungry가 true값으로 초기화됨. (단순 속성)
p2라는 person 도입해서 힙 영역의 0x300을 참조했다고 가정
만약 p1=p2; 가 주어진다면
● 스택 영역의 p1은 힙 영역의 객체 주소인 0x300을 참조하게 됨
● 이 때 0x100의 객체는 아무도 접근할 수 없게 됨
☞ 이걸 Garbage라고 부르는 것. 알아서 삭제되어야 함: GC.

# 변수
1. 변수의 종류
● 타입에 따른: Primitive, Reference
● 선언 위치에 따른: 멤버변수, 지역변수

2. 인스턴스 멤버 변수
● 객체와 관계가 큼.
● 선언 위치: 클래스 {} 영역에 선언됨. static이 붙어있지 않음
● 변수 생성: 객체가 만들어질 때, 객체 별로 메모리영역 heap에 생성됨
☞ 개별 객체마다 고유한 상태를 유지하고, 서로 아무 상관성이 없다.
● 변수 초기화: 선언 시, type 별로 default 초기화.
☞ 전역변수는 자동초기화가 일어나지만, 지역변수는 자동초기화가 일어나지 않음. 반드시 명시적인 초기화 필요
● 변수 접근: 메모리에 객체를 생성한 후, 객체 이름으로 접근
● 소멸 시점: GC에 의해 객체가 없어질 때 소멸. 프로그래머가 명시적으로 소멸시키는 건 불가능

3. 클래스 멤버 변수
● 선언 위치: 클래스 {} 영역에 선언. static 키워드가 붙은 것.
☞ static: 정적인. 웬만해서 바뀌지 않는다. 영향이 매우 크기 때문
☞ 클래스 단위에서 static 변수를 제어하면, 클래스에 속하는 객체들이 일괄적으로 변동
● 변수 생성: 클래스 영역에 클래스를 로딩할 시, 메모리가 등록
☞ 개별 객체 생성과 무관하고, 모든 객체가 공유
● 변수 초기화: 타입 별로 default 초기화
● 변수 접근: 객체 생성과 무관히, 클래스 이름으로 접근
☞ 객체 생성 후 객체 이름으로 접근도 가능은 하나, static에 부합하지는 않음
● 소멸 시점: 프로그램 종료 시.

4. 지역 변수 & 파라미터 변수
● 선언 위치: 클래스 영역 {} 이외의 모든 중괄호 안에 선언되는 변수들
☞ void call(String to) {	// 파라미터 변수	String beep = “띠”;		// 로컬 변수	for(int i=0; i<3; i++) {	// 로컬 변수		sysout(beep);
● 변수 생성: 선언된 라인이 실행될 때.
☞ 생성 메모리 영역: thread 별로 생성된 stack 영역에 생성
● 변수 초기화: 사용 전 명시적 초기화 필요
● 변수 접근: 외부 접근 불가. 메서드 내부에서는 이름에 바로 접근
● 소멸 시점: 선언된 영역인 {}를 벗어날 때.

5. 메모리 동작 예시
● 메모리 동작하는 방식 손컴파일링하는 거 숙지해보자
● stack에 main메서드와 call 메서드가 생성됐다가 사라지는 과정
● {}가 끝나면 해당 메서드도 stack에서 out된다는 점. 로컬이기 때문에
● heap 영역에는 주소값을 가지는 객체들이 계속 생성되고, stack으로부터 참조된다는 점

6. 보론
● 각각 변수가 어느 영역에 존재하는 지에 따라 영향을 미치는 영역이 달라지는 것 주의
● 자동초기화는 전역변수에서만 일어난다.
☞ 그러니까 구태여 int 변수를 선언하면서 0으로 초기화시키는 문구도 집어넣을 필요가 없다. 메모리 낭비니까 그냥 선언만 하자
☞ String 변수도 그냥 선언만 하지 null로 초기화시킬 필요 없다.
☞ 지역변수에서 명시적 초기화를 절대 빼먹지 말 것.
● 접근제어자도 전역변수에서만 쓸 수 있다. 메서드 내에서는 접근제어자 사용 불가

# 메서드
1. 메서드
● 메서드는 현실 객체가 하는 동작을 프로그래밍화한 것.
● 어떤 작업을 수행하는 명령문의 집합.
● 사용하는 이유
☞ 반복적으로 사용되는 코드의 중복을 방지함.
☞ 코드 양을 줄일 수 있고, 유지보수가 용이함
● “모듈화”하여 보다 똑똑한 객체를 만들어낸다.

2. 메서드의 작성 방법
● 선언부
☞ 제한자 + 리턴타입 + 메서드이름(타입변수_명, 타입변수_명 ,,,_ {	do something }
● 리턴타입 (int같은 것)
☞ void: 호출 결과 반환값을 리턴하지 않을 경우.
☞ 결과를 받을 때, 묵시적 형 변환을 적용함.
☞ 리턴 타입은 하나만 적용 가능만약 여러 타입의 데이터를 넘기고 싶다면, “객체”를 전달하면 될 것
● Variable arguments: 메서드 선언 시 몇 개의 인자가 들어올지 예상할 수 없는 경우.
☞ ... 을 이용해 파라미터를 선언하면, 호출 시 넘겨준 값의 개수에 따라 자동으로 ‘배열’을 생성하고 초기화public void varArg(int ... params) {} 이런 식.
☞ 우리가 사용하는 printf 메서드가, V.A를 활용하고 있다.%d 같은 것을 활용해서 가변적인 개수를 대입할 수 있기 때문
● 구현부: 중괄호 내에서 처리해야 하는 내용
☞ 리턴 문장과 함께 반환

3. 메서드의 호출
● 반드시 선언부에 맞춰서 호출해야 함
● 메서드 접근: 멤버 변수와 마찬가지로, static과 non-static 구분
☞ 같은 클래스에 있는 static member는 바로 호출 가능
☞ 다른 클래스에 있는 static member의 경우 클래스 이름과 함께 호출
☞ 다른 클래스에 있는 nonstatic은 객체 생성 후 객체 이름과 함께 호출
● 가장 중요한 것은, “메모리에 있는가”
☞ 있어야 호출 가능.
☞ class member는 클래스 생성과 함께 메모리에 올라가니까 호출 가능
☞ instance member는 객체 생성 전엔 메모리에 없으니까 호출이 불가능

4. 메서드 호출 스택
● 각각 메서드를 호출 시, main을 가장 바닥으로 해서 계속 그 위에 쌓이는 구조다.
● 새로운 메서드 호출 시 맨 위에 있는 메모리 상자만 활성화, 그 밑의 메서드는 일시정지(팬딩?)
● 맨 위 메모리 상자가 리턴될 시, 비로소 그 밑의 메모리 상자 활성화
● 순차적으로 해결되다가 메인 메서드로 끝나는 식

5. 기본형 변수와 참조형 변수

6. 메서드 오버로딩
● 오버로딩: 동일한 기능을 수행하는 메서드의 추가 작성.
☞ 일반적으로 메서드 이름은 “기능”에 따라 의미있게 정함.
☞ 동일한 기능을, 여러 형태로 정의해야 할 때 메서드 오버로딩을 활용
ex) eat과 eatUsingChopsticks, eatUsingFork, eatUsingSpoon
● println 메서드만 해도, 그 안에 아무거나 집어넣어도 같은 기능 수행
☞ 오버로딩을 통해 구현한 것. int를 넣든 char을 넣든 다 동작하도록
☞ pinrtlnInt, printlnChar 이런식으로 매번 달리 쓰지 않도록
● 장점: 기억해야 할 메서드 감소, 중복 코드에 대한 효율적 관리

7. 메서드 오버로딩 방법
● 메서드 이름은 동일하게.
● 파라미터의 개수 or 순서 or 타입이 달라야 할 것.
☞ 파라미터가 같으면 에러 발생
● 리턴 타입은 어떻게 해도 상관없음
● 예시:
☞ long add(long a, int b) {return a+b;}long add(int a, long b) {return a+b;;}
☞ 성공적인 메서드 오버로딩에 해당. 파라미터의 순서가 다르기 때문
☞ add(3, 5L); add(5L, 3); 으로 선택적인 호출 가능
● 메서드 오버로딩 시 코드 중복을 막기 위해 서로서로 호출하는 방식도 익힐 필요.

8. 보론
● 메서드 내에서 만드는 변수를 지역변수라 한다. 자동초기화가 일어나지 않는다.
● 대괄호 []로 묶여있는 건 생략 가능하다는 뜻
● void 메서드가 아닌 한 return문이 필요하다. return되는 자료의 type에 맞춰서 메서드의 returntype를 지정해놔야 한다.

9. 보론; 클래스 만들어보기
● 클래스 이름에 한글이 들어가도 되긴 한다.
● 클래스의 access modifier로 private랑 protected는 어차피 못 쓴다.

10. 생성자
● 클래스 이름과 똑같은 이름의 메서드.
● 객체 생성 시 최초로 호출되고, 객체를 초기화해주는 역할을 수행한다.
☞ 전역변수의 값을 설정하는 작업인 것.
☞ 객체 1개 당 생성자 1개가 필요하다고 이해하면 됨.ex) Student A = new Student();
● 형식: ReturnType이 없다. 클래스명과 같은 이름.
● this를 통해 전역변수와 지역변수를 구분해주기
