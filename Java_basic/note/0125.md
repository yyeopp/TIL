# Exception handling
1. 에러와 예외
● 어떤 원인에 의해 오동작하거나 비정상적으로 종료되는 경우
● Error: 메모리 부족이나 stackoverflow와 같이 일단 발생하면 복구 불가한 상황프로그램 비정상 종료는 막을 수 없음. 디버깅이 필요
● Exception: 읽으려는 파일이 없거나, 네트워크 연결이 안 되는 등 수습 가능한 것프로그램 코드에 의해 수습될 수 있는 상황.
● 예외 처리: 예외 발생 시, 프로그램 비정상 종료를 막고 정상적인 실행 상태를 유지하도록 하는 것.
☞ 예외의 감지 + 예외 발생 시 동작할 코드를 작성할 필요.
☞ ex) 카톡하다가 네트워크가 끊기면 에러가 뜨지만 프로그램 비정상종료는 X

2. 예외 클래스의 계층
● 가장 위에 Throwable
● Error는 예외처리 대상이 아님. 그냥 디버깅 필요
● Checked Exception: 예외에 대한 대처 코드가 없으면, 컴파일이 진행되지 않음
☞ 컴파일러가 먼저 체크해준다는 뜻.
● Unchecked Exception: 예외에 대한 대처 코드가 없더라고 컴파일이 진행됨
☞ 컴파일러가 체크를 안해준다는 뜻. RuntimeException의 하위 클래스

3. try~catch 구문
● 예외가 발생할 수 있는 코드를 try에 넣는다
● 컴파일러 동작 시 예외가 발생 (무슨무슨 exception)
● 이걸 throw문으로 처리
● catch 부분에서 예외발생 시 작동하는 코드를 실행

4. Exception 객체의 정보 활용
● Throwable의 주요 메서드가 어떤 게 있는지 익히기
☞ printStackTrace가 매우 중요

5. try~catch 흐름
● try 블록 예외 발생
☞ JVM이 해당 exception 클래스의 객체 생성 후 던짐 (throw new exception)
☞ 만약 try 블록 안에 예외발생 코드 + 일반 코드가 있었다면 일반코드는 실행될 기회가 없다.
● 던져진 exception 처리할 수 있는 catch 블록에서 받은 후 처리
☞ 적당한 catch 블록이 주어져야 할 것
● 정상 처리 시 블록을 완전히 벗어나 다음 문장이 진행됨
● try 블록에서 예외가 발생하지 않은 경우?
☞ try를 전부 실행한 이후 catch를 거치지 않고, 그냥 블록 이후의 다음 흐름 문장을 실행

6. 다중 exception handling
● try 블록에서 여러 종류의 예외가 발생할 경우, 하나의 try 블록에 여러 개의 catch 블록 추가가 가능
☞ 예외 종류별로 catch 블록을 구성.
☞ 어떤 세부 exception 발생 시, Exception e 라는 catch 문에서 잡아갈 수 있다.
☞ 이 또한 다형성...
● catch가 여러 개면, 발생한 예외에 대해서 위에서부터 순차적으로 catch문을 검증하게 됨
☞ Exception e는, 맨 마지막에 두는 게 바람직하다. 모든 exception을 잡아갈 수 있기 때문

7. 다중 catch 문장 작성 시 유의 사항: 순서
● 다형성이 적용된다는 점.
● 상위 타입 예외를 먼저 선언할 시 뒤에 있는 catch 블록이 동작할 기회가 없다.
● 상속 관계가 없는 exception 사이에서는 관계 없음
● 작은 범위에서 큰 범위의 순서로 가면서 작성해야 한다는 점.

8. 다중 예외 처리를 이용한 checked exception 처리
● 사실 exception e만 달아도 발생하는 예외들을 죄다 처리할 수 있다.
☞ 하지만 예외 상황 별 처리가 쉽지 않기 때문에, 가급적 예외 상황 별로 처리하는 것이 권장됨

9. finally 구문을 이용한 예외 처리
● finally는 예외 발생 여부와 관계없이 언제나 실행된다.
☞ 중간에 return을 만나는 경우에도 finally 블록을 먼저 수행한 후 리턴을 실행한다.
● finally의 기능은, try 블록에서 접근했던 시스템 자원을 안전하게 원상복구하는 것이기 때문
☞ try가 정상실행되어서 return까지 접근했더라도 finally는 실행된다.
☞ 파일인풋스트림으로 읽어냈다면, finally가 꼭 닫아줘야한다는 것.
☞ 그동안 Scanner쓸 때 노란줄뜨던 것도 scanner가 시스템자원이니까 닫는 구문이 필요하다는 거였음

# throw의 활용
1. throws 키워드를 통한 처리의 위임
● 메서드에서 처리해야 할 하나 이상의 예외를 호출한 곳으로 전달. 예외처리를 위임하는 것.
● 예외가 없어지는 것이 아니라, 단순히 전달됨.

2. 로그 분석과 예외의 추적
● printStackTrace를 통해 메서드 호출 스택 정보를 조회할 수 있다.
● 꼭 확인해야 할 정보
☞ 어떤 예외인지, 예외의 종류
☞ 예외 객체의 메시지는 무엇인지. 예외의 원인
☞ 어디서 발생했는지. 디버깅의 출발점java.lang 같이 기본적으로 참조하는 라이브러리들은 그냥 신경끄고 직접 작성한 코드를 디버깅하면 됨

3. throws의 목적과 API 활용
● API는 많은 메서드를 만들어놓을 때, 사전에 예외가 발생할 수 있음을 선언부에 명시해서프로그래머가 그 예외에 대응을 하도록 강요한다.
● API가 예외처리를 자동으로 해버린다면, 개발자는 상황을 인지하지 못할 수 있기 때문.
● 그래서 API가 예외 발생 시 그걸 개발자에게 전파해, 대처코드를 작성하도록 유도
● 결론: throws는 “통보”이다. 예외를 없애는 것이 절대 아니다.

4. 메서드 재정의와 throws
● 메서드 재정의 시 조상클래스 메서드가 던지는 예외보다, 부모 예외를 던질 수 없다.
☞ 부모 클래스 메서드에서 IOException을 throw하고 있는데, 자식 클래스 메서드에서 Exception을 throw하고 있다면 에러.

# 사용자 정의 예외
1. 정의
● API에 정의된 exception 이외에 필요에 따라서 사용자 정의 예외 클래스를 작성할 수 있다.
● 대부분 exception이나 runtimeException클래스를 상속받아 작성한다.
● checked를 활용할 시, 명시적 예외 처리 또는 throws가 필요
☞ 코드는 복잡해지지만, 처리 누락 같은 오류발생 가능성이 줄어듦
● runtime을 활용할 시, 묵시적인 예외 처리가 가능
☞ 코드는 간결해지지만, 예외 처리가 누락될 가능성이 발생

2. 장점
● 객체 활용: 내가 필요한 추가정보나 기능을 활용하는 것이 가능
● 코드의 재사용: 동일한 상황에서 예외 객체를 재사용하는 것이 가능
● throws 메커니즘의 이용: 중간 호출 단계에서 return하는 것이 불필요

3. 첨언
● 많은 경우 시스템에서 발생하는 RuntimeException은 try~catch의 처리 대상이라기보다는디버깅의 대상이다.
● 애초에 코드를 잘못 짠 것. 명심합니다

# 보론
1. 에러의 종류
● 문법 에러: 실행 자체가 안됨
● 논리 에러: 실행은 되는데 정상적으로 실행이 안됨
☞ 이건 둘다 개발자의 실수. 개발자가 직접 디버깅해야함.
● 시스템 에러: 자바 시스템 자체에서 발생하는 에러

2. 예외란?
● Exception. 특정상황에서만 발생하고, 무조건 배제해야 하는 요소가 아님
● RuntimeEx: 실행 시에 발생하는 예외
● Non-RuntimeEx: 컴파일 시에 발생하는 예외
● 둘을 구분하는 방법: API를 켜봤을 때 상속구조 Exception 밑에 RuntimeException이 있는지 여부.모든 exception은 Exception 클래스에 속해있다는 점 확인

● RuntimeEx는, 예외처리의 대상이 아니다. logic으로 처리할 대상절대 해당 예외가 발생하지 않도록 코드를 다시 짜야 함
● Non-runtime Ex는 “예외처리를 하지 않으면” 컴파일 시에 문법 에러가 발생함.이거는 “절대적으로” 예외처리를 해줘야 할 대상

3. 


# Collection Framework
1. 자료구조
● 데이터 값의 모임, 데이터 간의 관계, 데이터에 적용할 수 있는 함수나 명령
● 컴퓨터에서 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장
2. 배열
● 가장 기본적인 자료 구조
● 동일한 데이터 타입만 관리가 가능. homogeneous collection.
☞ 타입이 다른 객체를 관리하려면 매번 다른 배열이 필요하다.
● Polymorphism을 이용한 극복
☞ Object를 이용해서, 모든 객체를 참조할 수 있게 됨. 다형성그걸 자바에서 적극적으로 이용한 게 Collection Framework인 것.
☞ 담은 때는 되게 편리한데, 빼낼 때는 object형으로만 가져올 수 있음.
☞ 런타임 시 원래 해당 객체가 어떤 타입이었는지 확인 후 사용해야 해서 다소 번거롭다.
● Generic을 이용한 타입 한정
☞ 컴파일 당시에, 저장하려는 타입을 미리 제한해버린다. 런타임 시 형변환시키는 번거로움을 제거함
3. Collection Framework
● java.util 패키지에 있음. 다수의 데이터를 쉽게 처리하는 방법을 제공하는 패키지
☞ DB처럼 CRUD 기능이 중요하다.
● 핵심 인터페이스: 최상위에 Iterable, 이를 상속받는 Collection, 이를 상속받는 List와 SetList와 Set, Map을 3대 주요 인터페이스라고 한다.
☞ 각각이 어떻게 동작하는지 정확하게 익혀야 할 것
● List: 순서가 있는 데이터의 집합. 순서가 있으므로 데이터의 중복을 허락한다.
☞ ArrayList, LinkedList. 
● Set: 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허락하지 않음.
☞ HashSet, TreeSet
● key와 value의 쌍으로 데이터를 관리하는 집합. 순서는 없으나 key 중복 불가, value는 중복 가능
☞ HashMap, TreeMap

3. Collection interface
☞ 여러 메서드가 있는 것을 잘 익혀야할 것.
● 추가: add(E e), addAll(Collection <? extends E> c) 		// 제네릭이 활용된다는 점
● 조회: contains(Object o), containsAll(Collection<?> c), equals(), isEmpty(). iterator(). size()
● 삭제: clear(), removeAll(Collection <?> c), retainAll(Collection<?> c)
● 수정
● 기타: toArray()

4. List
● 특징: 순서가 있는 데이터의 집합으로 데이터의 중복을 허락함
● 주로 살펴볼 건 ArrayList랑 LinkedList

5. ArrayList
● 주요 메서드들 잘 익히자. 배열의 상위호환 느낌이지만
● 소스를 뜯어보면 사실 내부적으로 Object []에 저장하는 방식이다.
☞ 관련 기능들을 메서드로 구현해놔서 압도적으로 편리해졌을 뿐, 원리 자체는 배열에서 벗어나지 않은 것
● 즉, 처음부터 ArrayList의 사이즈를 지정해주면 사실 더 좋다. 연산 낭비를 최소화할 수 있음

6. 배열과 ArrayList
● 배열의 장점: 가장 기본적인 형태의 자료 구조. 간단하고 사용이 쉬움. “접근속도”가 빠름
● 배열의 단점: 크기 변경이 불가능함. 추가 데이터를 위해 새로운 배열을 만들고 복사해서 넣어야 함+ 비 순차적인 데이터를 추가하고 삭제하려면 많은 시간이 걸린다.
☞ ex) 특정 인덱스의 데이터를 삭제할 때 나머지 인덱스가 고정되고, 해당 자리만 null이 된다는 점이걸 인위적으로 구현하려면 나머지 인덱스를 하나하나 바꿔주는 대작업이 필요
● 배열을 사용하는 ArrayList 또한 태생적으로 배열의 장단점을 그대로 가져감
☞ 내가 직접 구현할 필요가 없을 뿐.

7. LinkedList
● 각 요소를 Node로 정의하고, node는 다음 요소의 참조값과 데이터로 구성됨.
● 각 요소가 다음 요소의 “링크정보”를 가지기 때문에 연속적으로 구성될 필요가 없다.
● 데이터 삭제나 추가 시에 node의 연결 순서에서 참조값만 달라지면 됨.
● ArrayList랑은 꽤나 이질적

8. 각각의 용도
● 순차적인 추가수정삭제 / 비순차적인 추가수정삭제 / 조회
● Array가 빠르고	  / 느리고		/ 빠르다.
● 결론: 특정 클래스가 좋고 나쁜게 아니고, 용도에 적합하게 사용해야 할 것.
☞ 소량의 데이터에서는 사실 큰 차이가 없음
● 정적인 데이터 활용, 단순한 데이터 조회용은 ArrayList
● 동적인 데이터 추가, 삭제가 많은 작업: LinkedList

9. 자료 삭제 시 주의 사항
● index를 이용해서 for문을 돌릴 때, 자료 삭제와 함께 인덱스가 하나씩 땡겨지면서 skip되는 데이터가 있을 수 있는 점.
☞ for문 내에서 i--를 넣는 등의 방법이 필요.
● forEach 문장은 read only인 점.

# Set 계열
1. 특징
● 순서 없이 데이터를 집어넣는 형태. 중복이 허용되지 않음.
● 주요 메서드는 Collection에 있는 것을 활용하게 됨
● 비교할 때 equals랑 hashCode를 비교

# Map 계열
1. 특징
● key와 value를 하나의 entry로 묶어서 데이터를 관리.
☞ key는 object 형태로 데이터 중복을 허락하지 않는다.
☞ value는 object 형태로 데이터 중복이 허락된다.
2. 주요 메서드
● Collection을 상속받고 있지 않아서, 아예 새로 익혀야 한다.
☞ 그래봤자 느낌 자체는 비슷하다.
● 추가는 put, putAll
● 조회는 containsKey, containsValue, entrySet, keySet, get, values, size, isEmpty
☞ key랑 entry를 set으로 관리할 수 있다고.
● 삭제는 clear, remove
● 수정은 put, putAll – 추가랑 동일함.