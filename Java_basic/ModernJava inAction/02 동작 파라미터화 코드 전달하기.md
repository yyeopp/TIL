# Chapter 02: 동작 파라미터화 코드 전달하기

---

## Intro

사용자의 요구는 시시각각 변화한다. 이에 대응하는 프로그래머는,

- 엔지니어링적 비용을 최소화하고

- 기능을 새로 추가하더라도 쉽게 구현할 수 있어야 하며

- 장기적 관점에서 유지보수가 쉬워야 한다.

**동작 파라미터화**는, **아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록**을 의미한다.

- 코드 블록의 **실제 실행**은 나중으로 미뤄진다.

- 예를 들어 나중에 실행된 메서드의 파라미터로 코드 블록을 전달하는 식.
  
  - 코드 블록에 따라 **메서드의 동작이 파라미터화**되는 효과가 있다.

- 이를 사용함으로써, 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.

## 변화하는 요구사항에 대응하기

*사과를 필터링하는 예제*를 활용한다.

### 첫 번째 시도: 녹색 사과 필터링

> 만약 요구사항이 녹색 사과만을 필터링해내는 것이라면?

`filterGreenApples(List<Apple> inventory)`  메서드를 구현하면서, 리스트를 순회해 색을 비교하면 된다. 여기까지는 간단하다.

### 두 번째 시도: 색을 파라미터화

> 요구사항이 빨간 사과를 함께 필터링해내는 것이라면?

물론 `filterRedApples` 메서드를 구현하면서 위 코드를 복붙하는 방법이 있다. 하지만 반복이 과하므로 좋은 코드는 아니다.

**색을 파라미터화**하여 메서드에 추가한다면, 보다 유연한 코드를 만들 수 있다.

```java
List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if(apple.getColor().equals(color)) {
            result.add(apple);
        }
    }
    return result;
}

List<Apple> greenApples = filterApplesByColor(inventory, GREEN);
```

나름대로 괜찮은 코드다.

### 세 번째 시도: 가능한 모든 속성으로 필터링

> 요구사항이 150g 이상의 사과를 필터링해내는 것이라면?

더 이상 Color 파라미터 하나로 기능 구현이 불가하다.

- `filterApplesByWeight` 메서드를 새로 구현하는 방법이 있으나, 중복이 심하다.

- Color와 Weight 파라미터를 모두 집어넣고 **어떤 기준으로 필터링할지 가리키는 플래그**를 함께 파라미터로 집어넣는 거대한 `filterApples` 메서드를 만드는 방법이 있으나,
  
  직접 구현해보면 만든 사람 외에는 아무도 알아볼 수 없는 형편없는 코드가 된다.
  
  심지어 다른 기준을 새롭게 집어넣고 싶을 때 완전히 고장난다.

이런 문제에서, **동작 파라미터화**를 통해 유연성을 확보할 수 있다.

## 동작 파라미터화


