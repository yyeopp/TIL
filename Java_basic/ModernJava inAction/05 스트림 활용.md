# Chapter 05: 스트림 활용

---

## 필터링

필터링은 스트림의 요소를 **선택**하는 방법이다.

### 프레디케이트로 필터링

`filter` 메서드는 **프레디케이트**를 인수로 받아서, 프레디케이트와 일치하는 모든 요소를 포함하는 **스트림**을 반환한다.

- `Predicate`는 `boolean`을 반환하는 함수

### 고유 요소 필터링

스트림은 **고유 요소**로 이루어진 스트림을 반환하는 `distinct` 메서드를 지원한다.

- 고유 여부는 객체의 `hashCode`와 `equals`로 결정된다.

---

## 스트림 슬라이싱

슬라이싱은 스트림의 요소를 **선택하거나 스킵**하는 방법이다.

### 프레디케이트를 이용한 슬라이싱

#### takeWhile 활용

여러 요리가 List 자료구조 내에 칼로리 순으로 정렬되어 있다고 가정할 때, 320칼로리 이하의 요리를 선택하는 방법을 생각해본다.

`filter`로 구현하는 방법이 당연스럽게 떠오르지만, `filter`는 기본적으로 **전체 스트림**을 반복한다는 점에서 **이미 해당 List가 정렬되어 있다는 사실**을 감안할 때 다소 비효율적이다.

자바9에서 추가된 `takeWhile` 연산을 이용하여 이를 보다 효율적으로 처리할 수 있다.

- `takeWhile`의 인수로 프레디케이트를 적용하면, 해당 조건을 만족시키는 요소까지만 스트림을 **슬라이스**할 수 있다.

#### dropWhile 활용

그 반대로 해당 조건을 만족시키는 요소를 스트림에서 제외하는 슬라이싱 처리는 `dropWhile`로 구현할 수 있다.

- 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버리는 처리

### 스트림 축소

`limit(n)` 메서드는 **주어진 값 이하의 크기를 갖는 새로운 스트림을 반환**한다.

`filter`와 조합한다고 할 때, 프레디케이트와 일치하는 첫 n개 요소를 선택한 뒤 즉시 새로운 스트림으로 반환한다.

### 요소 건너뛰기

`skip(n)` 은 처음 n개 요소를 제외한 스트림을 반환한다.

---

## 매핑

특정 객체에서 특정 데이터를 선택하는 작업에서 **매핑**을 사용한다.

스트림 API에서 `map` 과 `flatMap` 메서드를 활용한다.

### 스트림의 각 요소에 함수 적용하기

`map` 메서드는 **함수**를 인수로 받는다.

인수로 제공된 함수는 각 요소에 적용되며, 함수를 적용한 결과가 **새로운 요소**로 **매핑**된다.

- 이는 기존의 값을 **고친다**는 개념이 아니다. 새로운 버전을 만든다는 개념에 보다 가깝다.

```java
List<String> dishNames = menu.stream()
                            .map(Dish::getName)
                            .collect(toList());
```

- 위와 같이, `map`에 함수로 인수로 넘김으로써 **새로운 스트림**을 반환할 수 있다.

### 스트림 평면화

`flatMap` 메서드는 스트림의 각 값을 **다른 스트림으로 만든** 다음, **모든 스트림을 하나의 스트림으로 연결**하는 기능을 수행한다.

- 인수로는 **각 요소를 각각의 스트림으로 만드는 함수를** 넣고, `flatMap`이 최종적으로 생성된 모든 스트림을 하나로 이어서 **평면화**하는 방식

```java
List<String> uniqueCharacters = 
    words.stream()
        .map(word -> word.split(""))
        .flatMap(Arrays::stream)
        .distinct()
        .collect(toList());
```

- 위 코드는 List에 입력된 단어들을 모두 종합하여 유니크한 문자를 추출하는 코드다.

- 최초에 `split`을 통해 `String[]`의 스트림이 생성되면,

- `flatMap` 내부에서 `Arrays.stream()` 함수를 이용해 각 `String[]` 을 `Stream<String>` 으로 변환하고

- `flatMap`이 최종적으로 하나의 `Stream<String>` 으로 합쳐낸다.

---

## 검색과 매칭

특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리를 위해, 다양한 API가 제공된다.

### 프레디케이트가 적어도 한 요소와 일치하는지 확인

`anyMatch` 메서드는 주어진 스트림에서 **적어도 한 요소와 일치하는지** 여부를 확인한다.

- `boolean`을 반환하므로, **최종 연산**이다.

### 프레디케이트가 모든 요소와 일치하는지 검사

`allMatch`는 스트림의 **모든 요소가** 프레디케이트와 일치하는지 검사한다.

마찬가지로 최종 연산이다.

#### noneMatch

`noneMatch`는 `allMatch`와 정확히 반대 연산을 수행한다.

스트림 전체를 순회하면서, 프레디케이트와 전부 불일치하는지 검사한다.

#### 쇼트서킷

위 세 가지 메서드는 스트림의 쇼트서킷 기법을 활용한다.

- 세 가지 모두 잘 생각해보면, **전체 스트림을 순회하지 않더라도 중간에 결과를 반환할 수 있다**.

- 이와 같이 스트림의 모든 요소를 처리할 필요가 없는 상황을 **쇼트서킷**이라고 부른다.

- `limit`도 쇼트서킷 연산이다.
  
  - 무한한 요소를 가진 스트림을 유한한 크기로 줄이는 유용한 연산이다.

### 요소 검색

`findAny` 메서드는 현재 스트림에서 **임의의 요소**를 반환한다.

보통 다른 메서드와 연결하여, **쇼트서킷**을 적용해 결과를 빠르게 찾아 종료시키는 데 사용한다.

- `filter`와 연결하여, **가장 처음 발견된 요소를 반환**하고 종료

`findAny`는 특성 상 `Optional` 객체를 반환하게 된다.

#### Optional이란?

`Optional<T>` 클래스는 값의 존재나 부재 여부를 표현하는 **컨테이너 클래스**이다.

`null` 에서 발생하는 많은 오류를 보완하기 위해 설계된 클래스로,

값이 존재하는지 여부를 확인하고, 값이 없을 때의 처리방안을 강제한다는 이념을 담고 있다.

### 첫 번째 요소 찾기

`findFirst` 메서드는 스트림에서 만족하는 **첫 번째 요소**를 반환한다.

성격 상 `findAny`와 거의 비슷한데, 둘의 차이는 **병렬성**이다.

- 스트림의 **논리적 순서**가 매우 중요하다고 가정할 때, 멀티 스레드 환경에서 해당 스트림을 처리한다면 **첫 번째 요소**에 대해 안전하게 판단하기가 쉽지 않다.

- 만약 이러한 **논리적 순서**가 매우 중요하지 않고 그냥 아무거나 가장 먼저 튀어나오는 게 필요한 상황이라면, 그러한 제약이 없는 `findAny`를 사용하는 게 좋다.

---

## 리듀싱

리듀싱 연산은 **모든 스트림 요소를 처리하여 값으로 도출**하는 연산이다.

함수형 프로그래밍에서는, 이러한 과정이 마치 종이를 원하는 모양이 될 때까지 접는 것과 비슷하다고 하여 **폴드**라고 부른다.

### 요소의 합

`reduce` 메서드에서는 **초깃값**과 **그에 대한 처리 함수**를 인수로 입력하여 스트림의 모든 요소를 처리할 수 있다.

```java
 Arrays.stream(new BufferedReader(new InputStreamReader(System.in))
                                .readLine().split(" "))
                .map(Long::parseLong)
                .reduce(0L, Long::sum));
```

- 위 코드에서는 `12 44 14` 같이 입력된 숫자들의 총합을 구할 수 있다.

스트림의 모든 요소가 소비되는 기작은, 각 요소가 덧셈 등의 연산으로 소비된 후 그 다음 요소에 **누적값으로** 적용하는 방식이다.

#### 초깃값 없음

초깃값을 받지 않는 `reduce`도 가능한데, 대신 `Optional` 객체를 반환하게 된다.

### 최댓값과 최솟값

`Optional<Integer> max = numbers.stream().reduce(Integer::max)`

`Optional<Integer> min = numbers.stream().reduce(Integer::min)`

#### 맵 리듀스 패턴

스트림에 담겨 있는 요소를 **카운팅**할 때 아래와 같은 방식을 사용할 수 있다.

```java
int count = 
    menu.stream()
        .map(d -> 1)
        .reduce(Integer::sum);
```

- 각 요소를 단순히 1로 매핑한 뒤, `reduce`로 합계를 계산하는 방식

이와 같이 `map`과 `reduce`를 연결하는 기법을 **맵 리듀스 패턴**이라고 한다.

요소를 손쉽게 **병렬화**하는 특징 덕분에, 구글이 웹 검색에 적용한 바 있다.

---

## 숫자형 스트림

리듀싱 예제 코드에는 **박싱 비용**이 숨어있다.

- `Integer` 형으로 스트림이 구성되어 있기 때문에, 합계를 계산하기 위해 기본형 변수인 `int`로 언박싱하는 과정이 존재한다.

스트림 API는 **숫자형 스트림**에 대해 이러한 박싱 비용을 줄이고 효율적으로 처리할 수 있도록, **기본형 특화 스트림**을 제공하고 있다.

### 기본형 특화 스트림

자바8은 세 가지 기본형 특화 스트림을 제공한다.

- `IntStream`, `DoubleStream`, `LongStream`

각 인터페이스는 `sum`, `max` 같이 자주 사용하는 **숫자 관련 리듀싱 연산 수행 메서드**를 **스트림 인터페이스 수준에서** 제공한다.

당연히, 필요할 때 다시 랩핑객체 스트림으로 복원하는 기능도 제공하고 있다.

#### 숫자 스트림으로 매핑

`mapToInt`, `mapToDouble`, `mapToLong` 세 가지 메서드가 있다.

이들은 `map`과 정확히 같은 기능을 수행하지만, `Stream<T>` 대신 **기본형 특화 스트림**을 반환한다.

```java
 Arrays.stream(new BufferedReader(new InputStreamReader(System.in))
                                .readLine().split(" "))
                .mapToLong(Long::parseLong)
                .sum());
```

- 앞선 예제코드를 위와 같이 개선할 수 있다.

- `sum()` 은 스트림이 비어있을 시 기본값인 0을 반환해준다.

#### 객체 스트림으로 복원하기

`boxed()` 메서드를 사용하면 기본형 특화 스트림을 일반 스트림으로 변환하게 된다.

#### 기본값 : OptionalInt

`sum`을 처리할 때 스트림에 요소가 없어서 0이 반환되는 상황과 실제 sum값이 0인 상황을 구분하려면, `Optional` 같은 개념이 들어가야 한다.

기본형 특화 스트림에 대응하는 `Optional` 클래스로, `OptionalInt`, `OptionalDouble`, `OptionalLong`을 사용할 수 있다.

### 숫자 범위

프로그램에서 **특정 범위의 숫자를 이용하고자 할 때**, `IntStream`과 `LongStream`에서 `range` 또는 `rangeClosed`라는 두 가지 **정적 메서드**를 사용할 수 있다.

- 범위를 지정하여 선언하면, 해당 범위의 숫자를 가지는 스트림을 생성해준다.

---

## 스트림 만들기

가장 흔히 사용되는 컬렉션에서 스트림을 얻는 방법 외에도 다양한 방식으로 스트림을 생성할 수 있다.

### 값으로 스트림 만들기

`Stream.of` 메서드를 이용해 임의의 값들을 받아서 스트림을 만들 수 있다.

그리고 `empty` 메서드를 이용하면, 스트림이 비워진다.

### null이 될 수 있는 객체로 스트림 만들기

자바9에서는 Nullable 객체를 스트림으로 만들 수 있는 메서드가 추가되었다.

```java
Stream<String> values = 
    Stream.of("config", "home", "user")
        .flatMap(key -> Stream.ofNullable(System.getProperty(key)));
```

- 시스템 프로퍼티를 key 값으로 조회하고 `flatMap`을 이용해 하나로 합친다.

- `ofNullable`을 이용함으로써, **프로퍼티가 존재하지 않는 경우**에 대해 null-safe 처리가 가능하다.

### 배열로 스트림 만들기

`Arrays.stream()`을 사용하면 배열에서 스트림을 만들 수 있다.

### 파일로 스트림 만들기

I/O 연산에 사용하는 자바의 NIO API는 스트림 API를 활용할 수 있도록 업데이트 되었다.

- `java.nio.file.Files`의 많은 정적 메서드는 스트림을 반환한다.

### 함수로 무한 스트림 만들기

스트림 API는 함수에서 스트림을 직접 생성하는 `iterate`와 `generate` 메서드를 지원한다.

두 연산을 이용하면, **무한 스트림**을 만들 수 있다.

- 고정된 데이터 소스 (컬렉션 등) 에서 고정된 크기의 스트림을 만들었던 것과 달리,

- 크기가 고정되지 않은 스트림을 만들어서 무제한적으로 값을 계산한다.

보통 무한한 값을 출력하지 않도록 `limit`나 `takeWhile` 함수와 함께 사용된다.

---

## 요약

- 스트림 API를 이용하면 복잡한 데이터 처리 질의를 간명하게 표현할 수 있다.

- `filter, distinct, takeWhile, dropWhile, skip, limit` 메서드로 스트림을 **필터링**하거나 자를 수 있다.
  
  - 소스가 정렬되어 있다면, `takeWhile, dropWhile` 메서드가 보다 효율적일 수 있다.

- `map, flatMap` 메서드로 스트림의 요소를 추출하거나 변환할 수 있다.

- `findFirst, findAny` 메서드로 스트림의 요소를 **검색**할 수 있다. 그리고 `allMatch, noneMatch, anyMatch` 메서드를 이용해 주어진 프레디케이트와 일치하는 요소를 검색할 수 있다.
  
  - 이들은 **쇼트서킷**의 성격을 가진다. 즉, 결과를 찾는 즉시 반환하여 전체 스트림을 처리하지 않을 수 있다.

- `reduce` 메서드로 스트림의 모든 요소를 반복 조합하여 값을 도출할 수 있다.

- `IntStream, DoubleStream, LongStream`은 기본형 특화 스트림으로 각각의 기본형에 맞게 특화되어 있다.

- 컬렉션 뿐만 아니라 값, 배열, 파일, 메서드로도 스트림을 만들 수 있다.

- 무한한 개수의 요소를 가진 스트림을 무한 스트림이라고 한다.


