# Chapter 07: 병렬 데이터 처리와 성능

---

## Intro

데이터 컬렉션을 병렬로 처리하는 과정을 상세히 뜯어보면 아래와 같다.

- 데이터를 여러 개의 서브파트로 분할한다.

- 각 서브파트를 각각의 스레드로 할당한다.

- 할당된 스레드 간의 의도치 않은 경합 상태가 발생하지 않도록, 적절한 동기화 처리를 추가한다.

- 마지막으로 부분 결과를 합친다.

스트림API는 데이터 병렬 처리를 자연스럽고 쉽게 가능하도록 해준다.

이를 이해하기 위해 기반 원리에 대해 확인한다.

---

## 병렬 스트림

컬렉션에 `parallelStream` 을 호출하면 **병렬 스트림**이 생성된다.

- 스트림 요소를 여러 개의 **청크**로 분할한 스트림

- 이로써 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당된다.

```java
Stream.iterate(1L, i -> i+1)
    .limit(n)
    .parallel()
    .reduce(0L, Long::sum);
```

- `n`을 입력받아 1부터 n까지의 모든 숫자의 합계를 반환하는 스트림이다.

- `parallel`을 호출함으로써, 모든 숫자의 합계를 구하는 `reduce` 가 병렬로 처리된다.

### 순차 스트림과 병렬 스트림 간 변환

병렬과 순차 사이에는 자유로운 변환이 가능하다.

- 병렬 상태라면 `sequential()`

- 순차 상태라면 `parallel()`

단, 결과적으로 전체 파이프라인에 영향을 미치는 것은 둘 중 **최종적으로 호출된 메서드**이다.

#### 병렬 스트림에서 사용하는 스레드 풀

병렬 스트림은 내부적으로 `ForkJoinPool`을 사용하고 있다.

그리고 `ForkJoinPool`은 기본적으로 **프로세서 수**에 상응하는 스레드를 가지도록 설계되어 있다.

### 스트림 성능 측정

적절한 툴을 사용하여 위 코드를 단순 `for`문과 성능 비교해보면, 오히려 스트림 쪽 성능이 훨씬 떨어지는 것을 확인할 수 있다.

이는 두 가지 문제로 인해 발생한다.

- 반복 결과로 **박싱된 객체**가 만들어진다. 숫자를 더하려면 **언박싱**해야한다.

- 반복 작업이 병렬로 수행 가능한 **독립 단위로 나누기가 어렵다**.

#### 더 특화된 메서드 사용

```java
LongStream.rangeClosed(1, N)
    .parallel()
    .reduce(0L, Long:sum);
```

- 위와 같이 `LongStream`을 사용하여 병렬 스트림을 개선한다.
  
  - 기본형인 `long`을 직접 사용하게 되므로, **박싱, 언박싱 오버헤드**가 사라진다.
  
  - `rangeClosed`를 사용하면 숫자 범위를 **손쉽게 청크로 분할**할 수 있다.

이 상태에서 성능을 측정하면, 멀티코어 CPU의 성능에 비례하여 성능이 증대됨을 확인 가능하다.

### 병렬 스트림의 올바른 사용

병렬화는 절대 공짜가 아니다.

- 스트림을 재귀적으로 분할해야 하고

- 각 서브스트림이 서로 다른 스레드의 리듀싱 연산에 할당되어야 하고

- 이들의 결과가 하나로 합쳐져야 한다.

멀티코어 간의 데이터 이동 또한 상당한 비용을 감수해야 하는 부분이다.

즉, 병렬화를 아예 이용할 수 없는 상황을 적절히 파악해야 하고, 사용하더라도 올바르게 사용해야 한다.

### 병렬 스트림 효과적으로 사용하는 방법

몇 가지 가이드라인이 제시될 수 있다.

- 확신이 서지 않으면 직접 측정할 것

- **박싱**에 주의할 것
  
  - 되도록 기본형 특화 스트림을 사용할 것

- 순차 스트림의 성능이 더 좋은 경우를 잘 식별할 것
  
  - `limit` 나 `findFirst` 같은 연산은 병렬 스트림이 부적절함

- 전체 파이프라인의 연산 비용을 고려할 것
  
  - 요소의 수와 연산 비용을 비교했을 때, 연산 비용 쪽이 꽤 높다면 병렬 스트림을 통해 성능을 개선할 여지가 있다.

- 소량의 데이터에는 병렬 스트림이 도움되지 않음

- 스트림을 구성하는 자료구조가 적절한지 확인할 것
  
  - `LinkedList`보다 `ArrayList`가 분할하기에 더 효율적임

- 스트림의 특성과 파이프라인의 중간 연산을 잘 고려할 것
  
  - 필터 연산이 있으면 스트림 길이를 예측할 수 없으므로, 병렬 처리가 비효율적일 수 있음

- 최종 연산의 병합 과정 비용을 고려할 것
  
  - 병합 비용이 꽤 비싸다면 병렬 처리가 비효율적임


