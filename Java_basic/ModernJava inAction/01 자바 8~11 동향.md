# Modern Java in Action

---

# Part 1: 기초

---

# Chapter 01: 자바 8~11 동향

----

## 자바가 변화하는 이유

프로그래밍 언어도 생태계를 구축하고 있다. 새로운 언어는 계속 등장하고, 진화하지 않는 기존 언어는 사장된다.

자바는 공개 직후부터 경쟁 언어를 대신해 커다란 생태계를 성공적으로 구축한 언어이다. 왜 성공했을까?

### 프로그래밍 언어 생태계에서의 자바의 위치

**출발이 좋았다.**

- 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어

- 스레드와 락을 이용한 소소한 수준의 동시성 지원

- 코드를 JVM 바이트 코드로 컴파일하는 특징
  
  - 모든 브라우저에서 가상 머신 코드를 지원하면서 특히 **Web**에서 인기를 끌게 됨

하지만 새로운 바람이 불고있다.

**빅데이터의 도전**: 멀티코어 컴퓨터와 컴퓨팅 클러스터를 이용해, 테라바이트 이상의 데이터셋을 효과적으로 처리해야 한다. 병렬 프로세싱의 활용이 절대적

자바 8에서는 크게 3가지 프로그래밍 개념을 제공함으로써 이에 대응하고 있다.

### 스트림 처리

**스트림**은, 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.

이론적으로, 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이고, 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.

> #### 비유: 자동차 생산공장 라인
> 
> 생산 공장은 여러 자동차로 구성된 스트림을 처리한다.
> 
> 각각의 작업장은 자동차를 받아 수리하고 다음 작업장으로 넘겨준다. 이 때,
> 
> **전체 조립 라인은 자동차를 물리적인 순서로 한 개씩 운반하지만,**
> 
> **각각의 작업장에서는 동시에 다른 작업을 처리하고 있다.**

자바 8에서는 `java.util.stream` 패키지에 스트림 API를 추가했다.

`Stream<T>` 는, T 형식으로 구성된 **일련의 항목**을 의미한다.

- 일단은 스트림 API가, **조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 생각하자.**

핵심은, 기존에는 한 번에 한 항목을 처리하였지만 자바 8에서는 작업을 고수준으로 추상화하여, 일련의 스트림으로 처리할 수 있다는 것이다.

입력 부분을 여러 CPU 코어에 할당함으로써 멀티코어에 대응할 수도 있다는 장점이 생긴다.

### 동작 파라미터화로 메서드에 코드를 전달하기

코드 일부를 API로 전달하는 기능.

> #### 예시: 송장 ID를 정렬하는 sort 메서드를 실행
> 
> 송장 ID의 형식이 연도와 국가코드, 고객ID를 모두 섞어놓은 형태라면,
> 
> sort를 할 때 단일 메서드로는 구현이 곤란하다.

자바 8 이전을 기준으로는, 위 예시처럼 `Comparator` 객체를 만들어서 넘겨줄 것.

자바 8에서는, **메서드를 다른 메서드의 인수로 넘겨주는 기능**을 제공한다.

- `compareUsingCustomerID` 같은 메서드를 sort 메서드의 **인수로 전달**함으로써 기능 구현이 가능하다는 뜻

- sort 메서드의 동작을 **파라미터화**한다.

이를 **동작 파라미터화(behavior parameterization)** 라고 부른다.

스트림 API는, 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초한다.

### 자바가 진화해야 하는 이유

자바 8의 가장 큰 변화는, 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다는 점.

함수형 프로그래밍에서는, 우리가 하려는 작업이 최우선시되고 그 작업을 어떻게 수행하는지는 별개로 취급한다.

자바는, 프로그래밍 언어로서 하드웨어나 프로그래머의 기대의 변화에 부응하는 방향으로 변화하고 있다.

-----

## 자바 함수

프로그래밍 언어에서의 **함수**라는 용어는 주로 **메서드** (정적)와 같은 의미로 사용된다.

자바 8에서는, 함수를 **새로운 값의 형식으로** 추가했다.

원래 자바에서 **조작 가능한** 값의 형식은 두 가지.

- Primitive type의 int, double 같은 원시 자료형

- Reference type의 클래스 instance. 즉 객체

프로그래밍 언어는, 결국 이러한 **값**을 바꾸는 것이 핵심이다. 이렇게 자유롭게 조작 및 전달이 가능한 값을, *일급 시민*으로 표현한다.

이 때 메서드, 클래스는 본래 **그 자체로** 값이 될 수 없는 인자들이였다. 자바 8에서는 이들을 *일급 시민*으로 만들었다는 점이 핵심

메서드를 그 자체로 값으로 만들어, 런타임에 전달할 수 있다면 프로그래밍 시 유용하게 활용할 수 있다.

### 메서드와 람다를 일급 시민으로: 메서드 참조

자바 8의 새로운 기능, **메서드 참조 (method reference)** 

```java
File [] hideenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
});
```

*디렉터리의 모든 숨겨진 파일을 필터링하는 프로그래밍을 할 때* 기존의 코드는 이렇다.

`File` 클래스는 원래도 `isHidden` 메서드를 제공하고 있지만, 해당 메서드를 **매개변수로 런타임에 집어넣는 것은** 불가능하다.

그래서 우회적으로 `FileFilter` 객체(인스턴스)를 집어넣고 `accept` 메서드를 오버라이딩해야한다.

`new`로 객체를 생성해서 **객체 참조**를 사용해야 하는 기존의 프로그래밍이다.

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden)
```

**메서드 참조** 기능을  사용하게 되면 코드가 이렇게 간결해진다.

`::`는 **해당 메서드를 값으로 사용하라**라는 의미이다. `listFiles` 메서드의 매개변수로, 메서드를 직접 전달할 수 있다.

단, 이 때 전달되는 `isHidden` 은 **함수**라고 부르는 게 보다 정확하다.

결론적으로, 자바 8에서는 **메서드 참조**를 통해 메서드가 **일급시민**의 지위를 가질 수 있다.

**코드**가 마음대로 전달되는 느낌으로도 볼 수 있다.

#### 람다: 익명 함수

위와 같은 named 메서드 뿐만 아니라, **람다**를 포함하는 함수도 값으로 취급될 수 있다. 이 때 람다는 **익명 함수**라고도 부른다.

```java
(int x) -> x + 1
```

`x라는 인수를 호출하면 x+1을 반환` 하는 내용의 코드로, 이게 **일급시민**으로 취급 가능하다.

### 코드 넘겨주기: 예제

```java
public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
}
public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}
public interface Predicate<T> {
    boolean test(T t);
}
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory) {
        if(p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}

filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```

자세한 동작 원리는 추후 다시 학습하자.

- 물론 `Predicate`만 빼고는 알아볼 만하다. 제법 신기하다.

눈 여겨볼 것은, **메서드를 인자로 전달함으로써** 중복되는 코드를 방지하고 시인성을 높였다는 점이다.

> #### `Predicate`가 대체 뭐지?
> 
> - `filterApples` 메서드는 `Predicate<Apple>`을 파라미터로 받고 있다.
> 
> - 수학에서, 인수로 값을 받아 T/F를 반환하는 함수를 predicate라 한다.
> 
> - 자바 8에서는 이걸 사용하게 된다. 나중에 자세히 알게 될 것.

### 메서드 전달에서 람다로

위 코드에서 만약 `isGreenApple` 같은 메서드가 한두번만 쓰이고 마는 기능이라면?

- 굳이 메서드를 따로 빼서 정의할 필요가 없이, **람다**를 활용하는 게 효율적이다.

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()) );
filterApples(inventory, (Apple a) -> a.getWeight() >150 );
```

이렇게 만들 수 있다. **코드를 전달한다**는 개념이 보다 와닿는 모습이다.

물론, 필요에 따라 조절할 문제다. 람다가 너무 길어진다면 굳이 사용하지 않는 것이 명확성에 도움을 줄 것이다.

----

## 스트림

`Collection`은 자바 어플리케이션에서 아주 중요하게 활용된다.

하지만, 컬렉션 API는 **반복 과정을 직접 처리해야 하는** 한계가 있다. `for-each` 구문을 이용해, 요소를 반복하면서 작업을 수행해야 하는데 이런 방식을 **외부 반복**이라고 한다.

```java
import static java.util.stream.Collectors.groupingBy;

Map<Currency, List<Transaction>> transactionsByCurrencies = 
    transactions.stream().filter((Transaction t) -> t.getPrice() > 1000)
                        .collect(groupingBy(Transaction::getCurrency));
```

*거래 리스트에서 고가의 거래만 필터링하고, 통화로 결과를 그룹화하는 예제*를 **스트림 API**로 구현한 모습이다.

컬렉션 API만 사용하면 코드가 3배쯤 길어진다. 아직은 이해하기 어렵다.

우선, 스트림 API를 이용하면 컬렉션 API와 상당히 다른 방식으로 데이터를 처리한다는 점만 알자.

- 스트림 API에서는 외부 반복 루프를 신경 쓸 필요 없이, 라이브러리 내부에서 모든 데이터가 처리되는 **내부 반복**이 일어난다.

### 멀티스레딩은 어렵다

> 요즘 컴퓨터에 CPU가 하나만 달려있는 경우는 없다. (멀티코어 컴퓨터)
> 
> 전통적인 자바 프로그램은 단 하나의 CPU만 사용하면서 나머지 CPU 자원을 낭비하는 문제가 있었고, 자바 8에서는 이를 활용하고자 스트림 API를 개선했다.

**멀티스레딩** 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신한다.

스레드를 적절히 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있기 때문에, 멀티스레딩 모델은 그 전까지 사용하던 단일 스레드 **순차적** 모델보다 다루기가 어렵다.

자바 8에서는 스트림 API로, **컬렉션 처리 시 발생하는 반복적인 패턴 문제**와 **멀티코어 활용의 어려움**을 동시에 개선했다.

1. 컬렉션 API 처리 시 자주 반복되는 패턴 (필터링, 추출, 그룹화 등)을 라이브러리에서 제공하고

2. 가지고 있는 요소를 쉽게 **병렬로 처리**할 수 있는 환경을 제공하는 **스트림**을 통해 그 처리가 멀티스레드로 이루어지도록 한 것
   
   - 라이브러리 내에서 포크-필터-결과병합이라는 과정이 **알아서** 이루어진다.

즉, 스트림과 람다 표현식을 이용하면 **병렬성을 공짜로 얻을 수 있고** 컬렉션 API를 보다 효율적으로 처리할 수 있다.

----

## 디폴트 메서드와 자바 모듈

요즘은 외부 컴포넌트를 이용해 시스템을 구축하는 경향이 강해졌다. 이에 대응하기 위해 종전에는 특별한 구조가 아닌, 평범한 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였다.

그런데 이러한 패키지의 **인터페이스를 바꿔야 하는 상황**에서는 인터페이스를 구현하는 **모든 클래스의 구현을 바꿔야** 했으므로 매우 번거로웠다.

자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록, **디폴트 메서드**를 지원한다.

- 자바 9의 경우 **모듈 시스템**을 도입하여 패키지 모음을 포함하는 모듈을 정의할 수 있게 된다.

예시로, 앞서 스트림을 설명하면서 `List<T>`를 구현한 클래스에 `.stream()` 메서드를 적용하는 코드를 보였다.

- 자바 8 이하의 버전에서는 이를 원칙적으로 컴파일할 수 없기 때문에, 가장 단순한 해결책은 **직접 인터페이스를 만들어서 stream 메서드를 추가하는 것**이다.
  
  - 물론 해당 인터페이스를 구현한 모든 클래스를 새로 코딩해야 한다.

- 즉, 인터페이스의 변화는 이를 구현한 클래스를 전부 변화시켜야 한다는 점에서 지나친 부담을 유발한다.

자바 8에서 제공되는 디폴트 메서드는, **구현 클래스에서 구현하지 않아도 되는 메서드**를 인터페이스에 추가할 수 있는 기능이다.

메서드의 본문은 클래스 구현이 아니라, 인터페이스의 일부로 포함된다.

API 상 규격명세에서도, `default`라는 새로운 키워드를 지원하고 있다.

- 예시로, 자바 8부터 List에서는 직접 sort 메서드를 호출할 수 있다.

- ```java
  default void sort(Comparator<? super E> c) {
      Collections.sort(this, c);
  }
  ```
  
  List 인터페이스에 해당 디폴트 메서드 정의가 추가되었기 떄문.
