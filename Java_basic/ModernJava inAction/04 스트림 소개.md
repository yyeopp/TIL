# Part 2: 함수형 데이터 처리

---

# Chapter 04: 스트림 소개

---

## Intro

사실상 모든 Java 어플리케이션에서 컬렉션을 만들고 처리하는 과정을 포함한다.

컬렉션은, **데이터를 그룹화하고 처리**한다.

- 하지만 컬렉션에 대한 연산은 여전히 후진적인 수준에 머무른다.

> #### SQL과의 비교
> 
> SQL에서는 **선언형**으로 자료를 그룹화하고 탐색하는 연산을 수행하게 된다.
> 
> `SELECT name FROM dishes WHERE calorie < 400` 에서 볼 수 있듯이,
> 
> SQL에선 우리가 기대하는 것을 *명시적으로 직접 표현하고* *구현은 자동으로 제공된다.*

- 컬렉션으로도 비슷한 기능을 만들 수 있지 않을까?
  
  - 일단 멀티코어 아키텍처를 활용해 병렬로 컬렉션의 요소를 처리하는 방법이 있지만, 그 구현은 단순 반복 처리 코드에 비해 복잡하고 어렵다.
  
  - 다른 방법이 필요하다

---

## 스트림이란 무엇인가?

**스트림**은 Java 8 API에 새로 추가된 기능이다.

스트림을 이용하면, **선언형**으로 컬렉션 데이터를 처리할 수 있다.

> ##### 선언형?
> 
> 데이터를 처리하는 임시 구현 코드 대신 질의로 표현한다는 뜻

- 즉, 스트림은 **데이터 컬렉션 반복을 멋지게 처리하는 기능**이다.

- 또한 멀티스레드 코드를 구현하지 않아도 데이터를 **투명하게 병렬로 처리**할 수 있다.

### 예시

> 저칼로리의 요리명을 반환하고, 칼로리를 기준으로 요리를 정렬해야 한다면?

Java 8 이전의 코드는 다음과 같다.

```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish : menu) {
    if(dish.getCalories() < 400) {
        lowCaloricDishes.add(dish);
    }
}
Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
    public int compare(Dish d1, Dish d2) {
        return Integer.compare(d1.getCalories(), d2.getCalories());
    }
});
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish : lowCaloricDishes) {
    lowCaloricDishesName.add(dish.getName());
}
```

- 해당 코드에서 `lowCaloricDishes`는 **가비지 변수**에 해당한다.
  
  - 컬렉션 데이터를 처리하기 위한 *컨테이너* 역할만을 수행하는 **중간변수**라는 뜻.

- Java 8에서는, 이러한 가비지 변수를 도입하지 않고 세부 구현을 라이브러리 내에서 처리하도록 할 수 있다.

```java
List<String> lowCaloricDishesName = 
    menu.stream()
        .filter(d -> d.getCalories() < 400)
        .sorted(comparing(Dish :: getCalories))
        .map(Dish :: getName)
        .collect(toList());
```

- `stream()` 대신 `parellelStream()` 을 사용하면 위 코드는 멀티코어 아키텍처에서 병렬로 실행될 수 있다.
  
  - 정확히 어떤 동작이 발생하는 지에 대해서는 추후 다룬다.

### 스트림 API 활용 시의 장점

- **선언형**으로 코드를 구현할 수 있다.
  
  - 별도의 `Comparator` 클래스를 구현하는 등의 코드 없이, **동작의 수행**만을 지정하여 코드를 구현함으로써 요구사항에 보다 자유롭게 대응할 수 있다.

- 여러 개의 블록 연산을 **유연하게 조립**함으로써 **데이터 처리 파이프라인**을 만들 수 있다.
  
  - 가독성과 명확성이 유지된 가운데 복잡한 데이터 연산을 처리하는 것이 가능하다.

- 스트림 API가 자체적으로 **병럴 처리**를 지원한다.
  
  - 내부적으로 멀티코어 아키텍처를 최대한 활용할 수 있도록 구현되어 있으며,
  
  - 병렬 처리 과정에서 스레드와 락에 대해 크게 걱정하지 않아도 된다.

---

## 스트림 시작하기

### 스트림이란

**데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소**로 정의할 수 있다.

- 스트림은 컬렉션과 마찬가지로, **특정 요소**로 이루어진 **연속된 값** 집합의 인터페이스이다.
  
  - 대신 컬렉션이 **시간/공간 복잡성** 등과 같이 **요소 저장 및 접근에 대한** 연산을 주로 하는 데에 비해
  
  - 스트림은 필터, sort, map 같은 **표현 계산**식이 주를 이룬다.
  
  - 컬렉션의 주제는 **데이터**이고, 스트림의 주제는 **계산**이다.

#### 2가지 중요 특징

- **파이프라이닝** : 스트림 연산끼리 연결하여 거대한 파이프라인을 구성할 수 있다.
  
  - **게으름**, **쇼트서킷** 같은 최적화를 구현할 수도 있다.

- **내부 반복**

### 예시

```java
List<String> threeHighCaloricDishNames = 
    menu.stream()
        .filter(dish -> dish.getCalories() > 300)
        .map(Dish::getName)
        .limit(3)
        .collect(toList());
```

- 스트림을 이용해 메뉴 중에 3개의 고칼로리 요리명을 찾는 코드다.

---

## 스트림과 컬렉션

**데이터를 언제 계산하느냐**가 컬렉션과 스트림 간의 가장 큰 차이이다.

- 컬렉션은 자료구조가 포함하는 **모든 값**이 메모리에 저장된다.
  
  - 결과적으로 컬렉션에 추가하기 전에 이미 계산되어 있다.
  
  - 영화 파일이 DVD에 저장되어 있는 것과 비슷하다.

- 스트림은 이론적으로 **요청할 때만 요소를 계산**하는 자료구조이다.
  
  - 사용자가 요청하는 값만 스트림에서 **추출**되는 구조이기 때문에,
  
  - **생산자**와 **소비자**의 관계를 형성하는 특성이 있다.
  
  - 영화 파일이 인터넷을 통해 스트리밍되는 것과 비슷하다.
    
    - 영상이 재생됨에 따라 이후의 프레임이 순차적으로 필요한만큼 다운로드 되는 방식

### 딱 한 번만 탐색할 수 있다

즉, 기본적으로 **탐색된 스트림의 요소는 소비가 완료된 상태**이다.

한 번 탐색한 요소를 다시 탐색하려면, **초기 데이터 소스에서 새로운 스트림을 만들어야** 한다.

- 이런 점에서 데이터 소스가 I/O 채널일 때는 소스 반복 사용이 어려워, 스트림이 부적합하다.

### 외부 반복과 내부 반복

컬렉션 인터페이스를 사용하려면 사용자가 **직접** 요소를 반복해야 한다. 이를 외부 반복이라고 한다.

- 뭔가 요구사항이 있을 때, 컬렉션을 `forEach` 등을 이용해 통째로 돌리면서 직접 건드려야 한다.

스트림은 이에 반해 반복을 **알아서 처리하고 결과 스트림으로 저장하는 내부 반복**을 사용한다.

- 이로써 동일한 요구사항을 코드에 반영하고자 할 때,

- **필요한 동작** 자체를 주문함으로써 코드 구현이 보다 깔끔해지는 것 뿐만 아니라

- 병렬 처리, 처리 순서에 대한 최적화가 보다 자연스럽게 지원될 수 있다.

특히 **병렬성**의 경우, 외부 반복으로 이를 관리하고자 할 시 **아예 포기**하거나 `synchronized` 를 이용한 아주 어려운 코딩이 들어가야 한다.

스트림을 사용함으로써, 개발자는 **반복 과정에 주목하지 않은 상태로** 요구사항을 구현할 수 있다.

#### 반복을 숨겨주는 연산

**내부 반복**을 이용하여 데이터 처리를 원활하게 진행되기 위해선, **반복을 숨겨주는 연산**들이 미리 구현되어 있어야 한다.

자바8의 `filter`와 `map` 같은 함수들이 이를 지원하고, 더구나 대부분 **람다 표현식**을 인수로 받을 수 있게 설계되어 있어 **동작 파라미터화**를 활용 가능하다.

---

## 스트림 연산

앞선 예제코드에 사용된 스트림 연산은 두 그룹으로 구분할 수 있다.

- `filter, map, limit` : 서로 연결되어 파이프라인을 형성

- `collect` : 파이프라인을 닫음

연결 가능한 스트림 연산은 **중간 연산**이라고 하며, 스트림을 닫는 연산은 **최종 연산**이라고 한다.

### 중간 연산

중간 연산은 **다른 스트림**을 반환한다. 이에 따라 여러 개를 연결하여 **질의**를 만들 수 있다.

중간 연산은 **게으른** 특징을 가진다. 전부 합친 최종 연산으로 한 번에 처리되고, 그 전까지는 **아무 연산도 실제 수행되지 않는다**.

- **쇼트서킷**, **루프 퓨전**

### 최종 연산

최종 연산은 **스트림 파이프라인에서 결과를 도출**한다.

### 스트림 이용하기

결과적으로 스트림 이용 과정은 세 가지로 요약된다.

- 질의를 수행할 **데이터 소스**

- 스트림 파이프라인을 구성하는 **중간 연산의 연결**

- 스트림 파이프라인을 **실행**하고 결과를 만드는 **최종 연산**

이러한 방식은 **빌더 패턴**과도 비슷하다.

- 빌더 패턴 또한 설정 내용을 미리 준비해두고 최종적으로 `build` 메서드를 호출함으로써 실제 연산이 진행된다.

---

## 요약

- 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원한다.

- 스트림은 **내부 반복**을 지원한다.
  
  - `filter`, `map`, `sorted` 등의 연산이 반복을 추상화해주고 있다.

- 스트림에는 중간 연산과 최종 연산이 있다.

- 중간 연산은 스트림을 반환하면서 다른 연산과 연결되는 연산이다.
  
  - 중간 연산을 이용하여 파이프라인을 구성할 수 있고, 중간 연산만으로는 어떤 결과도 생성되지 않는다.

- `forEach`나 `count`처럼 스트림 파이프라인을 **처리**하여 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라 한다.

- 스트림의 요소는 **요청할 때** 게으르게 계산된다.


