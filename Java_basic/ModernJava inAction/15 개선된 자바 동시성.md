# Part 5 : 개선된 자바 동시성

---

# Chapter 15 : CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

---

## Intro

최근의 애플리케이션은 서비스의 크기를 줄이고 네트워크 통신이 증가한 추세를 보인다.

이에 따라 **멀티태스크** 프로그래밍이 상당히 중요해졌고, 원격 서비스나 데이터베이스 결과를 기다리는 스레드를 단순히 **블록**하는 것은 되도록 피해야 한다.

자바8의 `CompletableFuture`은 `Future` 인터페이스의 일종으로 간단하고 효율적으로 **동시성**과 **병렬성**의 문제를 해결해준다.

- **동시성**은 단일 코어 머신에서 서로 다른 작업이 동시에 실행되고 있는 것을 뜻하고,

- **병렬성**은 멀티 코어 머신에서 서로 다른 작업을 서로 다른 코어에서 실행하는 것이 하드웨어 수준에서 지원되는 것을 뜻한다.

---

## 동시성을 구현하는 자바 지원의 진화

### 스레드와 높은 수준의 추상화

프로세스는 운영체제에 한 개 이상의 **스레드**를 요청함으로써, **태스크**를 동시에 또는 협력적으로 실행할 수 있다.

이론상 4개 코어를 가진 CPU라면, 4개의 스레드에서 제각기 작업을 수행한 뒤 그 결과를 합침으로써 최대 4배의 성능을 달성할 수 있다는 뜻.

이러한 코드를 개발자가 직접 구현하는 것은 **극히 어렵고 위험하다**.

하지만 앞서 배운 **병렬 스트림**을 이용하면, 이러한 병렬 처리가 높은 수준으로 **추상화**된다는 것을 확인 가능하다.

```java
sum = Arrays.stream(stats).parallel().sum();
```

- 달리 생각해보면, 개발자가 직접 병렬 처리를 구현하기 위해 스레드를 생성하고 할당하는 것은 주객이 전도된 모습이라고 할 수 있다.

- 적절한 툴이 제공된 가운데 **병렬 처리를 추상화**할 수 있다면, 훨씬 안전하고 유지보수가 쉬운 코드가 만들어질 수 있다.

### Executor와 스레드 풀

자바5에서는 `Executor` 프레임워크와 **스레드 풀**을 이용해, 프로그래머가 **태스크 제출**과 **실행**을 분리할 수 있도록 했다.

#### 스레드의 문제

프로그래머가 자바 스레드를 직접 만들고 종료하는 것은 상당히 위험하다.

운영체제가 핸들링할 수 있는 스레드의 개수는 제한적이고, 그 생성 및 종료 비용은 매우 크다. 운영체제가 지원하는 스레드 수를 초과하여 자바 스레드를 생성하면, 애플리케이션이 예상치 못하게 크래시될 수 있다.

#### 스레드 풀이 바람직한 이유

자바의 `ExecutorService`는 태스크를 제출하고 결과를 **나중에 수집**할 수 있는 인터페이스를 제공한다.

그리고 `newFirxedThreadPool` 같은 팩토리 메서드를 이용해 **스레드 풀**을 만들고 사용할 수 있다.

프로그래머가 `Runnable`이나 `Callable` 로 **태스크**를 제공하면, 스레드 풀에서 스레드가 할당되어 이를 실행하고, 태스크 종료와 함께 다시 반환된다.

이에 따라,

- 하드웨어에 맞는 수의 태스크를 유지할 수 있고,

- 태스크의 개수가 수 천개에 달할 정도로 많더라도 스레드 풀에 **아무런 오버헤드 없이** 제출해둘 수 있다는 점이다.
  
  - 어차피 큐잉되어 순차적으로 실행될 것이기 때문.

스레드 풀에 대한 큐의 크기 조정, 거부 정책, 우선순위 등은 필요한 만큼 커스터마이징하면 된다.

#### 스레드 풀 주의사항

I/O를 기다리는 블록 상황을 유발할 태스크를 워커 스레드에 함부로 올리면 안 된다.

- 스레드 풀이 관리하는 스레드 개수는 제한되어 있기 때문에, 그 중 일부가 **블록** 상태를 자주 가지는 상황이라면 성능 이슈, 더 나아가 **데드락**을 유발할 수 있다.

- **블록을 유발할 수 있는 태스크는 스레드 풀에 제출하지 않는 것이 정석**이지만 이걸 지키기는 다소 어렵다.

프로그램 종료 시 모든 스레드 풀을 종료하는 습관을 가져야 한다.

---

## 동기 API와 비동기 API

복잡하고 위험한 스레드 작업 없이 요소에 대한 병렬 처리를 달성하기 위해서는, API 개발 자체가 달라질 필요가 있다.

예를 들어 흔히 사용하는 방식대로

```java
int f(int x);
int g(int x);
```

위와 같이 두 가지 메서드가 있다고 할 때, 이들은 **물리적 결과**를 반환하므로 **동기 API**라고 볼 수 있다.

**동기 API**에 대해 병렬 처리를 구현하기 위해서는 아주 복잡하고, 스레드의 로우 레벨까지 건드려야 하는 위험한 코드가 탄생하게 된다.

```java
Thread t1 = new Thread(() -> {f(x);});
Thread t2 = new Thread(() -> {g(x);});
t1.start();
t2.start();
t1.join();
t2.join();
```

그나마 `Future` API와 `ExcecutorService`를 이용해 조금이나마 개선하면 아래와 같다.

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
Future<Integer> y = executor.submit(() -> f(x));
Future<Integer> z = executor.submit(() -> g(x));
y.get() + z.get();
executor.shutdown();
```

조금은 나아졌지만, 결국 이 또한 `submit`이나 `shutdown` 같은 다소 시스템 레벨의 불필요한 코드로 오염된 상태다.

스트림이 **명시적 반복으로 병렬화를 수행하지 않고 내부 반복으로 개선한 것**과 같이, 해결할 필요가 있다.

이는 API 자체를 **비동기 API**로 구성하는 것이다.

### Future 형식 API

API의 시그니처 자체를 아래와 같이 바꾼다.

```java
Future<Integer> f(int x);
Future<Integer> g(int x);
```

이에 따라, 해당 API를 호출하는 쪽에서도 아래와 같이 호출하는 것이 가능하다.

```java
Future<Integer> y = f(x);
Future<Integer> z = g(x);
y.get() + z.get();
```

각 API를 호출한 결과는 `get()` 메서드를 통해 결과가 합쳐져 반환된다.


