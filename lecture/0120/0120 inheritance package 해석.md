< Car 클래스 해석 시작 >

1. Car 클래스에서 singleton 디자인.
전역변수를 private로 선언하고
getter와 setter 메서드를 generate


2. public Car()는 default 생성자
그 외에도 생성자 내에 매개변수를 다르게 집어넣어서, 
'생성자 메서드 오버로딩'을 실현
코드 중복을 막기 위해, 모든 변수를 담고 있는 생성자로 작동부를 몰아주고 있음


3. public String info()로 초보적인 toString()을 직접 구현


4. 첫 오버라이딩은 toString()에 대해서.
원래 Object 클래스의 메서드.
Car 클래스 내부에서는 toString 호출 시 단순 객체 주소가 아니라 좀더 쓸만한 값이 호출되도록 "재정의"

5. 두번째 오버라이딩은 다형성에 관한 부분. Object 클래스의 메서드인 equals를 재정의한다.
equals에 의해 객체의 주소값이 아닌, carName 변수가 비교되도록 하는 게 목적

우선 equals 내에 매개변수를 (비교 대상이 t1이라 하면, t2를) 집어넣을거니까 매개변수에 Object 타입을 명시.

if문: 매개변수에 아무것도 들어가지 않았거나, obj가 Car 클래스에 속한다는 것이 모두 true로 확인되어야 carName 비교가 개시됨.
** obj는 Object 클래스이지만 거기에 뭘 집어넣느냐에 따라 Car 클래스에 소속된 객체일 수 있음.
기본적으로 Car 클래스에 속한 객체는 Object 클래스(타입)으로서의 성질도 가지는 다형성이 나타나기 때문.
만약 Object지만 Car가 아니라면 carName을 비교하는 게 에러가 될 것
그래서 instanceof 연산자로 Car 클래스에 소속된게 맞는지를 확인

if문을 통과했어도 여전히 obj는 코드 상에서 Object 타입이기 때문에 Car 타입으로 명시적 형변환이 필요.
Car가 더 작으니까 개발자가 책임을 져야 함
Car 타입으로 선언된 car는 이제 obj를 참조하게 되는 것. 그리고 obj는 Car 타입이므로 carName이라는 메서드를 굴릴 수 있다

이제 비로소 equals 안에 Car 타입 객체가 담겼을 때, 서로 carName을 비교할 수 있게 됨


6. 나머지 void들은 별거 아님


< Taxi 클래스 해석 시작 >

1. 일단 extends로 Car를 상속받음
Taxi에 대한 생성자를 따로 만들지 않았을 경우, 기본 생성자 Taxi()가 알아서 만들어지고 + 자식 클래스이기 때문에 그 안에 super()가 알아서 선언된다.

2. 생성자를 따로 선언할 때도, 하나하나 this.를 찍어주는 건 코드 낭비.
상속 관계를 잘 이용하자. super()를 통해 부모 클래스의 생성자였던 Car(str, str, str)를 소환

3. 첫 오버라이딩은 toString()
기본적으로 Car에서 굴렸던 toString()과 비슷하지만, Taxi에 해당한다는 문구를 붙여주고 싶다.
super.toString() + "Taxi" 로 해결.
super를 잘 활용해야한다는 것

4. 두번째 오버라이딩은 speedUp()
Car가 가지던 속성을 super를 통해 가져오는 동시에, 최적화된 오버라이딩
단 이 때 speed값이 private이므로 getter와 setter를 활용해야한다는 점


< TaxiTest 클래스 해석 >

1. t1을 Taxi로 선언

2. toString()을 소환하면 Taxi클래스에서 작동함. 뒤에 Taxi가 붙은

3. 가속 시에도 Taxi클래스에 붙인 제한이 구현됨

4. getSpeed()로 private 전역변수에 접근

5. t2를 택시로 선언하면서 생성자에 새로운 값을 집어넣음
Taxi 클래스 생성자에 들어가고, 그건 또 super에 의해 Car 클래스 생성자에 들어가서 변수를 초기화

6. setCarName() 메서드로 전역변수 속성 변경.
t2의 이름은 이제 아반떼임.
근데 이건 일단 각주로 처리하자.

7. sysout(t2)에 의해 t2.toString()이 자동으로 구현되는데, 이건 왜???

8. t2.info()는 그냥 내가 만들었던 거

9. t3을 택시로 선언. 생성자에 값 대입
t3의 이름은 기아임.

10. 마찬가지로 t2, t3만 프린팅해도 toString()된 값이 나온다. 왜???

11. t2==t3가 조건식인데, t2와 t3은 각각 new 생성자에 의해 만들어진 객체들이므로 '주소값'의 일치 여부를 비교하게 됨.
결과는 "주소값이 다른 차"

12. Taxi 타입의 t4는 별도의 객체 형성 없이, 같은 타입의 t2를 참조함.
즉 둘은 모두 같은 주소에 있는 같은 객체를 참조하게 됨.
t2==t4 해보면 "주소값이 같은 차"

13. Car클래스에서 equals 메서드를 carName끼리 비교하도록 오버라이딩해놓고 왔음.
이유는 잘 모르겠지만 지금 t2는 print해보면 toString이 나오는 상태. (equals 오버라이딩이랑 상관 없음)
결국 t2.equals(t3)은 true. 둘다 K5

14. ==에 의해 비교되는 건 주소값이라는 걸 다시 한번 증명.
t2와 t3를 그냥 뽑아보면 toString의 내용이 나오는데, 내용이 완전 똑같음
그니까 주소값 비교한게 맞다는 거