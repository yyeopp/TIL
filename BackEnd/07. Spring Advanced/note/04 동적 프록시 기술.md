# 동적 프록시 기술

---

## 리플렉션

자바가 기본으로 제공하는 JDK 동적 프록시 기술이나, CGLIB 같은 프록시 생성 오픈소스 기술을 활용하면, **프록시 객체를 동적으로 만들어낼 수 있다.**

JDK 동적 프록시 기술을 이해하기 위해, **리플렉션**에 대해 알아본다.

- 리플렉션은, 클래스나 메서드의 **메타정보를 사용해서 동적으로 호출**하는 JDK 기본 제공 기술이다.

### 예제 코드 요약

- `java.lang.reflect` 패키지에서 리플렉션 기능을 제공한다.

- `Class` 라는 클래스로 **클래스의 이름을 집어넣으면** 실제 클래스를 가져올 수 있고,

- `Method`라는 클래스로 **메서드의 이름을 집어넣으면** 실제 메서드도 가져올 수 있다.

- 가져온 메서드를 `invoke()` 함수로 실행시키면,

- 사용할 클래스와 메서드를 생각보다 쉽게 **동적으로 변동**시킬 수 있다.

### 주의할 점

리플렉션을 사용하면 언뜻 애플리케이션을 동적으로 유연하게 만드는 데 도움이 될 것 같지만, 치명적인 단점이 있기 때문에 웬만해서는 사용하지 않는다.

**런타임에 동작하기 때문에 컴파일 시점에 오류를 잡을 수 없다는 점**이 문제.

프로그래밍 언어의 발달은 **타입 정보를 기반으로 컴파일 시점에 오류를 잡아주는 방향**으로 이루어지고 있는데, 리플렉션을 그것에 **역행**하는 방식이다.

**프레임워크 개발** 수준으로 **매우 일반적인 공통 처리가 필요할 때나** 부분적으로 주의해서 사용해야 한다.

- 프록시 객체를 **수 백개 쯤** 제거한다고 할 때

---

## JDK 동적 프록시

동적 프록시 기술을 사용하면, 개발자가 직접 프록시 클래스를 만드는 것이 아니라 **런타임에 프록시 객체가 동적으로 만들어진다**.

단, **자바 언어가 기본으로 제공하는** JDK 동적 프록시의 경우 **인터페이스 기반**으로 프록시를 동적 생성하기 때문에 **인터페이스가 필수**이다.

### 예제 코드 요약

- `InvocationHandler` 인터페이스를 사용하면, **프록시 처리할 로직을 담은 클래스**를 생성할 수 있다.

- `java.lang.reflect.Proxy` 를 이용하여 동적 프록시를 생성하고 원하는 로직을 구현할 수 있는데,

- `newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)` 

- 위와 같은 형태로 `Proxy` 객체를 생성하고 호출하는 방식이다.
  
  - 어떤 **클래스로더**를 사용할 것인지
  
  - 어떤 **인터페이스**들을 구현할 것인지
  
  - **프록시 로직**은 어떻게 적용할 것인지

- 이와 같은 방식으로 처리하면, 결과적으로 **프록시 클래스를 개발자가 직접 일일이 생성하지 않아도** 프록시 생성 효과를 달성할 수 있다.
  
  - **런타임에** `com.sun.proxy.$Proxy` 같은 동적 클래스를 생성 후 사용되는 것을 확인할 수 있다.
  
  - JDK 동적 프록시를 사용하고, 대신 프록시 처리하는 핸들러 로직 하나만 생성하여 공통으로 사용했다.

- 프록시 클래스를 매우 많이 사용하는 문제도 해결하고, 부가 기능 로직을 하나의 클래스에 모아서 **단일 책임 원칙**도 지키게 된다.

### 애플리케이션 적용

앞서 **모든 서비스 객체에 프록시 객체를 하나씩 생성했던** 부분을, 단 하나의 프록시 객체만 생성하여 공통 적용하는 방식으로 전환한다.

JDK 동적 프록시 (**리플렉션**) 을 활용하여 구현한다.

```java
    @Bean
    public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace) {
        OrderRepositoryV1 orderRepositoryV1 = new OrderRepositoryV1Impl();
        return (OrderRepositoryV1) Proxy.newProxyInstance(OrderRepositoryV1.class.getClassLoader(), new Class[]{OrderRepositoryV1.class}, new LogTraceBasicHandler(orderRepositoryV1, logTrace));
    }
```

- 구현 방식 자체는 익숙하다. 메서드 실행을 **리플렉션**을 이용하여 동적으로 처리하고, 클래스명이나 메서드명도 `InvocationHandler` 를 이용해 동적으로 처리한다.

- `Config` 하여 빈으로 등록하는 부분이 다소 까다로울 수 있는데, 결과적으로 `Proxy.newProxyInstance()` 를 이용하여 **프록시 객체를 대신 등록**한다는 점이 중요하다.

- 이로써 모든 서비스 인터페이스들은 서로 **프록시를 사이에 두고 의존**하는 관계를 형성할 수 있다.

#### 문제점 및 추가개발

별다른 제어 로직 없이 메서드를 동적으로 호출하기 때문에, `no-log` 라는 기능은 의도대로 동작하지 않는다.

- 프록시 객체 (`InvocationHandler`) 에 간단한 로직을 추가개발하면, 큰 무리없이 요구사항을 구현할 수 있다.

- 대신 스프링 빈 등록 시 매개변수가 추가되는 등 몇 가지만 주의해주면 된다.

### 한계

JDK 동적 프록시는 **인터페이스가 필수**이다.

인터페이스가 없이 클래스만 있는 경우 적용이 불가하다.

그런 경우 일반적인 방법으로는 더 이상 불가하고, CGLIB 같은 라이브러리를 따로 사용해야 한다.

---

## CGLIB

### 개요

CGLIB는 **바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공**하는 라이브러리이다.

이를 통해 인터페이스가 없는 **구체 클래스만을 가지고도 동적 프록시를 만들어낼 수 있다**.

원래 외부 라이브러리였는데, 스프링 프레임워크가 전면적으로 포함시켰다.

- 해당 라이브러리를 직접 사용할 일은 사실상 없다.

- `ProxyFactory`를 사용하기 전에 이해도를 높이기 위해 알아본다.

### CGLIB 코드 적용

CGLIB는 `MethodInterceptor`를 이용해 동적 프록시 실행 로직을 제공한다.

- `MethodInterceptor` 는 `InvocationHandler` 와 비슷한 역할이다. 인터페이스로써, 이를 구현하여 프록시의 **실행 로직**을 정의한다.
  
  - 호출 대상 메서드를 호출할 때 마찬가지로 `invoke`를 사용하면 되는데,
  
  - `Method`를 똑같이 사용해도 되지만 `MethodProxy`를 사용하는 쪽이 성능상 권장된다고 한다.

- `Enhancer`를 사용해서 실제 프록시 객체를 생성하는데, 몇 가지 세팅이 필요하다.
  
  - `setSuperClass` : 앞서 V2에서 했던 것 같이, CGLIB가 바이트코드 조작으로 생성해주는 프록시 객체를 **원본 객체를 상속받는다는 개념**이다. 즉, 프록시 로직을 삽입할 대상 객체를 입력한다.
  
  - `setCallback` : 프록시 실행 로직이 있는 `MethodInterceptor` 객체를 입력한다.
  
  - `create()` 하면 프록시 객체가 완성된다.

- 생성된 호출된 클래스에 대해 로그를 남겨보면,
  
  - `ConcreteService$$EnhancerByCGLIB$$25d6b0e3`
  
  - 이런 식으로 CGLIB가 enhance한 동적 프록시 클래스임이 드러나고 있다.

### CGLIB 제약

어디까지나 **클래스 기반 프록시**이기 때문에 몇 가지 제약이 있다.

- 부모 클래스의 생성자를 체크해야 한다.
  
  - 자식 클래스를 동적으로 생성하는 개념이기 때문에, 부모 클래스의 **기본 생성자**가 필요하다.

- 클래스에 `final` 키워드가 붙으면 상속이 불가능하다.

- 메서드에 `final` 키워드가 붙으면 오버라이딩이 불가능하다.
  
  - CGLIB를 생성해도 로직이 동작하지 않는다.

`ProxyFactory`와 함께 CGLIB를 적용하면 이런 단점을 해결하면서 편리해진다.

### 남은 문제

- 인터페이스 유무에 따라 JDK 동적 프록시와 CGLIB를 교차로 사용해야할 것 같다. 어떻게 해야 할지?
  
  - `InvocationHandler`와 `MethodInterceptor`를 각각 중복으로 만들어서 관리해야 하는가?

- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능 또한 공통으로 제공되려면?


