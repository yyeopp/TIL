# 쓰레드 로컬 - ThreadLocal

---

## 로그 추적기 개발

예제 애플리케이션의 요구사항은 아래와 같다.

- 모든 public 메서드의 호출과 응답 정보를 로그로 출력한다.

- 로깅으로 인해 애플리케이션의 흐름이 변경되면 안 된다.

- 메서드 호출에 걸린 시간을 출력한다.

- 정상 흐름과 예외 흐름을 구분해서 표시한다.
  
  - 예외 발생 시 예외 정보가 남아야 한다.

- 메서드 호출의 깊이를 표현해야 한다.

- HTTP 요청 단위로 트랜잭션 ID를 남겨서, 요청 간 명확하게 구분되어야 한다.

### 기존 예제 코드의 문제점

- **트랜잭션 ID를 유지하기 위해** 메서드 호출 시 `TraceId` 정보를 파라미터로 들고다녀야 했다.
  
  - 비즈니스 로직을 들고 있는 모든 메서드에서 로깅용 파라미터를 들고 다니는 문제점
  
  - 수정사항 발생 시 모든 메서드를 수정해야 한다.
  
  - 인터페이스가 있다면 문제는 더 심각함

- 로깅을 처음 시작할 때와 처음이 아닐 때 호출하는 메서드가 달라야 한다.
  
  - 다소 작위적이라고 할 수 있는 코드

---

## 필드 동기화

모든 메서드에서 `TraceId` 파라미터를 직접 들고 다니지 않도록 코드를 개선하고자 한다.

### 예제 코드 요약

- 로깅을 처리하는 `LogTrace` 인터페이스를 만들고, 그 구현체를 만든다.

- `FieldLogTrace` 의 경우 **필드에서** `TraceId` 값을 관리한다.
  
  - `begin` 과 `end` 동작에서 각기 `sync`, `release` 메서드를 이용해 **필드값에 접근**하여,
  
  - 트랜잭션 ID 유지 및 레벨 관리를 진행하는 방식

- 이 상태로 예제 코드에서 `FieldLogTrace` 를 사용하면, 애플리케이션 코드의 **외견이 매우 깔끔해진다**.
  
  - `LogTraceConfig` 클래스를 이용해 `FieldLogTrace`를 싱글톤 빈으로 등록한 뒤 사용해야 한다.
  
  - `begin`과 `beginSync` 를 섞어서 사용하는 문제점이 사라지고
  
  - 모든 메서드에서 traceId 를 일일이 들고 다니지 않게 된다.

- 하지만 `FieldLogTrace` 라는 싱글톤 객체의 필드값을 이용해서, 다중으로 발생하는 HTTP 요청을 관리하는 것은 **심각한 동시성 이슈**를 유발하고 있다.

### 동시성 문제

`FieldTrace`는 싱글톤 스프링 빈이기 때문에, 그 인스턴스는 애플리케이션을 통틀어 단 1개 존재한다.

그 상태에서 `traceIdHolder`라는 필드에 대해 **여러 개의 쓰레드**가 동시에 접근하면, 의도한대로 동작할 수 없게 된다.

### 동시성 예제

- 테스트코드에서 `Runnable` 인터페이스를 람다 표현식을 이용해 2개 구현한다.
  
  - 두 `Runnable`은 하나의 `Service` 객체에 접근하여, `String` 형의 `private` **필드**를 수정 및 조회하고 있다.

- 각 `Runnable`을 실행시키는 2개의 `Thread` 를 만들고, 실행시킨다.

- 테스트코드를 실행시키면, **두 개의 쓰레드가 하나의 스프링 빈에 접근하여 그 멤버 변수를 조회 및 수정함**에 따른 부정확한 동작이 발생하고 있음을 확인 가능하다.

#### 정리

결국 이러한 문제점은 **여러 쓰레드가 동시에 동일한 인스턴스의 필드 값을 변경**하면서 발생한다.

트래픽이 적은 상황에서는 확률적으로 발생하지 않는데, 트래픽이 높아지면 발생하기 시작하므로 사전에 대비하기가 극히 어렵다.

#### 참고

이러한 동시성 문제는 **지역변수**에서 발생하지 않는다.

- 지역 변수는 쓰레드마다 각기 다른 메모리 영역에 할당된다.

동시성 문제는 같은 인스턴스의 **필드** 혹은 `static` 같은 **공용 필드**에서 발생하며, 값을 읽기만 하는 것이 아닌 **변경**할 때 발생한다.

---

## ThreadLocal

쓰레드 로컬은 **해당 쓰레드만 접근할 수 있는 특별한 저장소**에 해당한다.

쓰레드 로컬을 사용하면 각 쓰레드마다 **별도의 내부 저장소**를 제공하기 때문에 **같은 인스턴스의 로컬 필드에 서로 다른 쓰레드가 접근하여도** 필드값을 안전하게 사용할 수 있다.

- 이를 통해 멀티쓰레드 상황에서도 하나의 인스턴스로 로직을 안전하게 처리할 수 있다.

자바는 언어 차원에서 쓰레드 로컬을 지원하기 위한 `java.lang.ThreadLocal` 클래스를 제공하고 있다.

### 예제 코드 요약

- 앞서 만들었던 싱글톤 서비스 객체의 공용 필드를, 단순 `String` 이 아닌 `ThreadLocal<String>` 으로 처리한다.
  
  - 이로써 서로 다른 쓰레드에서 해당 필드에 동시 접근하더라도, 쓰레드 간 경합이나 필드값 변조가 발생하지 않게 된다.

- 테스트코드에서 멀티쓰레드 환경을 재현했을 때, 해당 인스턴스의 필드값을 안전하게 수정 및 조회할 수 있음을 확인 가능하다.

---

### 로그 추적기 - 쓰레드 로컬 동기화

앞서 만든 로그 추적기에 `ThreadLocal`을 적용한다.

- `LogTrace` 인스턴스가 싱글톤으로 사용됨에 따라 `TraceId` 멤버변수를 멀티쓰레드로 접근하는 것이 문제가 되었는데,

- `TraecId`를 `ThreadLocal` 로 랩핑하여 사용하는 `ThreadLocalLogTrace` 클래스를 만들도록 한다.

### remove 처리

쓰레드 로컬의 경우, 해당 쓰레드에서 그 저장소에 대한 용건이 끝났다면 반드시 `ThreadLocal.remove()`를 호출하여 저장된 값을 제거해주어야 한다.

- 향후 메모리 누수를 방지하기 위함이며, 자세한 내용은 나중에 다룬다.

예제 코드의 경우 `release` 로직에서 level이 0임을 확인할 시, 기존에는 필드값을 `null` 로 초기화하던 것을 `remove()` 메서드 호출하는 것으로 변경하면 된다.

### 애플리케이션 적용

`LogTraceConfig` 에서 `ThreadLocalLogTrace`를 `FieldLogTrace` 대신 스프링 빈으로 등록하고, v3 컨트롤러를 호출한다.

쓰레드 로컬을 통해 `LogTrace` 의 필드값이 멀티쓰레드 환경에서 보호됨으로써, 이전과 달리 메서드 레벨링이 정확히 표시됨을 확인 가능하다.

### 주의사항

쓰레드 로컬의 값을 사용한 후 **제거하지 않고 그냥 두면** WAS에서 **쓰레드 풀을 사용하는 경우에** 심각한 문제가 발생할 수 있다.

상용 WAS는 대부분 **쓰레드 풀**을 사용하고 있는데, 이는 쓰레드 생성 및 제거 비용이 매우 크기 때문이다.

- 보통 구동 시점에 쓰레드를 여러 개 생성해서 pool 로 보관하고,

- HTTP 요청이 들어올 때마다 할당 및 반환하여 관리하고 있다.

즉, 쓰레드는 **재사용되는 환경**이다. 

쓰레드 로컬에서 사용한 값을 적절히 `remove()` 처리하지 않을 시, 그 이후의 요청에서 **언젠가는 동일한 쓰레드를 재사용**하게 되면서 **이전 요청 시의 set했던 데이터값을 다시 조회할 수 있는** 문제가 발생한다.

- 사용자 B가 사용자 A의 데이터에 접근한다는 결론


