# 스프링 AOP - 포인트컷

---

## 포인트컷 지시자

AspectJ는 포인트컷을 편리하게 표현하기 위해 고유의 **표현식**을 제공한다.

지금까지 예제에서는 `execution`으로 시작했었는데, 이와 같은 `execution`은 **포인트컷 지시자**에 해당하며, **이외에도 여러 개의 지시자가 지원**된다.

- Pointcut Designator (**PCD**)

### execution

`execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?)`

- 공식문서 상에 기재된 사용방법이다.

- `?`는 생략할 수 있고, `*` 같은 표현식 사용이 가능하다.

### within

특정 타입 내의 JoinPoint에 대한 매칭을 제한한다.

- 해당 타입이 매칭되면, 그 안의 메서드들이 자동으로 매칭된다.

- `execution` 에서 **타입 부분**만 사용한다고 보면 된다.

`execution`과 달리 부모 타입(인터페이스)과는 매칭이 안 된다.

### args

인자가 주어진 타입의 인스턴스인 JoinPoint로 매칭

- `execution` 에서 **파라미터 부분**만 사용한다고 보면 된다.

`execution`과 달리, 런타임에 실제 전달된 파라미터를 기준으로 판단한다.

- 파라미터의 **부모 타입**을 인지할 수 있다.

### @target, @within

애노테이션 기반으로 AOP 적용 여부를 판단할 수 있음

- `@target` 은 인스턴스의 모든 메서드를 JoinPoint로 적용
  
  - **부모 클래스의 메서드 포함**

- `@within`은 해당 타입 내에 있는 메서드만 JoinPoint로 적용
  
  - **부모 클래스 메서드는 제외됨**

### 주의사항

`args`, `@args`, `@target` 같은 포인트컷 지시자의 경우 **단독으로 사용하지 말고 적용 대상을 반드시 줄여줘야 한다**.

그 이유는, 위 지시자들의 경우 **실제 객체 인스턴스가 생성되고 실행될 때**, 즉 런타임에 **어드바이스 적용 여부**를 확인하게 되는데,

이러한 **런타임 포인트컷 적용 여부**도 결국 **프록시**가 있어야 판단 가능하므로, 적절한 적용 대상이 없는 상태에서는 스프링이 **모든 스프링 빈에 AOP를 적용하고자** 애플리케이션 로딩 시점에 **모든 프록시를 생성**해버린다.

자원 낭비도 문제지만, 스프링이 내부적으로 사용하는 빈 중에는 `final`로 지정된 빈들도 있기 때문에 애플리케이션 로딩부터 실패하게 된다.

### @annotation

메서드가 주어진 애노테이션을 가지고 있는 JoinPoint를 매칭함

- 실무적으로 종종 사용함

### @args

전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 JoinPoint

### bean

스프링 전용 포인트컷 지시자로, **빈의 이름**으로 지정함

### 매개변수 전달

특정 포인트컷 표현식을 사용하면, **어드바이스에 매개변수를 전달할 수 있다**.

- 자세한 사용법은 예제코드 참고

### this, target

- `this`: 스프링 빈 객체를 대상으로 하는 JoinPoint

- `target`: Target 객체를 대상으로 하는 JoinPoint

이들은 적용 타입 **하나를 정확하게 지정**해야 한다.

- `*` 같은 패턴을 사용할 수 없고, 부모 타입은 허용한다.

#### this vs target

스프링에서 AOP를 적용하면, 실제 target 객체 대신 **프록시 객체**가 스프링 빈으로 등록된다.

이 때,

- `this`는 스프링 빈으로 등록된 **프록시 객체**를 대상으로 하고

- `target`은 실제 **target 객체**를 대상으로 한다.

#### 프록시 생성 방식에 따른 차이

스프링은 프록시를 생성할 때 JDK 동적 프록시와 CGLIB 중에 선택할 수 있다. 

둘은 프록시 생성 방식이 다른데, 여기서 차이가 발생한다.

- JDK 동적 프록시 : **인터페이스가 필수**이고, 인터페이스를 구현하는 프록시 객체를 생성

- CGLIB : **구체 클래스를 상속받아** 프록시 객체를 생성

결론만 정리하면, JDK 동적 프록시 + 구체 클래스를 `this` 로 지정할 시 해당 구체 클래스에는 AOP가 걸릴 수 없다.

- JDK 동적 프록시는 인터페이스를 기반으로 만들어지기 때문에, 소스 내에 존재하고 호출되는 구체 클래스의 **존재를 알 수가 없다**.


