# 템플릿 메서드 패턴과 콜백 패턴

---

## 템플릿 메서드 패턴

### 핵심 기능 vs 부가 기능

**핵심 기능**은, 해당 객체가 제공하는 고유 기능을 말한다.

- 앞서 만든 로그 추적기 app에서 고유 기능에 해당하는 건 길어봐야 두 세 줄이다.

- 로그를 남기기 위한 코드가 훨씬 길다.

**부가 기능**은, 핵심 기능을 보조하기 위해 제공되는 기능이다.

- 로그 추적이 전형적인 부가 기능으로,

- 보통 단독으로 사용되지 않고 핵심 기능과 함께 부수적으로 사용된다.

기존 예제 코드(v3)의 경우 객체 내부에 핵심 기능과 부가 기능이 엄청 섞여 있고, 부가 기능의 분량이 훨씬 많다.

그런데 부가 기능을 호출하기 위한 패턴이 **상당히 중복적**이라는 것을 확인 가능하다.

중복 코드를 해결하는 전형적인 방법이 **메서드 추출**이지만,

- `try~catch` 블록이 존재하고, 

- 핵심 기능 호출부가 중간에 껴있기 때문에

- 단순히 메서드를 추출하기는 어렵다.

### 변하는 것과 변하지 않는 것을 분리

설계의 핵심은, **변하는 것과 변하지 않는 것을 철저히 분리**하는 것이다.

핵심 기능은 보통 변화하지만, 부가 기능은 거의 변화하지 않는다.

그 둘을 **분리하여 모듈화**해야 하고,

**템플릿 메서드 패턴**은 이런 문제를 해결하는 디자인 패턴이다.

---

## 템플릿 메서드 패턴 - 적용

### 주의

추상클래스, 추상메서드, 다형성, 제네릭 등 자바 기본에 대한 숙달이 되어 있어야 함

### 예제 코드 요약

- 기존 코드에서 **템플릿**으로 추출할 수 있는 부분을 `AbstractTemplate<T>` 추상클래스로 분리한다.

- 해당 클래스에서는 부가기능 공통로직을 `public` 메서드로 가지고 있으며, 그 내부에 **비즈니스 로직** 부분을 **추상 메서드**로 처리하여 구현체의 구현을 **강제**하고 있다.
  
  - 추상클래스는 이를 상속받는 구현체가 **어떤 역할을 할 것이라고 강제하는 효과**를 가진다.

- 애플리케이션 코드에서는 해당 템플릿을 가져다가 **비즈니스 로직** 부분을 **오버라이드**해두고 사용하면 된다.
  
  - 구현 클래스를 따로 생성하는 방법도 있지만,
  
  - 클래스를 굳이 생성하지 않고 **익명 내부 클래스**로 처리하는 쪽이 보다 바람직하다.

### 좋은 설계란?

좋은 설계는 **변경**이 발생할 때 자연스럽게 드러난다.

템플릿 메서드 패턴을 적용하여 개선한 코드는 **로그를 남기는 부가기능 로직을 변경하고자 할 때** 애플리케이션 비즈니스 로직 (핵심 기능) 쪽을 변경할 **필요가 없다**.

#### 단일 책임 원칙 (SRP)

결과적으로 템플릿 메서드 패턴을 적용함으로써 **로그를 남기는 부분에 대해 SRP를 지키게 된 것**

변경 지점을 하나로 모아서, **변경에 쉽게 대처할 수 있는 구조**를 만들었다.

---

## 템플릿 메서드 패턴 - 정의

`GOF 디자인 패턴` 의 정의는 아래와 같다.

- 템플릿 메서드 디자인 패턴의 목적은, 작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기한다.

- 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있다.

해석하면,

- **부모 클래스**가 알고리즘의 **골격**인 **템플릿**을 정의

- 일부 변경되는 로직은 **자식 클래스**에서 **오버라이딩**으로 정의

- **상속과 오버라이딩을 통한 다형성**을 이용한 문제 해결

### 단점

템플릿 메서드 패턴은 **상속**을 사용하기 때문에, 상속이 가지는 단점들을 그대로 안고 간다.

- 자식 클래스가 부모 클래스의 기능을 실질적으로 전혀 사용하지 않지만, 컴파일 시점부터 양 클래스는 **강하게 결합**된다.

- 이런 의존관계는 부모 클래스 수정 시의 영향도를 아주 높게 만든다.

별개로 상속 구조를 사용하는 과정에서 별도 클래스를 생성하거나 익명 내부 클래스를 만들어내는 부분도 다소 지저분하다.

이러한 단점을 제거할 수 있는 디자인 패턴이 **전략 패턴**

---

## 전략 패턴

전략 패턴에서는 변하지 않는 부분을 `Context` 라는 개념으로 두고, 변하는 부분을 `Strategy` 인터페이스에 두어 자유롭게 구현하도록 하며, 최종적으로 `Context`가 `Strategy` 를 주입받아 사용하도록 한다.

- 상속이 아니라 **위임**으로 문제를 해결한다.

### 정의

GOF 디자인 패턴에서 정의한 의도는 아래와 같다.

- 알고리즘 제품군을 정의하고 **각각의 캡슐화하여 상호 교환 가능**하게 만든다.

- 전략을 사용하면, 알고리즘을 사용하는 클라이언트와 **독립적으로 알고리즘을 변경할 수 있다.**

### 예제 코드 요약

- 로깅을 처리하는 `ContextV1` 객체는 `Strategy` 를 주입받아서, 부가기능 처리 메서드에서 사용한다.

- 개발자는 `ContextV1` 객체가 **생성되는 시점**에 `Strategy` 인터페이스의 **적절한 구현체**를 가져다가 주입시켜줌으로써,

- `ContextV1` 이 변경되는 것과 `Strategy` 구현체가 변경되는 것 간의 영향도를 제거할 수 있다.

- `Strategy`는 인터페이스이므로, 그 구현체에 대해서도 결합도가 약하다.

### 정리

결과적으로 **컨텍스트**, 거대한 문맥은 크게 변하지 않지만 그 속에서 `Strategy`를 통해 **일부 전략만 변경**된다는 개념.

**스프링에서 의존관계 주입에 사용하는 패턴이** 다름 아닌 전략 패턴이다.

### 개선

- 템플릿 매서드 패턴 때와 마찬가지로 **익명 내부 클래스**를 사용하는 방식으로 코드를 개선할 수 있으며,

- 더 나아가 별도의 변수로 구현체를 받지 않고 `Context` 생성 시에 익명 내부 클래스를 집어넣는 방식도 가능하다.

- 가장 깔끔한 방법은, 해당 인터페이스가 **1개의 메서드만을 가지고 있기 때문에** **람다로 사용이 가능**하여, 람다로 처리하는 것.

### 선 조립, 후 실행

`Context`의 내부 필드에 `Strategy`를 두고 사용하는 부분이 중요하다.

정확히 말했을 때, `Context`는 **실행되기 전에 원하는 모양으로 조립되어 있다**.

한 번 조립된 후에는 `Context`를 실행시키면 된다. 스프링에서 애플리케이션 로딩 시 의존관계 주입을 통해 필요한 의존관계를 모두 맺어두고 요청을 처리하는 것과 동일한 원리다.

단점으로는 **조립 이후에 전략을 변경하기가 번거롭다는 점**.

- 특히 `Context`를 싱글톤으로 사용할 시 **동시성 이슈** 등 고려할 점이 많다.

- `setter`를 사용하는 방법이 있기는 한데, 이 또한 위험하다.

먼저 조립하고 사용하는 방식보다도 **유연하게** 전략 패턴을 사용할 필요가 있다.

### 보다 유연한 전략 패턴

`Context` 내부 필드에 `Strategy`를 둠으로써 `Context` 생성과 함께 `Strategy`를 조립해버리는 것이 아니라,

`Context`를 실행하는 시점에 `Strategy`를 **파라미터로 전달**하는 방식이다.

- `Context` 객체가 싱글톤이더라도 원하는 `Strategy`를 자유롭게 실행할 수 있다.

- 람다를 사용해서 최종적으로 코드를 짜고 나면,
  
  - 마치 `Context` 가 실행할 **코드 조각**을 파라미터로 전달해주는 모양새가 된다.

#### 정리

`Context`에 파라미터로 `Strategy`를 전달받으면, **실행할 때마다 전략을 유연하게 변경할 수 있다**.

- 단점은, 실행할 때마다 전략을 계속 지정해줘야한다는 것

- 상황에 맞게 사용해야 한다.

### 템플릿

지금까지 해결한 문제는 결국 **변하는 부분과 변하지 않는 부분을 분리하는 것**이다.

- 변하지 않는 템플릿을 만들고, 변하는 부분에 대해 **실행시킬 코드 조각을 넘겨서 실행시키는** 개념

이를 달성하는 방식이 크게 두 가지라고 할 수 있고, 그 중에 적절한 것을 상황에 맞게 사용해야 한다.

- 템플릿이 실행시킬 전략이 쉽게 변경되지 않는, 마치 **스프링 빈 의존관계 같은** 상태라면 필드에서 전략을 주입하는 것이 바람직하다.

- 템플릿이 실행시킬 전략이 클라이언트 요청에 따라 계속 변화한다면, 파라미터로 전략을 주입하는 것이 바람직하다.

---

## 템플릿 콜백 패턴

위의 `Strategy` 같이 **다른 코드의 인수로 넘겨져 실행 가능한 코드**를 **콜백**(callback) 이라고 한다.

### 콜백의 정의

콜백은 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.

콜백을 넘겨받는 코드는 필요에 따라 이를 즉시 실행할 수도 있고, 나중에 실행할 수도 있다.

#### 자바 언어에서의 콜백

자바에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하지만, 8버전부터는 람다를 사용할 수 있다.

### 템플릿 콜백 패턴

스프링에서는 위의 `ContextV2`와 같은 방식의 **전략 패턴**을 템플릿 콜백 패턴이라고 한다.

- GOF 패턴의 한 종류는 아닌다. 스프링 안에서만 이렇게 부르며, **전략 패턴**이지만 **템플릿과 콜백 부분이 강조된** 패턴이다.

- 스프링에서 이름에 `XxxTemplate` 같은 형태라면 템플릿 콜백 패턴으로 만들어진 인터페이스라고 생각하면 된다.

예제 코드는, 앞서 ContextV2 에서

- `Context` 가 `Template`로,

- `Strategy`가 `Callback` 으로 전환된 성격이다.


