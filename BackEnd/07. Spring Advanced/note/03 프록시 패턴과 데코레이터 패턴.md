# 프록시 패턴과 데코레이터 패턴

---

## 예제 세팅

### V1

인터페이스와 그 구현 클래스로 간단한 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컨트롤러를 인터페이스로 처리하고자 하는 경우, `@RequestMapping` 을 인터페이스 레벨에 달아줘야 **스프링 컨트롤러**로 인식될 수 있다.

- 마찬가지로 `@ResponseBody`를 인터페이스 레벨에 달아줘야 **HTTP 메시지 컨버터**를 사용하여 응답이 나갈 수 있다.

- 스프링 빈 수동 등록은 `@Configuration` 클래스를 사용하여 `@Bean` 메서드를 직접 넣는 방법으로 진행한다.
  
  - 다만 `@Configuration` 클래스의 경우 달리 신경쓰지 않는다면 자동으로 **컴포넌트 스캔**의 대상이 된다.
    
    - 정확히는, `@SpringBootApplication` 애노테이션이 해당 main 클래스를 포함한 하위 패키지를 전부 컴포넌트 스캔하도록 되어 있다.
  
  - 이에 대해 `scanBasePackages` 옵션을 사용해서 컴포넌트 스캔의 범위를 한정할 수 있다.
  
  - 의도적으로 `config` 패키지를 제외한 뒤, `Import(AppV1Config.class)` 하는 방식으로 컨피그 파일을 수동 주입할 수 있다.

### V2

인터페이스가 없는 구체 클래스로 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컴포넌트 스캔의 범위가 되지 않기 위해, `@Controller` 나 `@Service` 같은 애노테이션을 사용하지 않는다.

- `@Import({AppV1Config.class, AppV2Config.class})` 같은 방식으로 여러 개의 클래스를 수동으로 주입할 수 있다.

### V3

컴포넌트 스캔을 이용해 스프링 빈을 자동 주입한다.

- App 코드는 모두 동일하다.

- 다만 `@Component` 애노테이션을 사용하고, `AppConfig` 클래스를 등록하지 않는다.

---

## 프록시, 프록시 패턴, 데코레이터 패턴

### 프록시


