# 프록시 패턴과 데코레이터 패턴

---

## 예제 세팅

### V1

인터페이스와 그 구현 클래스로 간단한 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컨트롤러를 인터페이스로 처리하고자 하는 경우, `@RequestMapping` 을 인터페이스 레벨에 달아줘야 **스프링 컨트롤러**로 인식될 수 있다.

- 마찬가지로 `@ResponseBody`를 인터페이스 레벨에 달아줘야 **HTTP 메시지 컨버터**를 사용하여 응답이 나갈 수 있다.

- 스프링 빈 수동 등록은 `@Configuration` 클래스를 사용하여 `@Bean` 메서드를 직접 넣는 방법으로 진행한다.
  
  - 다만 `@Configuration` 클래스의 경우 달리 신경쓰지 않는다면 자동으로 **컴포넌트 스캔**의 대상이 된다.
    
    - 정확히는, `@SpringBootApplication` 애노테이션이 해당 main 클래스를 포함한 하위 패키지를 전부 컴포넌트 스캔하도록 되어 있다.
  
  - 이에 대해 `scanBasePackages` 옵션을 사용해서 컴포넌트 스캔의 범위를 한정할 수 있다.
  
  - 의도적으로 `config` 패키지를 제외한 뒤, `Import(AppV1Config.class)` 하는 방식으로 컨피그 파일을 수동 주입할 수 있다.

### V2

인터페이스가 없는 구체 클래스로 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컴포넌트 스캔의 범위가 되지 않기 위해, `@Controller` 나 `@Service` 같은 애노테이션을 사용하지 않는다.

- `@Import({AppV1Config.class, AppV2Config.class})` 같은 방식으로 여러 개의 클래스를 수동으로 주입할 수 있다.

### V3

컴포넌트 스캔을 이용해 스프링 빈을 자동 주입한다.

- App 코드는 모두 동일하다.

- 다만 `@Component` 애노테이션을 사용하고, `AppConfig` 클래스를 등록하지 않는다.

---

## 프록시, 프록시 패턴, 데코레이터 패턴

### 프록시

#### 직접 호출과 간접 호출

클라이언트와 서버의 개념으로 프록시를 설명할 수 있다.

일반적으로 클라이언트는 서버를 **직접** 호출하고 처리 결과를 직접 받는데,

어떤 **대리자**를 통해서 **간접적으로** 서버에 요청을 할 수도 있다.

이 때의 대리자를 **프록시**라고 한다.

- 간접 호출로 구현할 시, **프록시**는 중간에서 여러 가지 일을 할 수가 있어서 장점을 가진다.

- 접근 제어, 캐싱, 부가 기능 등

- 프록시를 여러 개 걸어줄 수도 있고, 이러한 구조를 **프록시 체인**이라고 한다.

#### 대체 기능

어떤 객체가 프록시가 되려면, 해당 프록시는 **클라이언트의 입장에서 봤을 때 서버와 완전히 동일한 인터페이스를 제공**해줘야 한다.

- 클라이언트가 지금 서버를 호출하는 건지, 프록시를 호출하는 건지 몰라야 한다.

코딩 레벨에서는, 프록시와 서버가 **같은 인터페이스**에 의존하도록 하면 된다. 이로써 클라이언트 측에 **DI**를 이용하여 대체가 가능하다.

- 클라이언트 코드 변경이 없다는 점이 중요

#### 프록시의 주요 기능

- 접근 제어
  
  - 권한에 따른 접근 차단
  
  - 캐싱
  
  - 지연 로딩

- 부가 기능 추가
  
  - 실제 서버가 제공하는 기능에 더하여 부가 기능을 수행함

#### GOF 디자인 패턴

GOF 디자인 패턴에서는 프록시를 사용하는 **의도**에 따라 **프록시 패턴**과 **데코레이터 패턴**을 구분한다.

- 프록시 패턴 : **접근 제어**가 목적

- 데코레이터 패턴 : **부가 기능 추가**가 목적

#### 참고

프록시라는 개념은 클라이언트와 서버라는 큰 개념 안에서 자연스럽게 발생할 수 있다.

객체 레벨 뿐만 아니라 서버 수준에서도 프록시가 존재할 수 있다.

### 프록시 패턴

서버 인터페이스를 구현하는 프록시 객체를 만들고, 클라이언트 측 의존관계를 서버에서 프록시로 전환하는 방법을 사용한다.

- 핵심은 실제 서버 코드와 클라이언트 코드를 **전혀 변경하지 않고** 프록시를 도입하여, **접근 제어**를 달성한다.

#### 예제 코드 요약

- 특정 인터페이스를 구현하는 서버 클래스를 만들고,

- 동일 인터페이스를 구현하는 프록시 클래스를 만든다.
  
  - 프록시 클래스는 **또 서버 클래스에 의존하여** **캐싱** 전략을 도입하고 있다.

- 클라이언트는 기본적으로 인터페이스에 의존하고 있는데, **구현체를 갈아끼우는 것**만으로 **캐싱** 전략을 넣거나 뺄 수 있다.
  
  - 캐싱 또한 **실제 서버에 접근하는 것을 사전에 차단**한다는 점에서 봤을 때 **접근 제어**의 일종이다.

### 데코레이터 패턴

프록시 패턴과 코드 수준에서는 사실상 동일하다.

다만, **목적**이 **부가 기능 추가**라는 점에서 다르다.

- 요청 값이나 응답 값을 중간에 변형하거나

- 실행 시간을 측정하여 추가 로그를 남기는 동작

#### 예제 코드 요약

- 코드 자체는 프록시 패턴과 거의 동일하다.

- 하지만 **데코레이터**라는 목적에 맞게, **서로 다른 여러 개의 부가기능**을 각각 별개의 프록시로 만들어서 적절한 의존관계를 부여하면

- **프록시 체인**의 형태로 클라이언트에게 갖가지 부가 기능을 제공할 수 있게 된다.

### 정리

프록시 패턴과 데코레이터 패턴은 모양만 따졌을 때 거의 동일하다.

둘을 구분하는 건 **의도**다.

- 프록시 패턴은 다른 객쳋에 대한 **접근을 제어**하기 위함이고

- 데코레이터 패턴은 **객체에 추가적인 책임을 동적으로 추가**하기 위함이다.

---

## 인터페이스 기반 프록시

V1 예제를 기반으로 작업한다.

- MVC App을 구성하는 인터페이스를 구현하여, **프록시 객체**를 별도로 생성한다.

- 프록시 객체에서 `LogTrace` 를 주입받아서 원하는 부가 기능인 **로깅**을 처리하고, 내부적으로 **실제 서비스 객체**를 호출한다.

- 별도의 `@Configuration` 클래스를 생성하고, 의존관계를 준수하여 프록시 객체들을 생성한다.
  
  - 핵심은, **인터페이스**에 대한 **스프링 빈**이 등록될 때 **실제 구현체**가 아닌 **프록시 객체**를 등록하는 것.
  
  - **스프링 빈**으로는 프록시 객체가 등록되고, **실제 구현체**는 단순히 프록시 객체가 참조하는 구조로써 **힙 메모리**에만 등재된다.

- 이 상태로 애플리케이션을 작동시키면, **실제 구현체**의 비즈니스 로직을 전혀 손대지 않은 상태에서 **부가 기능**인 로깅을 처리할 수 있다.

### 단점

**프록시 클래스를 일일이 생성해야 한다.** 너무 많은 프록시 클래스가 만들어진다.

**인터페이스가 없는 구체 클래스**에 대해서도 프록시를 적용하는 방법을 찾을 필요가 있다.

---

## 구체 클래스 기반 프록시

### 클래스 기반 프록시 도입

자바 다형성은 인터페이스를 구현하든, **클래스를 상속하든** 상위 타입만 맞으면 적용 가능하다.

즉, 인터페이스가 없어도 프록시를 만들 수 있다.

### 예제 코드 요약

- 구체 클래스에서 로직을 구현하고, 해당 클래스를 다른 클라이언트가 의존하는 구조를 짠다.

- 구체 클래스를 **상속**받는 **프록시 객체**를 따로 구현하고, 클라이언트가 부모 대신 **프록시 객체**에 의존하도록 한다.

- 결과적으로 프록시 호출이 원만하게 이루어진다.

**자바에서 다형성은 인터페이스나 클래스를 구분하지 않고 적용되기 때문에** 가능하다.

### 애플리케이션 적용

V2 코드를 기준으로 작업한다.

- 구체 클래스를 하나씩 상속받아서 프록시 객체로 생성한다.
  
  - 상속받는 과정에서, 부모 클래스 생성자를 `super()` 로 호출하는 부분이 다소 불편하다.
  
  - 인터페이스로 작업할 시 신경쓰지 않아도 될 부분

- 그 외 대부분은 인터페이스 기반 작업할 때와 거의 동일하다.

---

## 인터페이스 기반 프록시와 클래스 기반 프록시

### 프록시

원본 코드를 전혀 변경하지 않고도 애플리케이션에 부가기능을 적용할 수 있다.

- 예제 기준, `LogTrace` 기능

### 비교

- 인터페이스가 없어도, 클래스 기반으로도 프록시 생성이 가능하다.

- 하지만,
  
  - 클래스 기반 프록시는 해당 클래스에만 적용 가능하다. 인터페이스 기반 프록시는 인터페이스가 같으면 모든 곳에 적용 가능하다.
  
  - 클래스 기반 프록시는 상속이 필요하여 몇 가지 제약이 발생한다.
    
    - 부모 클래스의 생성자를 호출해야 함
    
    - 클래스에 final 키워드가 붙을 시 상속 불가
    
    - 메서드에 final 키워드가 붙을 시 오버라이딩 불가

결과적으로 인터페이스 기반 프록시가 설계적으로나 코딩하는 관점에서 좋다.

단점이라고 한다면 **인터페이스가 필요하다는 점 그 자체**

#### 그렇다고 인터페이스가 항상 필요한가?

이론적으로 모든 객체에 인터페이스를 도입하여, **역할과 구현을 분리**하는 것이 좋기는 하다.

하지만 실질적으로 **구현을 거의 변경할 일 없는** 클래스들이 있는데, 이런 곳에 인터페이스를 도입하는 것은 번거롭기만 하고 실용적이지 않다.

인터페이스가 항상 필요하지는 않다는 뜻.

### 결론

실무적으로 프록시를 사용할 때는 인터페이스와 구체 클래스가 혼재한다. 두 상황을 모두 대응할 수 있어야 한다.

### 문제점 : 너무 많은 프록시 클래스

결과적으로 예제코드를 확인해보면, 프록시 클래스가 **너무 많이 만들어진다**.

- 심지어 각 프록시 클래스의 기능은 모두 동일하다.

프록시 클래스를 하나만 만들어서 모든 곳에 적용하는 방법은 없는가?

- **동적 프록시 기술**을 사용한다.


