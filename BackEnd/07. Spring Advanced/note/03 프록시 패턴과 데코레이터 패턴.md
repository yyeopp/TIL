# 프록시 패턴과 데코레이터 패턴

---

## 예제 세팅

### V1

인터페이스와 그 구현 클래스로 간단한 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컨트롤러를 인터페이스로 처리하고자 하는 경우, `@RequestMapping` 을 인터페이스 레벨에 달아줘야 **스프링 컨트롤러**로 인식될 수 있다.

- 마찬가지로 `@ResponseBody`를 인터페이스 레벨에 달아줘야 **HTTP 메시지 컨버터**를 사용하여 응답이 나갈 수 있다.

- 스프링 빈 수동 등록은 `@Configuration` 클래스를 사용하여 `@Bean` 메서드를 직접 넣는 방법으로 진행한다.
  
  - 다만 `@Configuration` 클래스의 경우 달리 신경쓰지 않는다면 자동으로 **컴포넌트 스캔**의 대상이 된다.
    
    - 정확히는, `@SpringBootApplication` 애노테이션이 해당 main 클래스를 포함한 하위 패키지를 전부 컴포넌트 스캔하도록 되어 있다.
  
  - 이에 대해 `scanBasePackages` 옵션을 사용해서 컴포넌트 스캔의 범위를 한정할 수 있다.
  
  - 의도적으로 `config` 패키지를 제외한 뒤, `Import(AppV1Config.class)` 하는 방식으로 컨피그 파일을 수동 주입할 수 있다.

### V2

인터페이스가 없는 구체 클래스로 MVC App을 만들고, 스프링 빈은 수동 등록한다.

- 컴포넌트 스캔의 범위가 되지 않기 위해, `@Controller` 나 `@Service` 같은 애노테이션을 사용하지 않는다.

- `@Import({AppV1Config.class, AppV2Config.class})` 같은 방식으로 여러 개의 클래스를 수동으로 주입할 수 있다.

### V3

컴포넌트 스캔을 이용해 스프링 빈을 자동 주입한다.

- App 코드는 모두 동일하다.

- 다만 `@Component` 애노테이션을 사용하고, `AppConfig` 클래스를 등록하지 않는다.

---

## 프록시, 프록시 패턴, 데코레이터 패턴

### 프록시

#### 직접 호출과 간접 호출

클라이언트와 서버의 개념으로 프록시를 설명할 수 있다.

일반적으로 클라이언트는 서버를 **직접** 호출하고 처리 결과를 직접 받는데,

어떤 **대리자**를 통해서 **간접적으로** 서버에 요청을 할 수도 있다.

이 때의 대리자를 **프록시**라고 한다.

- 간접 호출로 구현할 시, **프록시**는 중간에서 여러 가지 일을 할 수가 있어서 장점을 가진다.

- 접근 제어, 캐싱, 부가 기능 등

- 프록시를 여러 개 걸어줄 수도 있고, 이러한 구조를 **프록시 체인**이라고 한다.

#### 대체 기능

어떤 객체가 프록시가 되려면, 해당 프록시는 **클라이언트의 입장에서 봤을 때 서버와 완전히 동일한 인터페이스를 제공**해줘야 한다.

- 클라이언트가 지금 서버를 호출하는 건지, 프록시를 호출하는 건지 몰라야 한다.

코딩 레벨에서는, 프록시와 서버가 **같은 인터페이스**에 의존하도록 하면 된다. 이로써 클라이언트 측에 **DI**를 이용하여 대체가 가능하다.

- 클라이언트 코드 변경이 없다는 점이 중요

#### 프록시의 주요 기능

- 접근 제어
  
  - 권한에 따른 접근 차단
  
  - 캐싱
  
  - 지연 로딩

- 부가 기능 추가
  
  - 실제 서버가 제공하는 기능에 더하여 부가 기능을 수행함

#### GOF 디자인 패턴

GOF 디자인 패턴에서는 프록시를 사용하는 **의도**에 따라 **프록시 패턴**과 **데코레이터 패턴**을 구분한다.

- 프록시 패턴 : **접근 제어**가 목적

- 데코레이터 패턴 : **부가 기능 추가**가 목적

#### 참고

프록시라는 개념은 클라이언트와 서버라는 큰 개념 안에서 자연스럽게 발생할 수 있다.

객체 레벨 뿐만 아니라 서버 수준에서도 프록시가 존재할 수 있다.

### 프록시 패턴

서버 인터페이스를 구현하는 프록시 객체를 만들고, 클라이언트 측 의존관계를 서버에서 프록시로 전환하는 방법을 사용한다.

- 핵심은 실제 서버 코드와 클라이언트 코드를 **전혀 변경하지 않고** 프록시를 도입하여, **접근 제어**를 달성한다.

#### 예제 코드 요약

- 특정 인터페이스를 구현하는 서버 클래스를 만들고,

- 동일 인터페이스를 구현하는 프록시 클래스를 만든다.
  
  - 프록시 클래스는 **또 서버 클래스에 의존하여** **캐싱** 전략을 도입하고 있다.

- 클라이언트는 기본적으로 인터페이스에 의존하고 있는데, **구현체를 갈아끼우는 것**만으로 **캐싱** 전략을 넣거나 뺄 수 있다.
  
  - 캐싱 또한 **실제 서버에 접근하는 것을 사전에 차단**한다는 점에서 봤을 때 **접근 제어**의 일종이다.

### 데코레이터 패턴

프록시 패턴과 코드 수준에서는 사실상 동일하다.

다만, **목적**이 **부가 기능 추가**라는 점에서 다르다.

- 요청 값이나 응답 값을 중간에 변형하거나

- 실행 시간을 측정하여 추가 로그를 남기는 동작

#### 예제 코드 요약

- 코드 자체는 프록시 패턴과 거의 동일하다.

- 하지만 **데코레이터**라는 목적에 맞게, **서로 다른 여러 개의 부가기능**을 각각 별개의 프록시로 만들어서 적절한 의존관계를 부여하면

- **프록시 체인**의 형태로 클라이언트에게 갖가지 부가 기능을 제공할 수 있게 된다.

### 정리

프록시 패턴과 데코레이터 패턴은 모양만 따졌을 때 거의 동일하다.

둘을 구분하는 건 **의도**다.

- 프록시 패턴은 다른 객쳋에 대한 **접근을 제어**하기 위함이고

- 데코레이터 패턴은 **객체에 추가적인 책임을 동적으로 추가**하기 위함이다.

---

## 인터페이스 기반 프록시

V1 예제를 기반으로 작업한다.

- MVC App을 구성하는 인터페이스를 구현하여, **프록시 객체**를 별도로 생성한다.

- 프록시 객체에서 `LogTrace` 를 주입받아서 원하는 부가 기능인 **로깅**을 처리하고, 내부적으로 **실제 서비스 객체**를 호출한다.

- 별도의 `@Configuration` 클래스를 생성하고, 의존관계를 준수하여 프록시 객체들을 생성한다.
  
  - 핵심은, **인터페이스**에 대한 **스프링 빈**이 등록될 때 **실제 구현체**가 아닌 **프록시 객체**를 등록하는 것.
  
  - **스프링 빈**으로는 프록시 객체가 등록되고, **실제 구현체**는 단순히 프록시 객체가 참조하는 구조로써 **힙 메모리**에만 등재된다.

- 이 상태로 애플리케이션을 작동시키면, **실제 구현체**의 비즈니스 로직을 전혀 손대지 않은 상태에서 **부가 기능**인 로깅을 처리할 수 있다.

### 단점

프록시 클래스를 일일이 생성해야 한다. 너무 많은 프록시 클래스가 만들어진다.

인터페이스가 없는 구체 클래스에 대해서도 프록시를 적용하는 방법을 찾을 필요가 있다.

---

## 구체 클래스 기반 프록시


