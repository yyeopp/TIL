# 검증 - Validation

---

## 검증 개요

**컨트롤러**의 중요한 역할 중 하나가 **HTTP 요청이 정상인지 여부를 검증하는 것**이다.

### 클라이언트 검증과 서버 검증

**클라이언트 검증**은 고객 사용성이 우수하나, **조작 가능**하므로 보안에 취약하다.

**서버 검증**은 보안이 우수하나, 고객 사용성이 부족해진다.

둘을 적절히 **섞어서 사용**하는 것이 필요하고, **최종적인 서버 검증은 필수**다.

특히 API 방식을 사용할 시, API 스펙 수준에서 **검증 오류를 API 응답 결과에 잘 남겨주는 것**이 중요하다.

---

## 검증 직접 처리

### 예제 코드 요약

- 서버 API에서 다중 if 문으로, **validation을 처리하는 비즈니스 로직**을 개발한다.
  
  - 개별 field에 대한 validation 처리와,
    
    - 타입 검증, 자릿수 검증 등
  
  - 전체 Object에 대한 validation 처리를 의도적으로 구분한다.
    
    - 필드 여러 개 값에 대한 `&&` 연산 

- validation 오류가 존재할 시, `errors` 라는 `Model` 에 `Map` 형태로 담아서 화면으로 리턴한다.
  
  - `errors` 에 대해서는 template에서 받아서 적절하게 표시할 수 있도록 처리

- 오류가 발생할 시 리턴되는`View` 는 **기존 화면을 유지**하도록 함

- 결과적으로, 기존 화면에서 입력 오류가 존재하면, 
  
  - 화면이 이동하지 않는 동시에 
  
  - 발생한 validation 오류들이 화면에 표시된다.
  
  - 클라이언트가 입력한 데이터도 그대로 유지시킨다.

### 문제점

- 뷰 탬플릿 상의 중복이 많음

- **타입 오류**에 대한 처리가 되어있지 않음
  
  - 타입 오류가 발생할 시 **객체 파싱 수준**에서 오류가 발생하면서, 아예 오류 페이지를 띄워버린다.
  
  - 오류 페이지를 띄우지 않았다고 해도, **클라이언트가 입력한 잘못된 값을 화면상에 유지해줄 방법**이 없다.
  
  - 클라이언트가 입력한 값도 어딘가에 별도 관리가 필요하다는 뜻

무엇보다도, 이러한 validation 처리는 모든 애플리케이션에서 다루는 주제이기 때문에, **스프링 수준에서 공통화**가 이루어져있다.

---

## BindingResult

### BindingResult 인터페이스 도입

스프링이 제공하는 `BindingResult` 인터페이스를 적용하여 기존 방식을 개선할 수 있다.

- `Map` 형태로 저장했던 `errors` 가 `BindingResult` 인터페이스로 바뀐다.

- 메서드에서 `BindingResult` 파라미터는 `@ModelAttribute` 파라미터 바로 뒤에 붙어야 한다.

- `addError()` 메서드로 validation 결과를 저장할 수 있다.
  
  - 개별 field에 대한 오류는 `new FieldError()`
  
  - Object 전반에 대한 오류는 `new ObjectError()`
  
  - 파라미터로 필드명, `Model` 명, 기본 메시지 등을 함께 넣어서 만들어야 한다.

- `hasErrors()` 메서드로 validation 통과 여부를 체크하면 되고,

- 별도로 `Model` 을 명시하지 않더라도 `BindingResult`는 자동으로 뷰에 리턴된다.

### @ModelAttribute 파싱 오류 대응

기존 방식에서는, `@ModelAttribute` 객체 파싱을 실패할 시 아예 오류페이지가 리턴된다.

- 400 오류 발생, 오류 페이지 이동

`BindingResult` 를 함께 명시하는 경우, 객체 파싱에 실패하더라도 **컨트롤러를 정상적으로 호출할 수 있다.**

- **파싱 과정에서 어떤 문제가 발생했는지**를, **문제가 발생한 필드에 대한** `FieldError` 로 자동 생성하여

- `BindingResult` 에 `addError()` 처리하고 돌려준다.

`BindingResult` 를 특정 `@ModelAttribute` 바로 뒤에 선언해야 위와 같은 제대로 매핑이 이루어지는 것을 확인 가능하다.

### 문제점

validation 오류가 발생했을 때, 여전히 **클라이언트 입력값을 유지**시켜주는 부분이 누락되어있다.

---

## FieldError, ObjectError

클라이언트가 입력한 값을 validation 오류에도 불구하고 화면상 보존하기 위해, `FieldError` 생성자를 다르게 사용한다.

- 핵심은 `rejectedValue` 를 파라미터로 사용하고,

- 기존 input 값을 `getter` 해와서 파라미터로 입력하는 것.
  
  - 엄밀히 따졌을 때, `@ModelAttribute` 로 입력되는 input 객체는 생성 자체가 되지 않았으므로, 여기서 getter 처리하는 것은 **의미가 없다.**
  
  - 또한 메서드에서 직접 `FieldError` 를 생성하는 것은, **스프링이 이미 객체 파싱 단계에서 생성한 FieldError에 우선순위가 밀려있기 때문에** 별다른 의미가 없다.
  
  - 객체 파싱 오류가 발생한 순간에 이미, 스프링에서 `FieldError`를 새로 생성하고 `rejectedValue` 값도 입력해둔다.
  
  - **화면에서 리턴받는 `BindingResult`에는 스프링이 자동생성한 `FieldError` 가 들어있으며**, 그에 따라 `rejectedValue`도 클라이언트 입력값으로 그대로 보존할 수 있다.

- 그 외에도 `bindingFailure` 파라미터를 `false` 로 설정해준다.
  
  - binding 자체가 실패한 것은 아니고, 데이터타입이 맞지 않은 케이스이기 때문

---

## 오류 코드와 메시지 처리


