# 로그인 처리 - 필터, 인터셉터

---

## 서블릿 필터 - 소개

프로그램 설계 의도상 특정 페이지는 로그인한 사용자만 들어갈 수 있어야 하는데, 별다른 처리를 하지 않았다면 로그인하지 않았어도 **URL을 직접 입력했을 때** 모든 화면에 진입할 수 있다.

이걸 차단하기 위한 가장 단순한 방법은, **컨트롤러 모든 메서드에 로그인 여부 체크 로직을 넣는 것**.

- 아주 비효율적인 코딩 방식일 수밖에 없다.

- 이런 **공통 관심사**는 AOP로 처리하는 게 나은데, 특히 해당 로직은 **서블릿 필터** 또는 **스프링 인터셉터**에서 잘 처리할 수 있다.

### 서블릿 필터

#### 필터 흐름

HTTP 요청이 진입하면, WAS는 **필터**를 먼저 거친 뒤에 서블릿을 호출하고 컨트롤러로 진입시킨다.

즉, 필터에 적용된 로직은 **모든 HTTP 요청**에 공통적으로 적용될 수 있다.

필터에서 **제한 조건**을 설정해주면, 아예 서블릿을 호출하지 않고  HTTP 응답을 반환해줄 수 있다.

#### 필터 체인

필터는 **체인**으로 구성되기 때문에, 여러 개의 필터를 자유롭게 추가할 수 있다.

#### 필터 인터페이스

필터 인터페이스를 **직접** 구현하고 등록할 수도 있다. 그러면 서블릿 컨테이너가 필터를 **싱글톤 객체**로 생성하고 관리해 준다.

- `init()` : 필터 초기화 메서드. 서블릿 컨테이너 생성 시 호출

- `doFilter()` : 고객 요청이 올 때마다 호출

- `destroy()` : 필터 종료 메서드. 서블릿 컨테이너 종료 시 호출

---

## 서블릿 필터 - 요청 로그

모든 요청을 다 로그로 남기는 필터를 직접 개발하고 적용해본다.

- `Filter`라는 클래스를 구현하면 **서블릿 필터**를 만들 수 있다.

- 제작한 필터를 적용하려면, 별도의 `@Configuration` 클래스에서 Bean으로 등록해줘야 한다.
  
  - `FilterRegistrationBean` 을 사용해서 등록
  
  - `setOrder()` 를 사용해서 필터 간 우선순위도 적용 가능
  
  - `addUrlPattern` 하여, 특정 URL 패턴에 대해서만 필터를 적용하는 처리도 가능함

- `doFilter()` 메서드를 구현하면 로깅 등의 처리가 가능하고, `chain.doFilter()` 로 다음 필터를 호출해줘야 **체인 구조**를 활용할 수 있다.
  
  - 다음 필터가 없으면 서블릿이 호출되는 것.
  
  - 만약 호출을 안 하면, 그냥 다음 단계 진행 자체가 안 된다.

- 실무적으로 각 요청에 대한 GID를 처리하고 로그로 남기고 싶다면, `logback mdc` 라는 것을 사용하면 된다.

---

## 서블릿 필터 - 인증 체크

### 예제 코드 요약

- `ServletRequest`와 `Response` 객체를 `Http` 사용하는 객체로 **다운캐스팅**한다.
  
  - 서블릿 객체에 대해 일종의 설계 미스가 있음

- 인증 체크가 필요없는 URL 패턴을 저장하고, `PatternMatchUtils` 을 사용해서 request URL과 비교한다.
  
  - **화이트리스트** 개념으로 지정해야, **향후 추가되는 모든 페이지에서** 신경쓰지 않을 수 있다.

- 인증 실패 시 **리다이렉트 처리**를 해줌으로써 UX를 챙길 수 있다.
  
  - 로그인 컨트롤러에서 `@RequestParam` 을 받아서 리다이렉트 처리하는 간단한 로직

- 필터를 `@Configuration` 에 등록하고, 우선순위를 설정해줌으로써 앞서 만들었던 **로그 처리 핕터**와의 **체이닝**을 구현할 수 있다.

### 정리

서블릿 필터를 적용함으로써, **로그인 관련 정책을 철저히 분리**하고 **로그인 정책 변경에 대응하기가 쉬워진다.**

#### 참고

스프링 인터셉터가 제공하지 않는 기능 중에는, `request` 와 `response` 객체 자체를 다른 객체로 변경해서 다음 필터로 넘기는 기능도 있다.

자주 사용하지는 않는다.

---

## 스프링 인터셉터 - 소개

서블릿 필터와 같이 **웹 관련 공통 관심 사항**을 효과적으로 해결할 수 있는 기술이다.

서블릿 필터는 **서블릿**이 제공하는 기술이고

스프링 인터셉터는 **스프링 MVC**가 제공하는 기술

### 스프링 인터셉터 흐름

```
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤
```

스프링 인터셉터는 **디스패쳐 서블릿**과 **컨트롤러** 사이에서 호출된다.

마찬가지로 URL 패턴을 적용할 수 있는데, 서블릿 필터에서보다 훨씬 정밀한 설정이 가능하다.

#### 스프링 인터셉터 제한

서블릿 필터와 동일하게, 인증을 적용할 수 있다.

다만 호출되는 순서가 다르다는 점

#### 스프링 인터셉터 체인

마찬가지로 **체인**으로 구성되기 때문에, 자유롭게 인터셉터를 추가할 수 있다.

결과적으로 서블릿 필터랑 거의 동일한 개념이라고 볼 수 있다. 대신 스프링 인터셉터가 더 편리하고, 정교하다.

#### 스프링 인터셉터 인터페이스

`HandlerInterceptor` 인터셉터를 구현하여 사용하면 된다.

- 컨트롤러 호출 전인 `preHandle`

- 컨트롤러 호출 후인 `postHandle`

- 요청 완료 후인 `afterCompletion` 까지 세분화된 처리가 가능하다.

어떤 컨트롤러가 호출되는지, 어떤 `ModelAndView`가 반환되는 지 까지도 모니터링 가능하다.

### 스프링 인터셉터 호출 흐름

- HTTP 요청이 진입하여 앞단을 모두 지나면 **디스패처 서블릿**이 호출됨

- 

#### 정상 흐름


