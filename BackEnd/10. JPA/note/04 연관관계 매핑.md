# 연관관계 매핑

---

## 단방향 연관관계

### 연관관계가 필요한 이유

객체를 테이블에 맞추어서 데이터 중심으로 모델링할 시,

객체 간의 **협력 관계**를 구성하기가 어렵다.

- 테이블 간에는 FK+JOIN으로 연관성을 가져가는 반면

- 객체 간에는 **참조**를 통해 연관성을 가져간다.

- 이걸 끼워맞추다보면 객체지향 측면에서는 어색한 코드가 구성된다.

### 단방향 연관관계 구성

`@ManyToOne` 애노테이션으로 설정할 수 있다.

- 한 쪽의 PK를 한 쪽이 FK로 쳐다보는 관계

- `@JoinColumn` 애노테이션으로 Join할 컬럼명을 명시할 수 있다.

이후 `em.find()` 로 객체를 조회할 시, DB FK값 같은 걸 전혀 신경쓰지 않고도 자연스럽게 연관관계에 있는 객체의 참조를 가져다가 쓸 수 있다.

---

## 양방향 연관관계와 연관관계의 주인

### 연관관계의 주인과 mappedBy

객체와 테이블 간에 연관관계를 맺는 차이를 정확히 이해해야 한다.

- 객체 간 연관관계는 따지고 보면 2개
  
  - 서로가 서로의 참조값을 들고 있음

- 테이블 간 연관관계는 FK를 매개로 정확히 1개

즉, 객체의 **양방향** 관계는 엄밀히 따졌을 때 **서로 다른 단방향 관계 2개다**.

그렇다면, 연관관계로 묶여있는 객체를 **변경**할 때는 대체 무엇을 변경해야 하는가?

- Member <-> Team 간 연관관계가 있을 때,

- 특정 Member의 Team을 바꾸고자 한다면

- Member의 필드인 Team을 바꾼다 vs Team의 필드인 List<Member>를 바꾼다

이 부분에 대해서 테이블 연관관계는 고민할 게 없는 것

- FK로 지정된 특정값을 바꾼다는 **해답이 명확**함

### 연관관계의 주인 (Owner)

양방향 매핑 시, 객체의 두 관계 중 하나를 **연관관계의 주인으로 반드시 지정**해야 한다.

연관관계의 주인만이 **외래 키를 관리**할 수 있고, 주인이 아닌 쪽은 **읽기**만 가능하다.

#### 주인이 되는 객체

**외래 키가 있는 곳을 주인으로 정한다**.

- 테이블을 설계할 때 외래 키가 위치하는 곳과 동일

- 위 예시에서는 Member 쪽이 주인이 될 것

- 주인이 아닌 쪽 (Team) 은 `mappedBy` 가 선언된다.

이러한 기준이 세워진 데에는 여러 이유가 있다. 성능 등등..

- **비즈니스 로직**은 연관관계 주인을 정하는 데에 **아무런 의미가 없다**.

### 양방향 매핑 시 주의사항

- 연관관계의 주인에 값을 입력해야 한다. 주인이 아닌 쪽 (읽기 전용) 을 수정하면 DB는 변화하지 않는다.

- 하지만, **순수하게 객체지향적 관계를 고려하면** 양쪽 모두에 값을 입력하는 게 바람직하다.
  
  - 2개의 단방향 연관관계가 존재하는데, 둘 중에 하나만 입력하는 게 엄밀히 따지면 어색하다.
  
  - **영속성 컨텍스트와 1차 캐시**의 존재로 인해 버그가 발생할 여지도 존재한다.
  
  - 양쪽 모두에 값을 설정하기 위한 **편의 메서드**를 생성하고 사용하는 쪽이 좋다.

- 양방향 매핑 시, 무한 루프가 발생할 가능성이 있으니 주의
  
  - `toString()`, `lombok`, JSON 생성 라이브러리 등

### 양방향 매핑 정리

사실, **단방향 매핑이 존재한다면 이미 연관관계 매핑은 완료된다**.

양방향 매핑을 추가하는 건 **반대 방향으로 조회**하는 **기능**을 추가하는 의미. (객체 그래프 탐색)

- 특히 JPQL 사용 할 때 역방향 탐색할 일이 많다.

단방향 매핑을 잘 해두고, 양방향은 **꼭 필요할 때** 추가하면 된다.


