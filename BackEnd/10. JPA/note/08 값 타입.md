# 값 타입

---

## 기본값 타입

### JPA의 데이터 타입 분류

#### 엔티티 타입

`@Entity`로 정의하는 객체

- 데이터가 변해도, 객체의 식별자를 통해 지속 추적 가능

#### 값 타입

`int` `String`처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체.

- 변경 시 추적 불가

### 값 타입의 분류

- 기본값 타입
  
  - 자바 기본 타입
  
  - 래퍼 클래스
  
  - String

- 임베디드 타입

- 컬렉션 값 타입

### 기본값 타입

생명주기를 **엔티티에 의존**한다.

기본값 타입의 value는 **공유하면 안 된다**. 애초에 공유를 못 한다.

- 래퍼 클래스나 String은 가능하긴 하지만, 역시 공유하면 안 된다.

---

## 임베디드 타입(복합 값 타입)

자바는 새로운 값 타입을 직접 정의하는 게 가능하다.

- 그냥 커스텀 클래스 하나 만드는 코드를 뜻함

- JPA는 이를 임베디드 타입이라고 한다.

주로 기본값 타입을 모아 만들어서, 복합 값 타입이라고 한다.

### 사용법

`@Embeddable`, `@Embedded`

위 애노테이션을 필드에 기재함으로써 임베디드 타입을 부여할 수 있다.

### 장점

- 재사용성이 증대된다.

- 응집도가 높아진다.

- 해당 값 타입을 이용한 유틸성 메서드를 만드는 게 용이하다.

- 해당 타입을 소유한 엔티티에 **생명주기를 의존**할 수 있다.

### 임베디드 타입과 테이블 매핑

테이블 쪽에서는 **달라지는 게 전혀 없다**.

- JPA가 중간에 매핑만 잘 해주면 된다.

객체와 테이블 간의 매핑이 보다 세밀해지는 것이라고 보면 된다.

잘 설계된 ORM 애플리케이션이라면, 매핑된 테이블의 수보다 클래스의 수가 더 많다.

### @AttributeOverride

동일한 임베디드 타입을 두 개 이상 사용하려면 한 쪽의 필드명을 오버라이드해야 컬럼명 충돌이 발생하지 않는다.

---

## 값 타입과 불변 객체

### 값 타입 공유 참조

임베디드 타입 같은 값 타입의 경우, **여러 엔티티에서 공유**하는 게 가능하다.

- 당연히 사이드 이펙트가 발생한다.

로직상 필요하다면, 값 타입의 실제 인스턴스를 공유하는 게 아니라 **복사**해서 새로운 인스턴스를 생성하고 사용해야 한다.

### 객체 타입의 한계

해당 문제는 **컴파일 수준**에서 잡는 게 불가능하다.

개발자가 객체 타입의 참조 값을 직접 대입하여, 공유 참조를 유발했을 때 **현실적으로 막을 방법이 없다**.

### 불변 객체

**객체 타입을 수정할 수 없게 만듦으로써 부작용을 원천 차단**한다.

값 타입을 **불변 객체**로 생성하고 관리한다.

- 불변 객체 : 생성 시점 이후에는 **절대 값을 변경할 수 없는 객체**

- 생성자로만 값을 설정하고, `setter` 같은 메서드를 만들지 않는 것

---

## 값 타입의 비교

값 타입은 성격 상, 인스턴스가 달라도 그 안의 값이 동일하면 같은 것으로 봐줄 필요가 있다.

### 동일성, 동등성

**동일성 비교** : 인스턴스의 **참조 값**을 비교한다. `==` 사용

**동등성 비교** : 인스턴스의 **값**을 비교한다. `equals()` 사용

값 타입의 경우 **동등성 비교**가 적절하다.

- 모든 필드를 담아서 `equals()` 메서드를 오버라이드하는 게 일반적이다.

---

## 값 타입 컬렉션

값 타입을 **하나 이상 저장하고자 할 때** 사용한다.

- `@ElementCollection`, `@CollectionTable` 애노테이션을 사용해서

- 컬렉션을 저장하기 위한 **별도의 테이블을 구성**하는 방식을 적용한다.

### 값 타입 컬렉션 사용

- 값 타입 컬렉션은 **영속성 전이**(cascade), **고아 객체 제거** 기능이 필수적으로 적용된다.

- 값 타입 컬렉션에는 **지연 로딩 전략**이 기본값으로 적용된다.

- 값 타입을 수정하고자 할 시, 필드값은 `set` 하는 방식은 위험하다. (불변 객체 사용)
  
  - 새로운 인스턴스를 생성해서 아예 갈아끼워야 한다.

- 값 타입 컬렉션의 value를 Java 코드에서 수정하면, 영속성이 전이되어 실제 테이블 DML이 발생한다.

### 값 타입 컬렉션의 제약사항

**엔티티와 달리 식별자 개념이 없다.** 즉, 값을 변경할 때 추적이 어렵다.

- DB 기준으로, 컬렉션 저장용 테이블에 **PK가 안 잡혀있다**.

그래서 값 타입 컬렉션에 변경 사항이 발생할 시, **주인 엔티티와 연관된 모든 데이터를 삭제하고 현재 값을 모두 다시 저장**하게 된다.

정 필요하다면 컬렉션 저장용 테이블의 모든 컬럼을 묶어서 **PK를 구성해야 한다**.

### 값 타입 컬렉션 대안

실무에서는 차라리 **일대다 관계를 위한 엔티티**를 만드는 게 좋다.

그리고 영속성 전이와 고아 객체 제거 설정을 부여하여,

값 타입 컬렉션처럼 사용하면 동일한 효과를 달성할 수 있다.

- **값 타입을 엔티티로 승급시킨다**는 표현을 쓴다.

값 타입 컬렉션을 쓰는 상황은 **정말 단순하고 안 중요한 데이터를 저장할 때**

- 식별자가 필요하고, 지속적으로 값을 추적 및 변경해야 할 시

- 이건 엔티티다.


