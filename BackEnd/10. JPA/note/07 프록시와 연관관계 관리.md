# 프록시와 연관관계 관리

---

## 프록시

### 기초

`em.getReference()` 를 통해, **DB 조회를 미루고 프록시 엔티티 객체를 조회**할 수 있다.

- `getClass()` 로 객체를 확인해보면, `$HibernateProxy` 가 붙어있는 걸 확인 가능하다.

### 특징

실제 클래스를 **상속** 받아서 만들어진 프록시 클래스로, 실제 클래스와 겉 모양이 동일하다.

- 즉, 사용하는 Java 코드 입장에서는 실제 객체와 구분하지 않고 사용할 수 있게 된다.

프록시 객체는 실제 객체의 **참조값**을 보관하고 있어서, 프록시 객체를 호출할 시 (`getName()`  같은거) 실제 객체의 메서드를 호출하게 된다.

### 프록시 객체의 초기화

- 코드 상에서 프록시 객체의 메서드를 호출한다.

- 프록시 객체의 `target` 이 비어있으면, **영속성 컨텍스트**로 **초기화를 요청**한다.

- 영속성 컨텍스트는 **1차 캐시**를 반환하거나 **DB를 조회**하여, 실제 Entity를 생성한 뒤 프록시 객체로 반환한다.

- 결과적으로 실제 객체의 메서드가 호출되여 클라이언트 측으로 반환된다.

### 정리

- 프록시 객체는 처음 **사용**할 때 한 번만 초기화된다.

- 프록시 객체를 초기화한다고 하여 **프록시 객체가 실제 엔티티로 바뀌는 것은 아니다**. 
  
  - 프록시 객체를 통해서 실제 엔티티에 접근하는 것.
  
  - 초기화 이후 `getClass()` 로 확인해도 여전히 `$HibernateProxy` 이다.

- 프록시 객체는 원본 엔티티를 **상속받은 객체**이다. `==` 비교를 하는 게 아니라 `instanceof` 비교를 사용해야 한다.

- 만약 영속성 컨텍스트에 찾고자 하는 실제 엔티티가 존재한다면, `em.getReference()` 를 호출하더라도 **프록시가 아닌 실제 엔티티**가 반환된다.
  
  - 그 반대도 마찬가지다.
  
  - 프록시를 호출해서 초기화한 뒤 `em.find()` 로 동일한 엔티티를 조회하면, 실제 엔티티가 아니라 **초기화가 완료된 그 프록시**가 반환된다.

- 영속성 컨텍스트에서 분리된 **준영속** 상태일 때, 프록시를 초기화하려고 하면 문제가 발생한다.
  
  - `Could not initialize proxy` 에러 발생

### 프록시 확인하기

- 프록시 인스턴스의 초기화 여부 확인
  
  - `PersistenceUnitUtil.isLoaded()`

- 프록시 클래스 확인
  
  - `entity.getClass().getName()`

- 프록시 강제 초기화
  
  - `Hibernate.initialize()`
  
  - 참고로 JPA 표준에서는 강제 초기화가 없다. Hibernate 스펙을 직접 사용한 것

---

## 즉시 로딩과 지연 로딩

### 사용

연관관계가 존재하는 엔티티의 필드 (`@ManyToOne` 등) 에서 `FetchType` 을 지정할 수 있다.

- `LAZY` : 지연 로딩
  
  - `em.find()` 시점에는 연관된 객체를 조회하지 않는다.
  
  - `getReference()` 해서 가지고 있다가, 실제로 사용하고자 할 때 초기화한다.

- `EAGER` : 즉시 로딩
  
  - 조회 즉시 `join` 쿼리를 생성해서 연관된 엔티티를 가져온다.

### 주의사항

**가급적 지연 로딩만 사용하는 게 좋다**.

- 아무 생각없이 EAGER를 늘리다보면 JOIN 대상이 기하급수적으로 증식하게 된다.
  
  - 예상치 못한 SQL 지연을 유발할 수 있다.

- 즉시 로딩은 **JPQL에서 N+1 문제를 발생**시킨다.

- `@ManyToOne`과 `@OneToOne`은 기본값이 EAGER다.
  
  - **실무에서 항상 LAZY를 명시해야 한다.**

#### N+1 문제

JPQL은 어찌됐든 DB에 쿼리를 즉시 날려버리는 개념.

지정된 엔티티를 조회하고자 쿼리를 날렸는데, 필드 중에 `EAGER` 로딩 대상이 존재한다면?

- 해당 필드를 채우기 위한 **추가 select 쿼리가** 뒤따라 발생한다.

이렇게 **의도하지 않은 N개의 쿼리가 추가적으로 발생**한다는 점에서 N+1 문제라고 한다.

### 지연 로딩의 활용

**모든 연관관계에서 지연 로딩을 활용하는 게 맞다**.

- 정 필요하면 JPQL fetch 조인이나, 엔티티 그래프 기능을 활용

즉시 로딩은 **쿼리를 통제할 수 없다**는 점에서 실무적으로 지나치게 위험하다.

---

## 영속성 전이(CASCADE)와 고아 객체

### 영속성 전이 : CASCADE

특정 엔티티를 영속 상태로 만들 때, **연관된 엔티티도 함께** 영속 상태로 만들고 싶은 상황을 말한다.

- `cascade = CascadeType.ALL` 이런 옵션으로 지정

#### 주의사항

**연관관계 매핑**과는 **직접적인 관계가 전혀 없다**.

- 그저 엔티티를 영속화할 때의 **편의**를 제공하는 기능이다.

엔티티 간의 종속관계가 **아주 굳게 잡혀있을 때**만 제한적으로 활용한다.

- ex. **단일 소유** 관계일 때

### 고아 객체

부모 엔티티와 연관관계가 **끊어진** 자식 엔티티를 **자동으로 삭제**하는 개념

- `orphanRemoval = true`

참조가 제거된 엔티티를 **다른 곳에서 참조하지 않는 고아 객체로 간주**하고 삭제한다.

#### 주의사항

**참조하는 곳이 하나일 때만 사용해야 한다**.

- 특정 엔티티를 **개인 소유**할 때.

- `@OneToOne` 혹은 `@OneToMany`가 대전제.

`CascadeType.REMOVE` 와 비슷한 개념으로 동작한다.

### 영속성 전이 + 고아 객체 : 생명 주기

위 옵션을 잘 활용하면, **부모 객체가 자식 객체의 생명 주기를 관리**하는 개념을 완성할 수 있다.

도메인 주도 설계(DDD)의 **Aggregate Root** 개념을 구현할 때 유용하다.


