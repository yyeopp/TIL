# JPA 소개

---

## SQL 중심적인 개발의 문제점

---

### 패러다임의 불일치

상속, 연관관계를 적극적으로 사용하여 객체지향 프로그래밍을 실현할수록,

**데이터베이스에 대한 매핑 작업이 힘들어지는 부작용**이 발생

- 객체를 DB에 CRUD하는 작업이 반복적이거나 번거롭고

- 객체를 의도한 대로 탐색하기가 어렵고

- 조회한 엔티티를 신뢰할 수 없다.

---

## JPA 소개

### JPA

Java Persistence API

자바 진영의 ORM 기술 표준

애플리케이션과 JDBC 사이에서 동작

- SQL를 자동으로 생성하여 JDBC API를 대신 호출해주는데,

- 핵심은 **패러다임의 불일치를 해결**해주는 데에 있다.

### ORM

Object-relational mapping

객체는 객체대로 설꼐하고, RDB는 RDB대로 설계한 뒤

ORM 프레임워크가 **중간에서 매핑**해주는 것.

### JPA 역사

태초에 자바 표준은 EJB.

- 너무 어렵고 성능도 조악해서 아무도 안 썼다.

이에 대응하는 오픈소스로 **하이버네이트**가 출시됐는데,

자바 표준 측에서 하이버네이트를 흡수하여 JPA로 리뉴얼했다.

- 사실상 하이버네이트의 카피라고 보면 된다.

- 하이버네이트는 현재 JPA의 **구현체** 지위를 가지고 있다. 그 외에도 구현체가 몇 개 더 있지만 대부분 하이버네이트를 사용한다.

### JPA를 사용해야 하는 이유

- SQL 중심적 개발 -> 객체 중심 개발

- 생산성, 유지보수

- 패러다임의 불일치 해결 : 상속, 연관관계, 객체 그래프 탐색, 객체 비교

- 데이터 접근 추상화와 벤더 독립성

- 표준

- 성능 최적화 기능
  
  - 1차 캐시와 동일성 보장
  
  - 트랜잭션을 지원하는 쓰기 지연
  
  - 지연 로딩과 즉시 로딩

---

## JPA 시작

### 데이터베이스 방언

JPA는 특정 DBMS에 종속되지 않는다.

DBMS 간에 발생하는 문법 차이는 **방언**(dialect) 으로 취급하여, 설정파일에서 사용 중인 DBMS를 적절히 명시하면 그에 맞게 SQL을 생성해준다.

- `hibernate.dialect`

- 40가지 이상의 DBMS를 지원하고 있다.

### JPA 구동 방식

`Persistence` 객체에서 시작한다.

- `META-INF/persistence.xml` 에서 설정 정보를 조회하고

- `EntityManagerFactory` 를 생성

`EntityManagerFactory` 가 실제 `EntityManager`를 생성함으로써 JPA가 구동된다.

### 주의

`EntityManagerFactory` 는 **하나만 생성해서 애플리케이션 전체에서 공유**한다.

`EntityManager` 를 쓰레드 간에 공유하면 안 된다.

JPA의 모든 데이터 변경은 **트랜잭션** 안에서 실행해야 한다.

### JPQL

JPA로 엔티티 객체 중심 개발을 진행하더라도, **검색** 쿼리는 피할 수 없다.

애플리케이션에 필요한 데이터만 DB에서 불러오려면 결국 **검색 조건**이 포함된 SQL을 수행해야 한다.

JPQL이 SQL을 추상화한 **객체 지향 쿼리 언어**이다.

SQL과 거의 문법이 유사하고, dialect도 모두 지원된다.


