# 엔티티 매핑

---

## 객체와 테이블 매핑

### @Entity

@Entity 가 붙은 클래스를 JPA가 관리하며, **엔티티**라고 한다.

테이블과 매핑할 클래스에 해당 애노테이션을 붙인다.

#### 주의사항

- 기본 생성자가 반드시 필요하다.

- final 클래스, enum, interface, inner 클래스를 적용하면 안 된다.

- DB에 저장하고자 하는 필드라면 final을 사용하면 안 된다.

---

## 데이터베이스 스키마 자동 생성

JPA는 애플리케이션 실행 시점에 **DDL**을 자동 생성하는 기능을 지원한다.

- 테이블 중심이 아닌 **객체 중심**으로 개발하고자 하는 사상이 반영된 부분

- DBMS에 맞는 dialect도 적절히 적용된다.

- 당연히 개발 단계에서만 사용해야 한다.

### 속성

- create : 애플리케이션 구동 시 생성 (기존 테이블은 DROP)

- create-drop : 애플리케이션 종료 시 DROP

- update : 변경분만 자동으로 반영 (추가만 반영됨)

- validate : 애플리케이션 구동 시 엔티티와 테이블이 정상 매핑 중인지 검증

- none

### 주의

**운영 환경에서 create, create-drop, update를 사용할 생각은 하면 안 된다**.

- validate, none 정도가 적절

테스트 환경이라고 해도 update, validate 수준이 한계다.

- 테스트용 데이터가 날라가기 때문

### DDL 생성 기능

유니크 제약조건을 추가한다거나 컬럼 사이즈를 지정하는 등의 동작도 가능한데,

JPA 동작에 영향을 준다기보다는 **DDL 생성을 위해** 지원되는 스펙이다.

---

## 필드와 컬럼 매핑

### @Column

- `unique` 옵션은 잘 사용하지 않는다. 생성되는 제약조건의 이름을 알아보기 어렵기 때문

- `nullable` 이나 `length` 같은 옵션은 쓸 만하다.

### @Enumerated

Java의 Enum에 대응해주기 위한 스펙

- 반드시 `EnumType.STRING` 으로 사용해야 한다.

- 기본값은 `EnumType.ORDINAL` 으로 Enum 간의 순서인데, Java 코드 구조 상 매우 쉽게 변경될 수 있는 값이다.

## @Temporal

Java 구버전이 아니라면 쓸 일이 없다.

8 이상이라면 `LocalDate`, `LocalDateTime` 사용하면 됨

### @Lob

DB의 BLOB, CLOB과 매핑해준다.

### @Transient

엔티티에서 사용할 필드이지만 DB에 저장하지 않고 메모리에서만 사용하고자 할 시 명시한다.

해당 필드는 DDL에 포함되지 않는다.

---

## 기본 키 매핑

직접 할당하는 방법이 있고, (`@Id`)

자동 생성하는 방법이 있다. (`@GeneratedValue`)

- `IDENTITY` : DBMS에 위임

- `SEQUENCE` : DB에 시퀀스 오브젝트를 생성
  
  - `@SequenceGenerator`를 직접 지정할 수 있음

- `TABLE` : 키 생성 전용 테이블을 하나 만들어서 시퀀스 값을 테이블에서 관리하는 전략

- `AUTO` : dialect에 부합하는 방법을 자동으로 지정함

### 권장하는 식별자 전략

기본 키는 기본적으로 **not null, unique, 불변**

- 그 어떤 경우에도 이 조건을 만족시킬 수 있는 **자연키**는 찾기 어렵다.
  
  - 주민등록번호조차도 부적절하다.

- **대리키**를 사용할 필요

권장하는 방식은 **Long형 + 대체키 + 키 생성전력**

### IDENTITY 전략의 특징

기본 키 생성을 DB에 위임하기 때문에,

JPA의 기본 전략처럼 **트랜잭션 커밋 시점까지 insert를 미루는 게 다소 어렵다**.

따라서 IDENTITY 전략이 지정된 경우 `em.persist()` 시점에 즉시 INSERT가 발생한다.

### SEQUENCE 전략의 특징

SEQUENCE로 지정할 시, `em.persist()` 시점에 시퀀스 오브젝트를 `call` 하여 값을 받아와야 한다.

- 실제 insert 쿼리는 `commit()` 까지 지연시키는 게 가능하다.

이걸 해결하는 방법은 `allocationSize`를 지정하는 것

- 50으로 설정한다면, 애플리케이션에서 시퀀스를 호출할 때마다 **한 번에 50개의 시퀀스를 가져와서 메모리에 저장**한다.

- 이후 `em.persist()` 할 때, 시퀀스를 추가로 호출하는 게 아니라 메모리에 들고 있는 시퀀스 값을 하나씩 사용하는 방식

- 당연히 시퀀스 오브젝트 자체도 50씩 증가하도록 설정되어 있어서, 애플리케이션이 다중화되어있을 때 충돌이 발생하지 않는다.

- 다중화된 환경에서는 시퀀스 간의 **순서**가 보장되지 않을 수 있다는 점은 감안할 필요가 있다.


