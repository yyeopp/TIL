# 고급 매핑

---

## 상속관계 매핑

RDB는 기본적으로 상속 관계가 없다.

대신 **슈퍼타입 서브타입 관계**라는 모델링 기법이 그나마 유사하다.

- **상속관계 매핑**은 객체의 상속관계를 RDB의 슈퍼타입 서브타입 모델로 구현한 것.

RDB의 슈퍼타입 서브타입 논리 모델을 물리적으로 구현할 시, **조인 전략**, **단일 테이블 전략**, **구현 클래스마다 테이블 전략**으로 구분할 수 있다.

- 중요한 건, **객체 지향**의 관점에서 위 3개 전략 사이에 차이가 없다는 것.

- DB를 관리하는 입장에서 선택의 여지가 있는 것이지, 객체지향 코드에서는 크게 신경쓰지 않아도 된다.

### 주요 애노테이션

#### @Inheritance

상속 관계를 실제 RDB에 어떻게 구현할 지 **전략을 선택하는 애노테이션**이다.

기본값은 **SINGLE_TABLE**

- **JOINED** : 조인 전략

- **SINGLE_TABLE** : 단일 테이블 전략

- **TABLE_PER_CLASS** : 구현 클래스마다 테이블 전략

#### @DiscriminatorColumn

슈퍼타입 쪽 테이블에서 어떤 서브타입에 대한 레코드인지를 구분하기 위한 컬럼명

기본값은 **DTYPE**

- 조인 전략을 사용할 시, 컬럼 생성 자체를 생략할 수도 있다.

- 단일 테이블 전략에서는 **반드시 있어야 한다**

#### @DiscriminatorValue

위에서 명시한 DiscriminatorColumn에 적재될 서브타입 쪽 Value 값

기본값은 **엔티티명**

### 각 전략의 장단점

#### 조인 전략

장점

- 테이블 정규화

- 저장공간 효율화

- 외래 키 참조, 무결성 제약조건 활용 가능

단점

- 조회 시 조인을 많이 사용하여 성능 저하

- 조회 쿼리가 복잡함

- 데이터 저장 시, INSERT 2번 호출

#### 단일 테이블 전략

장점

- 조인이 불필요. 일반적으로, 조회 성능이 빠름

- 조회 쿼리 단순

단점

- 자식 엔티티가 매핑하는 컬럼에 모두 nullable 적용 강제

- 상황에 따라서 조회 성능 지연

- 테이블이 과대해질 수 있음

#### 구현 클래스마다 테이블 전략

**기본적으로 안 쓰는 게 좋다.**

장점

- 서브 타입을 명확하게 구분해서 처리할 때 효과적

- NOT NULL 제약조건 적용 가능

단점

- 자식 테이블을 통합해서 조회하기 어려움

- DB 설계 변경이 어려움

---

## @MappedSuperclass

엄밀히 말했을 때 **상속관계에 대한 매핑은 아니다**.

- 애초에 엔티티도 아니고, 테이블과 직접적으로 매핑되지 않는다.

- 해당 부모 클래스를 상속받는 **자식 클래스에 매핑 정보만 제공하기 위한 애노테이션**

- `em.find()` 로 조회 및 검색이 불가하다.

직접 생성해서 사용할 객체가 아니므로 **추상 클래스로 생성하는 걸 권장**한다.

### 사용

테이블과 무관하게 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할

- 주로 등록일, 수정일, 등록자, 수정자 등


