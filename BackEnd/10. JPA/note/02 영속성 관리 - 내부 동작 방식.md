# 영속성 관리 - 내부 동작 방식

---

## 영속성 컨텍스트

### 영속성 컨텍스트란?

**엔티티를 영구 저장하는 환경**이라는 뜻

JPA를 이해하는 데 가장 중요한 용어

`EntityManager.persist(entity)`

- 영속성 컨텍스트는 **논리적**인 개념이다.

### 엔티티의 생명주기

- 비영속 (new / transient)
  
  - 영속성 컨텍스트와 전혀 관계 없음

- 영속 (managed)
  
  - 영속성 컨텍스트에서 관리되는 상태
  
  - `em.persist()` 하는 순간 **영속** 상태가 된다.
  
  - 근데 이게 **DB에 저장됐다**는 뜻이 **아니다**.
  
  - 영속성 컨텍스트 내에서 관리하다가, `tx.commit()`하는 순간에 비로소 DB에 저장된다.

- 준영속 (detached)
  
  - 영속성 컨텍스트에 저장되었다가 분리된 상태

- 삭제 (removed)
  
  - 삭제된 상태

### 엔티티 조회, 1차 캐시

영속성 컨텍스트는 일반적으로 하나의 트랜잭션 내에서 유지된다.

트랜잭션 내에서 영속성 컨텍스트가 가지고 있는 데이터를 조회하고자 시도할 시,

영속성 컨텍스트에 저장된 데이터가 **1차 캐시**로써 작동하여 DB에 접근하지 않게 된다.

### 영속 엔티티의 동일성 보장

마치 Java Collection에서 객체를 조회한 것처럼, 1차 캐시에서 가져오는 영속 엔티티 간의 동일성 (메모리 주소) 을 보장한다.

**REPEATABLE READ**등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공하게 된다.

### 트랜잭션을 지원하는 쓰기 지연

`em.persist()` 가 아니라 `tx.commit()` 하는 순간에 insert SQL이 DB로 보내진다.

정확히, `em.persist()` 하는 순간

- JPA 내부의 **쓰기 지연 SQL 저장소**에 insert 쿼리를 저장하고

- 영속성 컨텍스트 **1차 캐시**에 데이터를 저장한다.

그리고 `tx.commit()` 시점에 실제 insert가 이루어지는데,

- `jdbc.batch` 스펙을 사용해서 DML에 대한 성능을 최적화할 수 있다.

### 변경 감지

Dirty Checking

엔티티는 1차 캐시에 진입하는 순간 **스냅샷**이 떠진다.

자바 코드에서 엔티티를 변경할 시 (정확히는 `flush` 하는 순간) 해당 스냅샷과 비교하여 **변경을 감지**한다.

이를 통해 update 쿼리를 생성하고, **쓰기 지연 SQL 저장소**에 쿼리를 저장한다.

---

## 플러시

영속성 컨텍스트의 변경내용을 **데이터베이스에 반영**하는 것이다.

### 플러시 발생

다음과 같은 일이 발생한다.

- 변경 감지

- 수정된 엔티티에 대한 update 쿼리를 쓰기 지연 SQL 저장소에 등록

- 쓰기 지연 SQL 저장소의 쿼리를 DB로 전송

### 플러시 호출

- `em.flush()`로 직접 호출할 수 있다.

- `tx.commit()` 시점에 자동으로 호출된다.

- JPQL 쿼리를 실행하면 자동으로 호출된다.
  
  - JPQL은 그 자체로 직접 DB에 쿼리를 날리는 방식이다보니, 그동안 쌓아둔 쓰기 지연 SQL 쿼리를 모두 적용할 필요가 있다.

### 플러시 모드 옵션

- **AUTO**: 커밋이나 **쿼리를 실행할 때** 플러시 (기본값)

- **COMMIT** : 커밋할 때만 플러시

---

## 준영속 상태

영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태.

영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

- `em.detach()` : 특정 엔티티를 분리

- `em.clear()` : 영속성 컨텍스트를 통째로 초기화

- `em.close()` : 영속성 컨텍스트 종료


