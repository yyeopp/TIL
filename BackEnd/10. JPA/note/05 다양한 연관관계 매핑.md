# 다양한 연관관계 매핑

---

## 일대다 [1:N]

일(1) 쪽이 연관관계의 주인이 되는 관계로,

연관계의 주인은 자연스럽게 반대편 테이블의 외래 키를 관리하게 된다.

- 분명 A 객체를 제어했는데 B 객체에 update 쿼리가 날라가는 식

`@JoinColumn` 을 지정하지 않을 시, **조인 테이블** 방식이 자동으로 적용되어 매핑용 테이블이 생성되는 점을 주의

### 단점

엔티티가 관리하는 외래 키가 다른 테이블에 있다는 점 그 자체

연관관계를 관리하려면 update SQL이 실행된다.

- 차라리, 다대일 양방향 매핑을 사용하는 게 바람직하다.

### 일대다 양방향?

위와 같은 구조에서 한 발 더 나가서, N 쪽에 1로 향하는 참조를 설정하는 것

`@JoinColumn(insertable=false, updatable=false)` 를 사용한다.

즉, **공식적으로 존재하는 매핑 방법이 아니다.**

애초에 사용하지 말자.

---

## 일대일 [1:1]

양쪽 어디에 외래키를 세팅해도 성립하는 관계.

DB 기준으로는 unique 제약조건에 해당한다.

`@OneToOne` 애노테이션으로 설정할 수 있다.

다대일과 유사하게, 연관관계의 주인이 되는 쪽은 **외래 키를 관리하는 쪽**이다.

-  `mappedBy` 와 `@JoinColumn` 도 동일하게 사용한다.

### 외래 키를 어디에 세팅할 것인가

#### 주 테이블 세팅

주 테이블 (ex. Member) 에 외래 키를 두고 대상 테이블 (ex. Locker) 을 조회한다.

- **JPA 매핑이 편리**하기 때문에 객체지향 개발자가 선호한다.

- 단점: 외래 키인데도 NULL을 허용해야 한다.

#### 대상 테이블 세팅

대상 테이블에 외래 키가 존재한다.

- 전통적인 DB 개발자가 선호한다.

- 주 테이블과 대상 테이블의 관계가 일대다로 변경될 시, 테이블 구조를 유지할 수 있다.

- 단점: 프록시 기능의 한계로 인해 **지연 로딩으로 설정해도 항상 즉시 로딩된다**.

---

## 다대다 [N:M]

RDB는 기본적으로 정규화된 테이블 2개만 이용해서 다대다 관계를 표현할 수 없다.

**연결 테이블**을 추가해서, 일대다 + 다대일 관계로 풀어야 한다.

반면, 객체는 컬렉션을 사용할 시 **객체 2개만으로도** 다대다 관계를 표현할 수 있다.

- 여기서 발생하는 충돌을 해결해야 하는 것

`@ManyToMany` 애노테이션과 `@JoinTable` 을 명시함으로써 JPA를 이용해 다대다 관계를 구현할 수 있다.

### 다대다 매핑의 한계

일견 편리해보이지만 실무에서 사용하면 곤란하다.

- 연결 테이블이 단순히 연결만 하고 끝날 리가 없기 때문

- 비즈니스 로직 상 그에 부수하는 여러 데이터가 연결 테이블에 기재될 수밖에 없다.

연결 테이블을 뒷단에 숨겨두는 게 아니라,

연결용 **엔티티**로 **승격해서 관리**하는 게 바람직하다.

- ManyToMany -> OneToMany + ManyToOne


