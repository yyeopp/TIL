# 쿼리 메서드 기능

---

## 메서드 이름으로 쿼리 생성

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
}
```

스프링 데이터 JPA는 메서드 이름을 분석해서 JPQL을 자동생성해준다.

- 모든 사용법은 공식 문서에서 확인해볼 수 있다.

- 거의 대부분의 **단순한** 요구사항은 이 정도 선에서 해결이 된다.

findBy, readBy, count, exists, distinct, limit 등등..

#### 런타임 오류 방지

엔티티의 필드명이 변경될 시, 당연히 인터페이스에 명시한 **메서드명을 함께 변경해야 한다**.

메서드명이 부정확할 시 **애플리케이션을 시작하는 시점에** 오류가 발생한다.

---

## JPA NamedQuery

JPA는 원래 NamedQuery라는 기능을 제공한다. 스프링 데이터 JPA에서도 그대로 제공한다.

- 엔티티에 `@NamedQuery` 지정

- JpaRepository에서 `@Query` 애노테이션으로 해당 NamedQuery를 매핑
  
  - 단, 엔티티 쪽 네이밍룰에 이상이 없다면 애노테이션은 생략할 수 있음

하지만 NamedQuery는 엔티티에다가 쿼리를 박아놓는 부분이 설계적으로 어색하기 때문에 실무적으로 잘 사용하지는 않는다.

그럼에도 한 가지 강력한 기능은, 작성된 JPQL을 **애플리케이션 실행 시점**에 파싱해준다는 것.

- 일반 JPQL은 **런타임에만** 오류가 발생한다.

---

## @Query

굳이 엔티티 쪽에 NamedQuery를 작성하고 관리하는 것보다, JpaRepository 쪽에 JPQL을 입력하는 방법이 가능하다.

실무적으로는 이 쪽에 훨씬 편리하고 안전하다.

```java
    @Query("select m from Member m where m.username = :username and m.age = :age")
    List<Member> findUser(@Param("username") String username, @Param("age") int age);
```

- NamedQuery의 장점인, **부팅 시점의 JPQL 파싱**을 여기서도 제공할 수 있다.

- 메서드명에서 쿼리를 생성하기에는 로직이 좀 복잡해진 경우 (where 절에 2개 이상 바인딩) 부터 적극 사용한다.

DTO 형태로 조회하는 방법도 가능한데, JPQL 상에서 `new` 로 실제 생성자를 호출하는 형식을 취해야 해서 다소 귀찮다.

---

## 파라미터 바인딩

위치 기반, 이름 기반이 가능하다.

당연히 **이름 기반**으로 사용하는 게 정상이다.

`in` 절 SQL을 위해 **컬렉션 기반** 바인딩도 지원하는데, 실무에서도 많이 사용되니 익혀두자.

---

## 반환 타입

조회 쿼리에 대해 다양한 반환 타입을 자유롭게 지정할 수 있다.

- List, 객체, Optional<객체>

조회 건수가 0인 경우, 조회 건수가 의도한 바와 다른 경우에 대해 각 반환 타입의 동작이 상이하니 숙지해야 한다.

- `List` 반환형으로 받을 때 조회 결과가 없을 시, Empty List가 반환됨

- 객체로 받을 때 조회 결과가 없을 시, `NULL` 이 반환됨
  
  - 이 부분은 JPA 표준과 상이함
  
  - JPA 표준에서는 `NoResultException` 발생 - try catch 필요

---

## 페이징과 정렬

### 순수 JPA
