# 트랜잭션 이해

---

## 트랜잭션 - 개념 이해

데이터베이스를 굳이 사용하는 이유로 **트랜잭션**을 꼽을 수도 있다.

**트랜잭션**은?

- 데이터베이스에서 **하나의 거래를 안전하게 처리하도록 보장해주는 것**을 뜻한다.

- 하나의 거래는 여러 건의 데이터 변경을 한 세트로 묶고 다니는 경우가 대부분이다.
  
  - 대표적으로 계좌이체

- 이러한 경우에 대해, **모든 작업이 성공하거나, 아예 없었던 일로 처리하거나** 하는 것이 중요하다.

- 이걸 DB에서 트랜잭션으로 관리해준다.
  
  - 정상 반영을 `Commit`
  
  - 작업 중 하나라도 실패한 경우 원복시키는 것을 `Rollback`

### 트랜잭션 ACID

트랜잭션은 **원자성, 일관성, 격리성, 지속성**을 보장해야 한다.

- **원자성**: 트랜잭션 내에서 실행한 작업들은 모두 성공하거나 모두 실패

- **일관성**: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.

- **격리성**: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리해야 한다.
  
  - *원칙적으로* 동시에 같은 데이터를 수정하지 못하도록 한다.
  
  - 다만, 동시성 관련 **성능 이슈**가 발생하므로 **트랜잭션 격리 수준**은 따로 선택하고 관리한다.

- **지속성**: 트랜잭션이 성공적으로 끝나면 그 결과가 항상 기록되어야 한다.

### 트랜잭션 격리 수준 - Isolation level

나머지는 다 괜찮은데, **격리성**을 완전히 보장하려면 트랜잭션을 사실상 **순서대로 하나씩** 실행해야 한다. 그러면 성능이 극히 나빠질 수밖에 없다.

이에 따라 ANSI 표준은 트랜잭션 격리 수준을 4단계로 나누고 있다.

- **READ UNCOMMITED**: 커밋되지 않은 것까지 읽음

- **READ COMMITED**: 커밋된 것까지 읽음
  
  - 대부분 이 정도를 사용한다.

- **REPEATABLE READ**: 반복 가능한 읽기

- **SERIALIZABLE**: 직렬화

---

## 데이터베이스 연결 구조와 DB 세션

### 데이터베이스 연결 구조

사용자는 WAS나 DB 접근 툴 등의 클라이언트를 통해 데이터베이스 서버에 접근해, 커넥션을 맺는다.

이 때 데이터베이스 서버는 내부에 **세션**이라는 것을 만든다.

이후 커넥션을 통한 모든 요청은 이 세션을 통해서 실행된다.

- WAS 커넥션 풀에 커넥션이 10개 들어있다면, DB 세션도 10개 만들어진 것.

세션은 트랜잭션을 시작하고 종료하는 모든 과정을 주관한다.

사용자가 커넥션을 닫거나, DB 관리자가 강제로 종료할 때 세션은 종료된다.

### 트랜잭션 사용법

데이터 변경 쿼리(insert, update, delete)를 실행한 후 데이터베이스에 그 결과를 **실제로 반영**하려면, `commit`을 호출해야 한다. 반영하지 않으려면 `rollback`

즉, 커밋하기 전에는 데이터가 **임시로** 변경될 뿐이다.

- 해당 트랜잭션을 시작한 세션에서만 변경된 데이터로 보인다.

- **다른 세션에서는 변경된 데이터가 보이지 않는다.**

`rollback`을 호출하면, 트랜잭션을 시작하기 전 상태로 데이터가 모두 복구된다.

#### 커밋하지 않은 데이터를 다른 세션에서 조회한다면?

세션1이 임시로 변경 중인 데이터 (커밋 이전)를 세션2에서 조회해다가 자체 로직을 수행한다면,

이후에 세션1이 롤백이라도 하는 순간 서비스 전체 수준에서 **데이터 정합성**에 심각한 문제가 발생할 수 있다.

Transaction level 상에서 조절이 가능은 한데, 실제로 쓰는 일은 절대로 없다고 보면 된다.

---

## 트랜잭션 - 자동 커밋, 수동 커밋

### 자동 커밋

각각의 쿼리 실행 **직후에 자동으로** 커밋을 호출한다.

쿼리를 **하나하나** 실행할 때마다, 자동으로 커밋되므로 데이터 정합성 보장을 위한 **트랜잭션** 처리를 제대로 사용할 수 없다.

### 수동 커밋

보통은 자동 커밋 모드가 기본인 경우가 많다.

그래서, **수동 커밋 모드로 설정하는 것을 트랜잭션 시작**이라고 보기도 한다.

수동 커밋으로 설정하면, 로직이 완벽하게 끝나서 `commit`을 날리기 전까지는 데이터가 실제로 변경되지 않는다.

- 데이터 변경 쿼리가 `commit, rollback` 처리되지 않으면, DBMS가 자체적으로 타임아웃 처리해서 롤백시킨다.

- 모드를 한번 설정하면, 해당 세션에서는 계속 유지된다.

---

## 트랜잭션 실습

### 요약

- DB 세션 2개를 띄운 상태에서, `commit` 혹은 `rollback`을 쳤는지 여부에 따라 양쪽 세션에서 `select` 결과가 **다르게 나타남**을 확인

- `set autocommit false` 혹은 `true` 적용 확인

- 데이터 변경 쿼리 여러 건을 실행시키다가 중간에 오류가 발생한 케이스에서, `rollback` 처리함으로써 **데이터를 원복**시키는 시나리오

### 정리

#### 원자성

트랜잭션 **내**에서 실행한 작업들은, **마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패** 처리한다.

이러한 트랜잭션의 성질을 **원자성**이라고 한다.

- SQL 명령어를 마치 하나의 작업인 것처럼 처리할 수 있다. 

#### 오토 커밋과 트랜잭션 시작

트랜잭션 관리가 필요한 비즈니스 로직에서 오토 커밋이 적용되어 있으면 안 된다.

반드시 수동 커밋 모드를 사용해야 하고,

수동 커밋으로 전환하는 시점을 **트랜잭션의 시작**으로 판단하면 된다.

---

## DB 락

세션1에서 트랜잭션을 시작하고 데이터를 수정하는 동안, 세션2에서 동시에 같은 데이터를 **수정**하도록 방치한다면 트랜잭션의 **원자성**이 깨지게 된다.

이런 문제를 방지하기 위해, 특정 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 다른 세션에서 해당 데이터를 수정할 수 없도록 **막아야 한다**.

DBMS는 이를 해결하기 위해 **락**이라는 개념을 제공한다.

### DB Lock - 변경 SQL

- 특정 테이블의 특정 로우를 **업데이트**하려면, DB 세션은 기본적으로 해당 로우의 **락을 획득**해야 한다.

- 다른 세션에서 동일한 로우를 업데이트하고자 한다면, 락을 획득할 수 없기 때문에 **대기**한다.
  
  - 무한정은 아니고, 타임아웃 처리가 있다.

- 락을 걸었던 **트랜잭션이 종료되면 락이 반납**되고, 다른 세션에서 해당 락을 가져다가 로우를 업데이트할 수 있다.

### DB Lock - 조회 SQL

일반적으로는 **조회**에 대해 락을 걸지 않는다.

- 정확히는 락을 **획득하지 않고도** 데이터를 조회할 수 있다.

- 다른 세션에서 업데이트 중인 로우여도 **트랜잭션 이전 상태**의 로우는 맘껏 조회하는 식.

#### 조회와 락

데이터를 조회할 때도 락을 획득하고 싶을 때가 있다.

`select for update` 케이스가 대표적.

- **일단 데이터를 조회**한 다음, 애플리케이션에서 로직을 다 돌려서 **update, commit**할 때까지 해당 데이터가 **절대** 변화하면 안 되는 경우.

- 특히 돈과 관련된 중요한 계산일 때 사용된다.

`select * from member where member_id='memberA' for update;`

- 위와 같이 `for update` 를 `select` 문 뒤에 붙이게 된다.

---

## 트랜잭션 적용 - 1

### 요약

- (의도적으로) 트랜잭션 관리 없이 여러 번의 update 쿼리를 호출하는 서비스를 만들고, 로직 중간에 예외를 발생시키도록 함

- 이 때 예외 발생 시 데이터가 꼬이는 현상 테스트코드로 검증

- `@AfterEach` 적용하여 테스트데이터를 `delete`해 테스트 반복실행이 가능하도록 함
  
  - 보다 좋은 방법은 테스트를 하나의 트랜잭션으로 관리하여, 끝날 때마다 롤백시키는 것

---

## 트랜잭션 적용 - 2

애플리케이션에서 트랜잭션을 **어느 계층에 걸어야 할까?**

트랜잭션은 **비즈니스 로직이 있는 서비스 계층에서 시작**해야 한다.

- 해당 비즈니스 로직이 잘못됐을 때, 그대로 롤백시키기 위함

비즈니스 로직에서 트랜잭션을 관리하려면, 해당 트랜잭션을 사용하는 동안 **같은 커넥션이 반드시 유지**되어야 한다.

- 그래야 같은 세션에서 트랜잭션을 가져갈 수 있다.

### 커넥션과 세션

애플리케이션에서 **같은 커넥션을 유지하려면?**

- 가장 단순한 방법은 서비스 클래스에서 커넥션을 최초 1회 생성한 후, **DB 조회 로직마다 해당 커넥션을 파라미터로 계속 전달**해버리는 것.

- **모든 로직이 끝나면 서비스 클래스가 직접** commit 혹은 rollback 하고, 커넥션을 release 처리한다.

- 이러한 방법은, 서비스 계층에 비즈니스 로직이 아닌 커넥션 로직이 지나치게 많아져서 **너무 복잡해진다는 단점**이 있다.

- 커넥션을 유지하도록 코드를 유지관리하는 공수가 매우 큼

스프링은 이러한 문제를 어떻게 해결할까?


