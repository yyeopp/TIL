# 트랜잭션 이해

---

## 트랜잭션 - 개념 이해

데이터베이스를 굳이 사용하는 이유로 **트랜잭션**을 꼽을 수도 있다.

**트랜잭션**은?

- 데이터베이스에서 **하나의 거래를 안전하게 처리하도록 보장해주는 것**을 뜻한다.

- 하나의 거래는 여러 건의 데이터 변경을 한 세트로 묶고 다니는 경우가 대부분이다.
  
  - 대표적으로 계좌이체

- 이러한 경우에 대해, **모든 작업이 성공하거나, 아예 없었던 일로 처리하거나** 하는 것이 중요하다.

- 이걸 DB에서 트랜잭션으로 관리해준다.
  
  - 정상 반영을 `Commit`
  
  - 작업 중 하나라도 실패한 경우 원복시키는 것을 `Rollback`

### 트랜잭션 ACID

트랜잭션은 **원자성, 일관성, 격리성, 지속성**을 보장해야 한다.

- **원자성**: 트랜잭션 내에서 실행한 작업들은 모두 성공하거나 모두 실패

- **일관성**: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.

- **격리성**: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리해야 한다.
  
  - *원칙적으로* 동시에 같은 데이터를 수정하지 못하도록 한다.
  
  - 다만, 동시성 관련 **성능 이슈**가 발생하므로 **트랜잭션 격리 수준**은 따로 선택하고 관리한다.

- **지속성**: 트랜잭션이 성공적으로 끝나면 그 결과가 항상 기록되어야 한다.

### 트랜잭션 격리 수준 - Isolation level

나머지는 다 괜찮은데, **격리성**을 완전히 보장하려면 트랜잭션을 사실상 **순서대로 하나씩** 실행해야 한다. 그러면 성능이 극히 나빠질 수밖에 없다.

이에 따라 ANSI 표준은 트랜잭션 격리 수준을 4단계로 나누고 있다.

- **READ UNCOMMITED**: 커밋되지 않은 것까지 읽음

- **READ COMMITED**: 커밋된 것까지 읽음
  
  - 대부분 이 정도를 사용한다.

- **REPEATABLE READ**: 반복 가능한 읽기

- **SERIALIZABLE**: 직렬화

---

## 데이터베이스 연결 구조와 DB 세션

### 데이터베이스 연결 구조

사용자는 WAS나 DB 접근 툴 등의 클라이언트를 통해 데이터베이스 서버에 접근해, 커넥션을 맺는다.

이 때 데이터베이스 서버는 내부에 **세션**이라는 것을 만든다.

이후 커넥션을 통한 모든 요청은 이 세션을 통해서 실행된다.

- WAS 커넥션 풀에 커넥션이 10개 들어있다면, DB 세션도 10개 만들어진 것.

세션은 트랜잭션을 시작하고 종료하는 모든 과정을 주관한다.

사용자가 커넥션을 닫거나, DB 관리자가 강제로 종료할 때 세션은 종료된다.

### 트랜잭션 사용법

데이터 변경 쿼리(insert, update, delete)를 실행한 후 데이터베이스에 그 결과를 **실제로 반영**하려면, `commit`을 호출해야 한다. 반영하지 않으려면 `rollback`

즉, 커밋하기 전에는 데이터가 **임시로** 변경될 뿐이다.

- 해당 트랜잭션을 시작한 세션에서만 변경된 데이터로 보인다.

- **다른 세션에서는 변경된 데이터가 보이지 않는다.**

`rollback`을 호출하면, 트랜잭션을 시작하기 전 상태로 데이터가 모두 복구된다.

#### 커밋하지 않은 데이터를 다른 세션에서 조회한다면?

세션1이 임시로 변경 중인 데이터 (커밋 이전)를 세션2에서 조회해다가 자체 로직을 수행한다면,

이후에 세션1이 롤백이라도 하는 순간 서비스 전체 수준에서 **데이터 정합성**에 심각한 문제가 발생할 수 있다.

Transaction level 상에서 조절이 가능은 한데, 실제로 쓰는 일은 절대로 없다고 보면 된다.

---

## 트랜잭션 - 자동 커밋, 수동 커밋

### 자동 커밋

각각의 쿼리 실행 **직후에 자동으로** 커밋을 호출한다.

쿼리를 **하나하나** 실행할 때마다, 자동으로 커밋되므로 데이터 정합성 보장을 위한 **트랜잭션** 처리를 제대로 사용할 수 없다.

### 수동 커밋

보통은 자동 커밋 모드가 기본인 경우가 많다.

그래서, **수동 커밋 모드로 설정하는 것을 트랜잭션 시작**이라고 보기도 한다.

수동 커밋으로 설정하면, 로직이 완벽하게 끝나서 `commit`을 날리기 전까지는 데이터가 실제로 변경되지 않는다.

- 데이터 변경 쿼리가 `commit, rollback` 처리되지 않으면, DBMS가 자체적으로 타임아웃 처리해서 롤백시킨다.

- 모드를 한번 설정하면, 해당 세션에서는 계속 유지된다.

---


