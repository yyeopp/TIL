# 스프링과 문제 해결 - 트랜잭션

---

## 문제점들

### 애플리케이션 구조

가장 일반적인 애플리케이션 구조는 다음과 같다.

- 프레젠테이션 계층
  
  - `@Controller`
  
  - UI 관련 처리 담당
  
  - 웹 요청과 응답
  
  - 사용자 요청 검증
  
  - 주로 서블릿, HTTP 같은 웹 기술이나 스프링 MVC 사용

- 서비스 계층
  
  - `@Service`
  
  - 비즈니스 로직을 담당
  
  - 순수 자바 코드

- 데이터 접근 계층
  
  - `@Repository`
  
  - 실제 데이터베이스에 접근하는 코드
  
  - JDBC, JPA, File, Redis, MongoDB 등

### 순수한 서비스 계층?

가장 중요한 곳은? **서비스 계층**이다.

UI 디자인이 변화하고, 데이터 저장 기술이 변화해도 **비즈니스 로직**은 최대한 변화하지 않아야 한다.

그러려면 서비스 계층을 **특정 기술에 종속적이지 않게** 개발할 필요가 있다.

- 기술 종속적인 부분은 나머지 계층에서 최대한 가지고 간다.
  
  - 프레젠테이션 계층에서 UI 관련 기술의 변화를 다 커버해주고,
  
  - 데이터 접근 계층에서 데이터 접근 기술의 변화를 커버해주도록.
    
    - 서비스 계층이 데이터에 직접 접근하는 게 아니라, 데이터 접근 계층에서 **제공하는 인터페이스**에만 의존하도록 구성

- 서비스 계층이 기술 독립적일 때, **유지보수**하기도 쉽고 **테스트**도 쉽다.

- 향후 구현 기술이 변경될 때 **영향도**도 최소화할 수 있다.

### 문제점들

지금까지 실습하면서 작성한 코드의 문제점은 무엇일까?

- (특히 트랜잭션을 적용한 코드에서) **서비스 로직이 JDBC 기술에 지나치게 종속적이다.**
  
  - 결과적으로 비즈니스 로직보다도 트랜잭션 처리 코드가 더 많다.
  
  - 데이터 접근 기술이 JDBC에서 다른 것으로 변경되면 비즈니스 로직은 모두 재개발 대상

**정리하면**, 아래와 같이 3가지.

- 트랜잭션 문제

- 예외 누수 문제

- JDBC 반복 문제

#### 트랜잭션 문제

##### JDBC 구현 기술이 서비스 계층에 누수되는 문제

구현 기술을 변경해도 **서비스 계층 코드를 최대한 유지**할 수 있어야 하는데,

**트랜잭션 구현하느라** JDBC 코드가 서비스 계층으로 와장창 쏟아진 모습

##### 트랜잭션 동기화 문제

같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다.

개발 단계에서 혼동의 여지가 매우 크다.

##### 트랜잭션 적용 반복 문제

서비스 계층에서 Connection을 생성하고 release 하는 try - catch - finally 코드가 계속 반복된다.

#### 예외 누수

데이터 접근 계층의 JDBC 예외가, 서비스 계층으로 전파된다.

서비스 계층에서 `SQLException`을 잡든가 던져야하는데, 해당 예외는 JDBC 고유 Exception이므로 서비스 계층의 유지보수성이 떨어진다.

#### JDBC 반복 문제

`MemberRepository` 코드는 순수한 JDBC를 사용해서 만들었는데, 유사한 코드의 반복이 무척 많다.

---

## 트랜잭션 추상화

지금까지 예제코드 서비스의 트랜잭션 관련 코드가 **JDBC 기술에 완전히 의존적**이다.

JPA 같은 다른 기술로 변경하려면, 서비스 계층의 트랜잭션 관련 코드가 모두 변경되어야 한다.

- Repository 계층이라면 DB 접근기술 변경 시 변화가 있어도 이해할 수 있다.

- Service 계층이 영향이 받는 것은 **단일 책임 원칙**이 위배된 모습.

### 트랜잭션 추상화

위 문제를 해결하기 위한 작업이 트랜잭션 추상화.

사실 대단히 복잡할 것 없이, **인터페이스** 하나 만들어서 서비스 계층에서 사용하고, DB 접근 기술에 따라 **구현체만 갈아 끼우면 된다.**

- 서비스가 특정 트랜잭션 기술에 직접 의존하는 것이 아닌,

- `TxManager` 라는 추상화된 인터페이스를 예시로 만들어서 거기에만 의존하도록 구성.

- 클라리언트인 서비스가 인터페이스에 의존, DI로 적절한 구현체를 주입.
  
  - **OCP** 원칙 준수 가능

### 스프링의 트랜잭션 추상화

당연히 스프링은 위와 같은 인터페이스를 제공하고 있다.

우리는 스프링이 제공하는 `PlatformTransactionManager` 를 사용하면 된다.

- 트랜잭션 시작, 커밋, 롤백 기능 모두 제공

- 우리는 적당한 구현체만 갖다 쓰면 된다.
  
  - `DataSourceTransactionManager`, `JpaTransactionManager` 등등이 이미 만들어져 있다.

보통 `PlatformTransactionManager` 이하 구현체들을 **트랜잭션 매니저**라고 통칭하게 된다.

---

## 트랜잭션 동기화

### 리소스 동기화

트랜잭션을 유지하려면, 트랜잭션의 시작부터 끝까지 **동일한 커넥션을 유지**해야 한다.

- 이전 예제에서는 커넥션을 아예 파라미터로 전달하면서 다녔다.

### 트랜잭션 매니저와 트랜잭션 동기화 매니저

스프링은 **트랜잭션 동기화 매니저**를 제공한다.

- 쓰레드 로컬(`ThreadLocal`) 을 사용해서 커넥션을 동기화해주는 기능을 가지고 있다.

- 쓰레드 로컬에 대한 내용은 스킵. 멀티스레드 환경에서도 쓰레드 독립성을 유지해주기 위한 환경이라고 보면 된다.

트랜잭션 동기화 매너지는 **쓰레드 로컬**을 사용하기 때문에, **멀티쓰레드 상황에서도 커넥션을 동기화**할 수 있다.

#### 동작 방식

1. 서비스 로직에서 트랜잭션 매니저에게 트랜잭션 시작을 지시한다.

2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고, 트랜잭션을 시작한다.
   
   - `set autocommit true` 등등의 처리를 알아서 해준다.
   
   - DB 접근기술이 무엇인지에 대해 독립적이다. (**트랜잭션 추상화**)

3. 트랜잭션 매너지는 트랜잭션을 시작한 커넥션을 **트랜잭션 동기화 매니저**에 보관한다.

4. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 작업한다.
   
   - 일일이 파라미터로 들고 다니거나 하지 않아도 된다.

5. 트랜잭션이 종료되면 트랜잭션 매니저가 **동기화 매니저에 보관된 커넥션**을 통해 트랜잭션을 종료하고, 커넥션도 반환한다.

#### 참고

쓰레드 로컬을 사용하면, 각각의 쓰레드마다 **별도의 저장소가 부여**된다.

해당 쓰레드만 해당 데이터에 접근할 수 있기 때문에, 트랜잭션 간의 **고립성**이 보장된다.

---

## 트랜잭션 문제 해결 - 트랜잭션 매니저

### 예제 코딩 요약

- 서비스 계층의 코드가 `DataSource` (JDBC 기술) 에 직접 의존하지 않고, `PlatformTransactionManager`에 의존하면서 DB에 접근하도록 함
  
  - `con` 을 직접 집어넣지 않아도`commit`, `rollback` 지원
  
  - `finally` 절에서 커넥션을 직접 닫지 않아도 됨

- 리포지토리에서도 `Connection` 을 가져올 때 `DataSource`에서 직접 커넥션을 가져오지 않고, `DataSourceUtils.getConnection()` 를 통해서 커넥션을 가져옴
  
  - **트랜잭션 동기화 매니저가 관리하는 커넥션**이 있으면 해당 커넥션을 반환하고,
  
  - 없는 경우 새로운 커넥션을 생성해서 반환해주는 메서드

- 리포지토리가 `Connection` 을 `close` 할 때, `DataSourceUtils.releaseConnection()` 을 통해서 커넥션을 놓도록 변경
  
  - 트랜잭션 동기화 매니저가 관리하는 커넥션이면(**서비스 계층에서 시작해서 관리 중인 커넥션이면**) 닫지 않고 유지
  
  - 리포지토리가 직접 생성했던 커넥션이면 (**서비스 계층의 로직과 무관하게 리포지토리에서 시작한 `TransactionStatus` 이면**) 실제로 닫아줌

- 테스트코드는 서비스 계층으로 주입해줄 `PlatformTransactionManager`를 `DataSourceTransactionManager` 구현체로 생성해서 전달해줌
  
  - `DataSource` 주입하는 것 잊으면 안 됨

- 결과적으로, 서비스 계층의 코드에서 변화하는 점은
  
  - 서비스 로직에서 단일한 커넥션이 유지되도록 파라미터로 `con` 을 들고다니던 부분이 개선됨
    
    - `TransactionManager` 가 `status` 개념 하에 **쓰레드로컬에서 커넥션을 들고 다니면서 단일 커넥션을 보장**
  
  - 서비스 로직에서 커넥션을 생성하고 종료하기 위해 반복하여 작성하던 코드가 대폭 제거됨
    
    - `TransactionManager` 가 트랜잭션 시작, 커밋, 롤백, 종료 등을 관리해줌
  
  - 서비스 로직에서 특정 DB 접근 기술(JDBC)에 의존하지 않고, **추상화된 트랜잭션**에 의존한다.
    
    - 구현체를 바꾸더라도 서비스 코드를 유지할 수 있다.
    
    - JDBC를 JPA로 바꿀 때, 리포지토리와 테스트코드만 바꾸면 된다는 뜻
    
    - 단, `SQLException` 부분은 아직 예외..

### 트랜잭션 매니저의 전체적인 동작 흐름

1. 클라이언트 요청으로 서비스 로직 실행

2. 서비스 계층에서 `transactionManager.getTransaction()`을 호출해서 트랜잭션 시작
   
   - 트랜잭션 매니저가 내부적으로 DataSouce 를 사용해 커넥션을 생성하고,
   
   - 커넥션을 수동 커밋모드로 변경해서 실제 트랜잭션을 시작

3. 트랜잭션 매너지가 커넥션을 **트랜잭션 동기화 매니저**에 보관

4. 트랜잭션 동기화 매니저가 **스레드 로컬**에 커넥션을 보관

5. 서비스가 리포지토리의 메서드를 호출

6. 리포지토리는 `DataSourceUtils.getConnection()`을 통해, 트랜잭션 동기화 매니저에 **보관된 커넥션을 꺼내서** 사용.
   
   - 서비스 메서드 전체에 걸쳐서 파라미터 전달 없이 같은 커넥션을 사용

7. 리포지토리는 획득한 커넥션을 사용해 SQL을 데이터베이스에 전달하고 실행

8. 로직이 끝나면, 서비스는 트랜잭션을 커밋하거나 롤백하고

9. 전체 리소스를 정리
   
   - **트랜잭션 동기화 매니저 정리 (쓰레드 로컬 정리)**
   
   - 자동 커밋모드로 변경해서 트랜잭션 실질적 종료 처리
   
   - 커넥션을 실제로 close 처리 (커넥션 풀 반환)

---

## 트랜잭션 문제 해결 - 트랜잭션 템플릿

지금까지 작성된 트랜잭션 사용 로직에서 반복되는 코드 패턴을 확인할 수 있다.

- try-catch로 트랜잭션 시작, 로직 실행, 성공 커밋, 실패 롤백

- 이 중에 달라지는 부분은 사실 비즈니스 로직 뿐이다.

이거를 **템플릿 콜백 패턴**을 활용해서 해결할 수 있다.

### 트랜잭션 템플릿

스프링에서는 `TransactionTemplate` 라는 **템플랫 콜백 패턴을 적용한 템플릿 클래스**를 제공하고 있다.

`TransactionTemplate`를 사용하려면 `TransactionManager`가 필요하다. 생성자 수준에서 `TransactionManager`를 주입하면 된다.

- `TransactionManager`를 템플릿으로 감싸서 사용하는 모양새

결과적으로, 트랜잭션을 시작하고 커밋하거나 롤백하는 코드를 모두 제거할 수 있게 된다.

#### 트랜젝션 템플릿 기본 동작

- 비즈니스 로직이 정상 수행되면, 커밋

- **언체크 예외**가 발생하면 롤백. 그 외의 경우 커밋
  
  - **체크 예외**는 커밋한다는 뜻

#### 정리

트랜잭션 템플릿을 통해 **트랜잭션 처리용 반복적인 코드**를 제거할 수 있게 된다.

하지만 여전히 서비스 로직 내부에 트랜잭션 처리 로직이 남아 있다는 한계는 남는다.

비즈니스 로직과 트랜잭션 처리 로직이 한 곳에 남아있음으로써, 유지보수가 어려워지고 두 개의 관심사가 하나의 클래스에서 처리되는 결과를 만든다.

서비스 로직에, 가급적 **핵심 비즈니스 로직만 남길 수 있도록** 정리가 필요하다.

---

## 트랜잭션 문제 해결 - 트랜잭션 AOP 이해

서비스 계층에 순수한 비즈니스 로직만 남기기 위해, 스프링 AOP로 프록시를 도입한다.

### 프록시를 통한 문제 해결

**트랜잭션 프록시**라는 계층을 서비스 앞에다가 만들어두고,

클라이언트가 프록시를 호출해서 트랜잭션을 처리하도록 한다.

비즈니스 로직을 처리하는 서비스 객체를 **트랜잭션 코드로부터 분리시킬 수 있다.**




