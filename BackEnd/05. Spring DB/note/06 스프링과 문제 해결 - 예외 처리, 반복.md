# 스프링과 문제 해결 - 예외 처리, 반복

---

## 체크 예외와 인터페이스

`@Transactional`을 적용함으로써 기존 예제 코드도 많이 개선됐지만,

여전히 서비스 계층에 **예외가 누수**되어 있는 상황이다.

- `SQLException`을 서비스 계층에서 의존하고 있다.

- 서비스 계층에서는 어차피 `SQLException` 처리가 불가능하다. 

앞서 배운 내용을 참고하여, 해당 예외를 **런타임 예외로 전환**하는 방식으로 개선해보자.

이를 위해 서비스가 `Repository` 에 직접 의존하는 것이 아닌,

- `Repository` 클래스를 인터페이스로 만들고,

- **서비스에서는 그 구현체를 주입받아 사용**함으로써 특정 기술에 대한 의존성을 제거한다.

### 체크 예외와 인터페이스

하지만 현재 코드에서는 이런 인터페이스를 만드는 게 별다른 의미가 없다.

`SQLException` 이 **체크 예외**이고, 따라서 해당 인터페이스와 그 구현체는 체크 예외를 계속 던지고 다녀야 하기 때문

- **인터페이스**가 **순수**하다고 할 수 없게 된다.

- 참고로 구현 클래스의 메서드에서 선언할 수 있는 예외는, 부모 타입에서 던진 예외와 같거나 하위 타입이어야 한다.

#### 특정 기술에 종속되는 인터페이스

구현 기술을 쉽게 변경하기 위해 인터페이스를 도입한다는 취지에 무색하게, 해당 인터페이스는 이미 특정 구현 기술에 종속적이다.

이건 순수한 인터페이스라고 할 수 없다.

- JDBC가 아닌 다른 기술을 사용하려면 인터페이스 변경이 불가피하다.

#### 런타임 예외와 인터페이스

런타임 예외를 사용한다면 이런 부분에서 자유로워질 수 있다.

인터페이스가 특정 기술에 종속적이지 않을 수 있다.

---

## 런타임 예외 적용

### 예제 코드 요약

- `MyDbException` 이라는 런타임 예외를 직접 만들고, `Repository` 인터페이스를 만든다.
  
  - 해당 인터페이스는 `SQLException` 을 던지지 않도록 한다.

- `Repository` 구현 클래스에서, `SQLException`을 잡아서 직접 `MyDbException` 으로 **변환**시켜준다.
  
  - 이로써 메서드 선언부에서 `SQLException` 을 제거할 수 있고,
  
  - 인터페이스를 `implements` 할 수 있다.

- `MemberService` 를 만들어진 **인터페이스**에 의존하도록 바꾸면서, `SQLException`을 전혀 쳐다보지 않을 수 있다.

#### 예외 전환 시 기존 예외를 꼭 포함시키자

생성자를 통해 `Throwable cause` 를 포함시켜주지 않고 **예외 전환** 시켜버리면, 진짜 원인이 되는 예외가 로그에 나타나지 않는 일이 발생한다.

#### 정리

체크 예외를 **런타임 예외로 변환**함으로써, 인터페이스와 서비스 계층의 **순수성**을 유지할 수 있다.

#### 남은 문제

리포지토리에서 넘어오는 특정한 예외에 대해 **복구**를 시도하고 싶을 수 있다.

무조건 `MyDbException` 으로 잡아서 처리하면 그런 것이 어렵다.

예외를 구분해서 처리하는 방법은?

---

## 데이터 접근 예외 직접 만들기

DB에서 PK 중복 같은 오류가 발생했을 때, JDBC 드라이버가 뱉는 `SQLException` 은 `errorCode` 를 함께 가지고 있다.

- 예시로 H2 데이터베이스에서 PK 중복 오류 코드는 23505.

- `SQLException` 내부의 errorCode 를 활용해서, 데이터베이스에 어떤 문제가 발생했는지 확인하고

- 더 나아가 **서비스 로직에 활용**할 수 있다.

그렇다고 해서 `SQLException` 을 직접 서비스 계층으로 들고와서 처리하면, 서비스 계층의 순수성이 무너진다.

이를 해결하기 위해, **리포지토리에서 오류코드를 확인하여 예외를 변환**시킨다.

- `MyDbException` 을 상속 받아서`MyDuplicateKeyException`을 만든다. 
- 이로써 DB 관련 예외 **계층**을 구성한다.
- 해당 예외는 **런타임** 예외고, 특정 기술에 종속적이지 않기 때문에 서비스 계층의 순수성을 유지시켜줄 수 있다.

### 예제 코드 요약

- Repository 에서 DB 오류코드를 인지해서 **런타임 예외**로 변환시키고 던진다.

- Service 에서는 커스터 런타임 예외를 잡아서 서비스 로직을 돌린다.
  
  - Service 계층은 특정 DB 접근 기술에 종속적이지 않게 된다.

- 만약 Service 계층에서 **DB 오류코드를 잡아서** 로직을 돌렸다면?
  
  - DB 오류코드는 **DBMS마다 전부 다르기 때문에**, 서비스 계층의 순수성이 유지될 수 없다.

### 남은 문제

DB 오류코드로부터 서비스 계층을 보호하는 데에는 성공했으나,

리포지토리가 특정 DBMS에 의존하는 것 또한 큰 문제다.

- 키 중복 오류 코드는 H2에서 23505, MySQL에서 1062

이 부분도 개선이 필요하다.

- 스프링이 이걸 해결해준다.

---

## 스프링 예외 추상화 이해

스프링은 **데이터 접근과 관련된 예외를 추상화**하여 제공한다.

### 스프링 데이터 접근 예외 계층

스프링은 데이터 접근 계층에서 발생하는 예외들을 분류 및 정리하여, **일관된 계층 구조**로 제공한다.

각 예외들은 특정 기술에 종속적이지 않기 때문에, **서비스 계층에서도** 스프링이 제공하는 예외를 사용할 수 있다.

- JDBC를 사용하든, JPA를 사용하든 실제 발생하는 DB접근 예외가 스프링이 제공하는 예외로 **자동 변환**된다.

스프링 DB 접근 예외의 최상위는 `DataAccessException`이다.

- `RuntimeException`을 상속 받았기 때문에,

- 스프링이 제공하는 데이터 접근 예외는 **모두 런타임 예외**이다.

`DataAccessException`은 `NonTransient` 예외와 `Transient`예외로 구분된다.

- `Transient`는 **일시적**이라는 뜻.
  
  - 동일한 SQL을 재시도했을 떄 성공할 가능성이 있다.
  
  - 쿼리 타임아웃, **락** 등의 오류

- `NonTransient`는 **일시적이지 않다**는 뜻.
  
  - 같은 SQL을 재실행해도 무조건 실패한다.
  
  - SQL 문법 오류 등.

### 스프링이 제공하는 예외 변환기

스프링은 DB에서 실제 발생한 오류 코드를, 스프링이 정의한 DB 접근 예외로 **자동 변환**해주는 **변환기**를 제공한다.
