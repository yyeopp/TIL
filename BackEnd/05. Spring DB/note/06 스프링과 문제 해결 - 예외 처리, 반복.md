# 스프링과 문제 해결 - 예외 처리, 반복

---

## 체크 예외와 인터페이스

`@Transactional`을 적용함으로써 기존 예제 코드도 많이 개선됐지만,

여전히 서비스 계층에 **예외가 누수**되어 있는 상황이다.

- `SQLException`을 서비스 계층에서 의존하고 있다.

- 서비스 계층에서는 어차피 `SQLException` 처리가 불가능하다. 

앞서 배운 내용을 참고하여, 해당 예외를 **런타임 예외로 전환**하는 방식으로 개선해보자.

이를 위해 서비스가 `Repository` 에 직접 의존하는 것이 아닌,

- `Repository` 클래스를 인터페이스로 만들고,

- **서비스에서는 그 구현체를 주입받아 사용**함으로써 특정 기술에 대한 의존성을 제거한다.

### 체크 예외와 인터페이스

하지만 현재 코드에서는 이런 인터페이스를 만드는 게 별다른 의미가 없다.

`SQLException` 이 **체크 예외**이고, 따라서 해당 인터페이스와 그 구현체는 체크 예외를 계속 던지고 다녀야 하기 때문

- **인터페이스**가 **순수**하다고 할 수 없게 된다.

- 참고로 구현 클래스의 메서드에서 선언할 수 있는 예외는, 부모 타입에서 던진 예외와 같거나 하위 타입이어야 한다.

#### 특정 기술에 종속되는 인터페이스

구현 기술을 쉽게 변경하기 위해 인터페이스를 도입한다는 취지에 무색하게, 해당 인터페이스는 이미 특정 구현 기술에 종속적이다.

이건 순수한 인터페이스라고 할 수 없다.

- JDBC가 아닌 다른 기술을 사용하려면 인터페이스 변경이 불가피하다.

#### 런타임 예외와 인터페이스

런타임 예외를 사용한다면 이런 부분에서 자유로워질 수 있다.

인터페이스가 특정 기술에 종속적이지 않을 수 있다.

---

## 런타임 예외 적용

### 예제 코드 요약

- `MyDbException` 이라는 런타임 예외를 직접 만들고, `Repository` 인터페이스를 만든다.
  
  - 해당 인터페이스는 `SQLException` 을 던지지 않도록 한다.

- `Repository` 구현 클래스에서, `SQLException`을 잡아서 직접 `MyDbException` 으로 **변환**시켜준다.
  
  - 이로써 메서드 선언부에서 `SQLException` 을 제거할 수 있고,
  
  - 인터페이스를 `implements` 할 수 있다.

- `MemberService` 를 만들어진 **인터페이스**에 의존하도록 바꾸면서, `SQLException`을 전혀 쳐다보지 않을 수 있다.

#### 예외 전환 시 기존 예외를 꼭 포함시키자

생성자를 통해 `Throwable cause` 를 포함시켜주지 않고 **예외 전환** 시켜버리면, 진짜 원인이 되는 예외가 로그에 나타나지 않는 일이 발생한다.

#### 정리

체크 예외를 **런타임 예외로 변환**함으로써, 인터페이스와 서비스 계층의 **순수성**을 유지할 수 있다.

#### 남은 문제

리포지토리에서 넘어오는 특정한 예외에 대해 **복구**를 시도하고 싶을 수 있다.

무조건 `MyDbException` 으로 잡아서 처리하면 그런 것이 어렵다.

예외를 구분해서 처리하는 방법은?

---

## 데이터 접근 예외 직접 만들기

DB에서 PK 중복 같은 오류가 발생했을 때, JDBC 드라이버가 뱉는 `SQLException` 은 `errorCode` 를 함께 가지고 있다.

- 예시로 H2 데이터베이스에서 PK 중복 오류 코드는 23505.

- `SQLException` 내부의 errorCode 를 활용해서, 데이터베이스에 어떤 문제가 발생했는지 확인하고

- 더 나아가 **서비스 로직에 활용**할 수 있다.

그렇다고 해서 `SQLException` 을 직접 서비스 계층으로 들고와서 처리하면, 서비스 계층의 순수성이 무너진다.

이를 해결하기 위해, **리포지토리에서 오류코드를 확인하여 예외를 변환**시킨다.

- `MyDbException` 을 상속 받아서`MyDuplicateKeyException`을 만든다. 
- 이로써 DB 관련 예외 **계층**을 구성한다.
- 해당 예외는 **런타임** 예외고, 특정 기술에 종속적이지 않기 때문에 서비스 계층의 순수성을 유지시켜줄 수 있다.

### 예제 코드 요약

- Repository 에서 DB 오류코드를 인지해서 **런타임 예외**로 변환시키고 던진다.

- Service 에서는 커스터 런타임 예외를 잡아서 서비스 로직을 돌린다.
  
  - Service 계층은 특정 DB 접근 기술에 종속적이지 않게 된다.

- 만약 Service 계층에서 **DB 오류코드를 잡아서** 로직을 돌렸다면?
  
  - DB 오류코드는 **DBMS마다 전부 다르기 때문에**, 서비스 계층의 순수성이 유지될 수 없다.

### 남은 문제

DB 오류코드로부터 서비스 계층을 보호하는 데에는 성공했으나,

리포지토리가 특정 DBMS에 의존하는 것 또한 큰 문제다.

- 키 중복 오류 코드는 H2에서 23505, MySQL에서 1062

이 부분도 개선이 필요하다.

- 스프링이 이걸 해결해준다.

---

## 스프링 예외 추상화 이해

스프링은 **데이터 접근과 관련된 예외를 추상화**하여 제공한다.

### 스프링 데이터 접근 예외 계층

스프링은 데이터 접근 계층에서 발생하는 예외들을 분류 및 정리하여, **일관된 계층 구조**로 제공한다.

각 예외들은 특정 기술에 종속적이지 않기 때문에, **서비스 계층에서도** 스프링이 제공하는 예외를 사용할 수 있다.

- JDBC를 사용하든, JPA를 사용하든 실제 발생하는 DB접근 예외가 스프링이 제공하는 예외로 **자동 변환**된다.

스프링 DB 접근 예외의 최상위는 `DataAccessException`이다.

- `RuntimeException`을 상속 받았기 때문에,

- 스프링이 제공하는 데이터 접근 예외는 **모두 런타임 예외**이다.

`DataAccessException`은 `NonTransient` 예외와 `Transient`예외로 구분된다.

- `Transient`는 **일시적**이라는 뜻.
  
  - 동일한 SQL을 재시도했을 떄 성공할 가능성이 있다.
  
  - 쿼리 타임아웃, **락** 등의 오류

- `NonTransient`는 **일시적이지 않다**는 뜻.
  
  - 같은 SQL을 재실행해도 무조건 실패한다.
  
  - SQL 문법 오류 등.

### 스프링이 제공하는 예외 변환기

스프링은 DB에서 실제 발생한 오류 코드를, 스프링이 정의한 DB 접근 예외로 **자동 변환**해주는 **변환기**를 제공한다.

- `SQLErrorCodeSQLExceptionTranslator`라고 하는 엄청 긴 클래스를 스프링이 제공해준다.
  
  - DBMS 종류가 무엇이든, 오류코드를 스프링 DB예외로 번역해주는 클래스에 해당한다.

- 위 클래스의 `translate()` 메서드를 직접 사용해보면, 정말로 단순 `SQLException` with `errorCode` 가 스프링 DB 예외로 **변환**되는 모습을 확인 가능하다.
  
  - `translate()` 메서드의 리턴값이 스프링 DB 예외 최상위인 `DataAccessException`이라는 점도 유념

스프링은 각 DB에서 제공하는 SQL ErrorCode를 어떻게 인지해서 변환해주는걸까?

- 스프링 패키지를 뒤져보면 `sql-error-code.xml` 이라는 파일을 확인 가능하다.

- DBMS 별 오류코드를 나열해두고, 각각이 무슨 예외인지 적어둔 파일

- 10개 이상의 RDB를 지원하고 있다.

### 예제 코드 요약

- Repository 에서 `SQLException`을 직접 잡아서 처리했던 것을,

- `SQLExceptionTranslator` 를 사용해서 스프링 DB 예외로 변환해서 던져주는 쪽으로 바꾼다.

- 서비스 계층에서 **DB 접근 기술에 독립적인 런타임 예외**에 의존하게 되는 것이 여전하면서도,

- **Repository에서도** DB 접근 기술에 대한 종속성을 제거할 수 있다.

---

## JDBC 반복 문제 해결 - JdbcTemplate

**서비스 계층의 순수함을 유지**한다는 목표는 달성했다.

마지막으로 해결할 문제는 **리포지토리의 반복되는 코드**

- 커넥션 조회, 커넥션 동기화

- SQL 파라미터 바인딩

- 쿼리 실행

- 결과 바인딩

- 예외 발생 시 스프링 예외 변환기 실행

- 리소스 종료

스프링은 JDBC 반복 문제를 해결하기 위해, `JdbcTemplate`라는 탬플릿 기능을 제공한다.

- 위에서 반복된다고 언급된 코드를 모두 자동화시켜준다.

- Repository 에서 `try-catch` 처리했던 모든 코드가 사라진다.

- **트랜잭션을 위한 커넥션 동기화**나 **DB 오류코드 자동 변환**까지 제공한다.

---

## 정리

여기까지 완성된 코드에서 확인 가능한 장점

#### 서비스 계층의 순수성

**트랜잭션 추상화**와 **트랜잭션 AOP** 덕분에, 서비스 계층의 순수성을 최대한 유지하면서도 **트랜잭션**을 사용할 수 있다.

스프링이 제공하는 **예외 추상화**와 **예외 변환기** 덕분에, 데이터 접근 기술에 독립적인 서비스 계층을 구성할 수 있다.

서비스 계층이 리포지토리 **인터페이스**에 의존하면서, 리포지토리의 구현 기술이 변경되더라도 서비스 계층을 유지할 수 있다.

#### 리포지토리 계층의 반복 제거

`JdbcTemplate`를 사용함으로써, JDBC 사용으로 인한 반복 코드가 **대부분 제거**된다.
