# 자바 예외 이해

---

## 예외 계층

스프링이 제공하는 **예외의 추상화**를 이해하기 위한 파트

### 예외 계층 전반

- `Object` : 예외도 객체다.

- `Throwable` : 최상위 예외로, 하위에 `Exception` 과 `Error`

- `Error` : 메모리 부족 같이 애플리케이션 수준에서 복구 불가능한 시스템 예외. 개발자가 이걸 잡아서 처리하려고 하면 안 된다.
  
  - 예외를 `catch` 할 때 `Throwable`을 잡아버리면 `Error` 까지도 잡아버리기 때문에, `Exception` 까지만 잡아야 한다.
  
  - `Error` 도 **언체크 예외**다.

- `Exception` : **체크 예외**.
  
  - 애플리케이션 로직에서 사용할 수 있는 **실질적인 최상위 예외**.
  
  - `RuntimeException`을 제외하고, `Exception`의 자식은 모두 **체크 예외**다.

- `RuntimeException` 은 `Exception`의 자식이지만, 예외적으로 **언체크 예외**에 해당한다.
  
  - 그 자식들을 **런타임 예외**라고 흔히 부른다.

---

## 예외 기본 규칙

예외를 잡아서 처리하거나, 처리할 수 없으면 밖으로 던지거나.

### 예외 처리

2가지 기본 규칙을 기억하면 된다.

- 예외는 **잡아서 처리하거나 던져야 한다.**

- 예외를 잡거나 던질 때는, 명시적으로 지정한 예외 뿐만 아니라 **그 자식들도 함께** 처리해야 한다.

#### 예외가 끝까지 처리되지 못하고 계속 던져지면?

자바 `main()` 쓰레드는 예외를 처리하지 못한다.

`main()`까지 예외가 도착하면, 예외 로그를 출력하면서 **시스템이 아예 종료된다.**

다만 웹 애플리케이션인 경우 사용자가 여러 명이기 때문에, 시스템이 종료되는 일이 **있어서는 안 된다.**

- WAS가 예외를 받아서 처리하고, 클라이언트에게는 오류 페이지를 노출하도록 해준다.

- 보통 이걸 Java 위에 씌워놓은 WAS 프레임워크 수준에서 해주는 것.

---

## 체크 예외 기본 이해

`Exception`과 그 자식은 모두 **컴파일러가 체크하는** 체크 예외다.

- `RuntimeException`은 예외

체크 예외를 잡거나 던지지 않으면, **컴파일 에러**가 발생한다.

### 예제 코드 요약

- 체크 예외는 `Exception` 을 상속받음으로써 직접 만들어낼 수 있다.

- 메서드 내에서 `throws MyException` 을 적어넣으면, 해당 예외를 개발자가 직접 발생시킬 수 있다.

- 컴파일 에러를 유발하지 않으려면, 체크 예외는 다음과 같이 처리해야 함을 보여준다.
  
  - 예외가 발생하는 메서드 내에서 `try-catch` 처리하기
    
    - `catch` 로 잡을 때, 실제 발생하는 예외의 부모 타입으로 잡는 것도 가능하다.
    
    - 대신 부모 타입의 자식이 모두 잡힌다.
    
    - `catch Exception` 은 그런 측면에서 안 좋은 코드
  
  - 예외를 잡지 않고 던지려면, 메서드에서 `throws` 로 선언해야 한다.
    
    - 잡을 때와 마찬가지로 부모 타입으로 던질 수도 있다.

### 체크 예외의 장단점

체크 예외는 잡아서 던질 수 없을 때, `throws` 를 통해 명시적으로 던지도록 강제하고 있다. 아예 컴파일에서 체크해주는 것.

- 장점: 개발자가 실수로 예외를 누락하는 일을 사전에 차단한다.

- 단점: 개발자가 모든 체크 예외를 잡거나 던져야하기 때문에, 이걸 다 처리하는 게 번거로워진다.
  
  - `throws Exception`을 양산하게 되는 것.
  
  - 추가로 의존관계에 따른 단점도 존재한다.

---

## 언체크 예외 기본 이해

`RuntimeException`과 그 자식들은 **언체크 예외**로 분류된다.

언체크 예외는 **컴파일러**가 체크해주지 않는다. 

- 언체크 예외가 발생하는 메서드가 `catch`나 `throws`를 하지 않아도 컴파일 오류는 발생하지 않는다.

### 예제 코드 요약

- 언체크 예외는 `RuntimeException` 을 상속받음으로써 직접 만들 수 있다.

- 언체크 예외는 잡거나 던지지 않아도 컴파일 오류가 전혀 발생하지 않는다.

- 언체크 예외여도 명시적으로 잡거나 던지는 게 가능은 하다. 그게 컴파일과 관계는 없다.

### 언체크 예외의 장단점

- 장점: 신경쓰고 싶지 않은 언체크 예외를 **무시**할 수 있다. 특히, 예외의 의존관계를 참조하지 않아도 된다.

- 단점: 개발자가 실수로 예외를 **누락하기 쉽다.**

### 정리

체크 예외와 언체크 예외의 차이는, **예외를 처리할 수 없을 때 예외를 밖으로 던지는 부분**에 있다.

이게 필수인지, 선택인지 여부

---

## 체크 예외 활용

실무적으로 어떻게 활용하면 좋을까?

### 기본 원칙

- **기본적으로 런타임 예외를 사용하자**

- 체크 예외는, **비즈니스 로직상 의도적으로 던지는** 케이스에만 사용하자.
  
  - 예외를 잡아서 반드시 문제를 처리해야 하는 아주 중요한 상황일 때.
  
  - 계좌 이체 실패라든지, 결제 시 포인트 부족이라든지
  
  - 개발자가 실수로 놓치는 상황을 **반드시 차단**하는 것을 목적으로 할 때 체크 예외로 만들어서 컴파일 단계에서 잡는다.

### 체크 예외의 문제점

개발자가 실수로 예외를 놓치는 것을 막아준다는 점에서 제법 좋아보이는데, 왜 웬만해서 쓰지 말라고 하는걸까?

- 서비스 로직 수준에서 해결이 불가능한 **공통적인 시스템 오류**에 대해 체크 예외를 사용할 시, **무의미한 예외 처리를 반복적으로 양산**해야 하는 문제가 발생하기 때문이다.

#### 대표적인 예시 : 일반적인 MVC 구조의 서버

- Repository 에서 발생하는 `SQLExcpetion`이 체크 예외라면?

- Service 에서 이걸 처리할 방법이 **있을 리가 없다**. 밖으로 던짐

- 마찬가지로 Controller 에서도 밖으로 던짐

- `ControllerAdvice`가 서블릿 오류 페이지 같은, 프레임워크 수준에서 이걸 받아서 처리하는 수 밖에 없는데,

- 그마저도 있는 그대로 처리하면 **클라이언트에게 무의미한 메시지**밖에 줄 수 없다.
  
  - DB 오류라고 화면에 표시한다거나, 스택트레이스를 표시해줌으로써 클라이언트에게 제공할 수 있는 편의는 전혀 없다. 
  
  - 보안취약점만 발생할 뿐

- 이렇게 해결이 불가능한 오류는, **서버에만 로그를 남기고 개발자에게 알림을 전달하는 방식**으로 처리하는 게 맞다.
  
  - 클라이언트에게는 **공통 오류 페이지**로,
  
  - API 라면 **500 코드**로 처리하면 충분하다.

### 예제 코드 요약

- 간단하게 Controller, Service, Repository, NetworkClient 구조의 App 을 만든 상태에서, SQLException과 ConnectException을 체크 예외로 던져준다.

- 이 때 Service와 Controller 코드에서는 스스로 해결할 수도 없는 두 예외를 일일이 메서드마다 명시해서 던져줘야 한다.

### 2가지 문제점

#### 복구 불가능한 예외

대부분의 예외는 복구가 애초에 불가능하다.

`SQLException`만 해도, SQL 문법 오류나 DB서버 다운 등 서비스 로직에서 복구가 불가능하다.

이런 문제라면, 오류 로그를 남기고 개발자가 문제를 인지하도록 공통적으로 처리해주는 것이 오히려 일관성이 있다.

- 서블릿 필터, 스프링 인터셉터, 스프링의 `ControllerAdvice` 등이 이걸 도와준다.

#### 의존 관계에 대한 문제

서비스나 컨트롤러에서 `SQLException`을 던지는 게 귀찮다고 해서만 문제가 아니다.

진짜 문제는, 서비스, 컨트롤러에서 `SQLException` 이라는 구**체적인 DB 접근 기술에 의존하게 된다**는 점에 있다.

향후 DB 접근 기술이 JDBC가 아니게 된다면, 서비스와 컨트롤러가 전부 다 수정되어야 한다.

- 애초에 **스스로 처리할 수도 없었던 예외**에, **기술적으로 의존**까지 해야하는 상황.

이론적으로는 **OCP 위반**이고, **DI**를 마음대로 활용할 수도 없다.

### 정리

처리할 수 있는 체크 예외라면, 서비스나 컨트롤러에서 처리하는 게 맞다.

하지만 DB나 네트워크 통신처럼 **시스템 레벨**에서 올라오는 예외들은, 애초에 대부분 복구도 불가능하다.

- 이런 경우에 대해 체크 예외를 사용하면, 알 필요 없는 예외를 서비스와 컨트롤러가 알아야 하는 **불필요한 의존관계**가 발생한다.

### throws Exception?

모든 체크 예외를 `Exception`으로 던지면 코드도 깔끔하고 의존관계가 없게 된다고 생각하는 경우가 있는데,

시스템 수준의 예외 뿐만 아니라 모든 체크 예외를 다 던지기 때문에 **체크 예외를 쓰는 이유가 아예 사라진다.**

---

## 언체크 예외 활용

### 예제 코드 요약

- `RuntimeException`을 상속받아서 언체크 예외를 커스텀할 수 있다.

- Repository 에서 발생한 체크 예외인 `SQLException`을, Repository 선에서 잡아다가 언체크 예외로 바꿔준다.

- 이후 해당 Repository 를 호출하는 모든 서비스와 컨트롤러에서는 예외에 의존하지 않아도 된다.

### 예외 전환

체크 예외를 잡아서 런타임 예외로 바꾸는 것을 **예외 전환**이라고 볼 수 있다.

- 단 이 때 기존 예외를 포함하도록 코드를 구성해야, 예외 출력 시 스택 트레이스에서 기존 예외를 확인할 수 있다.

이를 통해 **복구 불가능한 런타임 예외에 대한 의존관계를 제거**할 수 있다.

구현 기술이 변경되더라도, 런타임 예외를 공통으로 처리하는 곳 하나만 건드리면 된다. 

해당 예외를 굳이 사용하지 않는 컨트롤러나 서비스 쪽에서는 코드를 변경할 필요가 없다.

### 정리

체크 예외가 설계 상 더 좋아보이던 시절도 있었다.

- 자바가 처음 나올 때 쯤..

그런데 자바를 단독으로 사용하는 게 아닌, WAS 프레임워크와 각종 라이브러리를 붙여서 사용하기 시작하면서 모든 예외를 체크 예외로 처리하는 게 **사실상 불가능**해지기 시작했다.

- 덕분에 사용하게 된 방법이 `throws Exception`이라는 극단적인 처리방법.

이런 문제 때문에, **최근의 라이브러리는 런타임 예외를 기본으로 사용**하고 있다. 스프링도 대부분 런타임 예외를 제공한다.

- 체크 예외는 옛날에 만들어진 자바 기본 기능에서 제공하고 있는 수준.

런타임 예외 또한 필요하면 잡아서 처리할 수 있기 때문에, 필요하면 잡고 그렇지 않으면 자연스럽게 던지는 식으로 사용하고 있다.

#### 런타임 예외는 문서화가 필수

런타임 예외를 잘 활용하려면 결국 **문서화**가 필수적이다.

정 어렵다면, 코드에서 `throws 런타임예외`를 개발자가 명시하는 방법이 있다.

- `throws` 해둬도 본질은 런타임 예외이기 때문에, IDE 수준에서 잡아주기는 하더라도 컴파일에 문제는 생기지 않는다.

---

## 예외 포함과 스택 트레이스

예외를 **전환**할 때는 꼭 **기존 예외를 포함시켜야 한다**.

### 로그 출력

`log.info()` 를 사용한다면, 마지막 파라미터에 예외를 그대로 넣어줬을 때 **스택 트레이스**를 출력시킬 수 있다.

`e.printStackTrace()` 는 `System.out` 를 사용하는 방식에 해당하므로, 사용을 자제

### 예외 포함

예제코드에서 사용 중인 `RuntimeSQLException`은 `SQLException` 을 **포함**하고 있는 관계다.

- `RuntimeSQLException` 이 `Throwable` 을 받을 수 있는 생성자를 갖춘 상태에서,

- `catch SQLException` 했을 때의 그  `e`를 넣어서 `RuntimeSQLException` 을 생성하는 방식

그 덕분에 스택 트레이스를 찍었을 때, `SQLException`이 함께 나타날 수 있다.

만약 **체크 예외를 언체크 예외로 전환하려는 의도**를 가지고  `RuntimeSQLException` 을 생성할 때 `SQLException` 의 `e`를 포함시켜주지 않았다면, `RuntimeException` 이 터진 이유는 알아보기 매우 어려워진다.

- 예외 전환시킨 보람이 없게 된다. 오히려 디버깅에 심각한 악영향을 끼치게 됨

- 자연스럽게 스택 트레이스는 여러 번의 **Caused by**를 포함시키게 된다. 

- 가장 하위에 존재하는 근본적인 원인을 **Root Cause**라고 부른다.

즉, **예외를 전환할 때는 반드시 기존 예외를 포함시키자.**


