# HTTP 헤더 - 캐시와 조건부 요청

---

## 캐시 기본 동작

### 캐시가 없다면?

1. 클라이언트가 GET 으로 JPG 파일을 요청한다.

2. 서버는 HTTP 헤더 0.1M, HTTP 바디 1.0M 짜리를 합쳐서 1.1M 짜리를 전송한다.

3. 두 번째 요청 시 같은 동작이 반복된다.

#### 문제점

- 데이터 변경이 없어도 **계속** 네트워크를 통해서 다운로드 받아야 한다.

- 인터넷 네트워크는 매우 느리고 비쌈.

- 브라우저 로딩 속도도 느려져서 사용자 경험 악화

### 캐시 적용

1. 클라이언트가 같은 요청을 전송한다.

2. 서버는 HTTP 헤더에 `cache-control` 정보를 넣어서 1.1M 짜리 응답을 전송한다.

3. 클라이언트는 그걸 보고 응답 결과를 캐시에 저장한다.
   
   - `cache-control: max-age=60` 이라면 60초 동안 저장

4. 두 번째 요청 시 클라이언트는 캐시를 먼저 뒤진다.

5. 60초 이내였다면 네트워크 요청 없이 캐시에서 JPG를 즉시 가져온다.

#### 장점

- 캐시 가능 시간동안은 네트워크를 사용하지 않아도 된다.

- 네트워크 사용량을 줄여 비용이 줄고

- 브라우저 로딩 속도가 빨라져서 사용자 경험이 개선된다.

### 캐시 시간이 초과된 경우

1. 위와 같은 상황에서 60초가 초과됐다면?

2. 클라이언트는 동일한 응답을 돌려준다. `cache-control` 포함, 똑같이 1.1M를 다운로드하게 된다.

하지만 캐싱된 파일과 서버의 데이터 간에는 변경점이 전혀 없는 상황. 이걸 개선할 방법은?

---

## 검증 헤더와 조건부 요청 1

### 캐시 시간 초과 시

두 가지 상황이 나타난다.

- 서버에서 기존 데이터를 변경한 상황

- 서버에서 기존 데이터를 변경하지 않은 상황

### 검증 헤더 활용

1. 클라이언트의 첫 요청 시,

2. 서버가 `cache-control`과 함께 `Last-Modified` 헤더를 첨가해서 리턴함

3. 브라우저는 응답 결과를 캐시에 저장하고,
   동시에 해당 데이터의 **최종 수정일**도 가지고 있는다.

4. 캐시 시간 초과 이후 요청을 보낼 시, 웹 브라우저는
   `if-modified-since` 헤더를 함께 붙여서 요청을 보낸다.

5. 서버가 받아서 해당 데이터의 `Last-Modified`를 확인한 뒤, `if-modified-since` 값과 동일하다면,

6. **304 Not Modified** 응답을 돌려준다.
   헤더에는 `Last-Modified`가 달려있고,
   **HTTP Body** 부분은 아예 존재하지 않는다.
   원래 1.1M 가 돌아가야했을 것이 0.1M 짜리 트래픽으로 감소한 것

7. 클라이언트는 304 응답을 받아서 캐시를 다시 세팅하고, 그대로 로딩해서 데이터를 사용

이 때,

- **Last-Modified**를 **검증 헤더**

- **if-modified-since**를 **조건부 요청**

이라고 볼 수 있다.

### 정리

- 캐시 유효 시간이 초과해도 서버 데이터가 갱신되지 않았으면, 서버는 **304 Not Modified**와 헤더 정보만 응답한다.

- 클라이언트는 헤더 정보로 캐시의 메타 정보를 갱신하고, 캐시 데이터를 재활용

- 네트워크 다운로드가 발생은 하지만, 용량이 크게 감소한다는 점에서 아주 실용적

---

## 검증 헤더와 조건부 요청 2

### Last-Modified, if-modified-since 의 단점

- 1초 미만의 단위로는 캐시 조정이 불가능

- 날짜 기반의 로직인 점
  
  - 데이터를 수정했다가 원복해서, 날짜는 달라졌지만 데이터는 동일한 경우

- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 적용 불가

### ETag, If-None-Match

**ETag**는, 캐시용 데이터에 달아두는 **임의의 고유한 버전 이름**

데이터가 변경되면 해당 이름을 변경하게 됨. (Hash 활용)

클라이언트는 `cache-control` 상의 시간을 초과할 시, 요청 헤더에 **If-None-Match** 태그를 넣어서 보낸다.

- value 값은 클라이언트가 들고 있던 ETag

- ETag를 비교해서 같으면 유지, 다르면 다시 받는 방식

- 같을 때 돌아오는 응답은 마찬가지로 **304**가 돌아옴

### 정리

단순하게, ETag로 관리하는 방식.

**캐시 제어 로직이 서버에서 완전하게 관리된다는 개념**

- 클라이언트가 캐시 메커니즘을 전혀 몰라도 된다.

- 애플리케이션 정기 배포 시점에 ETag를 일괄 갱신시키는 등으로 활용

---

## 캐시와 조건부 요청 헤더

### 캐시 제어 헤더

#### Cache-Control

기본이 되는 캐시 지시어로, Pragma, Expires의 **상위 호환**

**max-age**

- 캐시 유효 시간, 초 단위

**no-cache**

- 데이터는 캐시해도 되지만, **항상** origin 서버에 검증해서 사용
  
  - 경로상의 캐시 서버에서 검증하라는 의미가 아님

- 안 바뀌었으면 304 돌려줄테니 어쨌든 꼭 보내라는 뜻

**no-store**

- 데이터에 민감한 정보가 있으므로, 저장하지 말 것

#### Pragma

캐시 제어 (하위 호환)

#### Expires

캐시 만료일 지정 (하위 호환)

### 검증 헤더와 조건부 요청 헤더

#### 검증 헤더

- ETag

- Last-Modified

#### 조건부 요청 헤더

- If-Match, If-None-Match : ETag

- If-Modified-Since, If-Unmodified-Since : Last-Modified

---

## 프록시 캐시

### origin 서버 직접 접근 시

클라이언트는 한국인데, origin 서버의 위치가 미국이라면 순수 통신만 편도로 500ms 씩은 걸린다.

### 프록시 캐시 도입 시

특정 글로벌 서비스들은 origin 서버를 대신하여 클라이언트와 인접한 거리에서 빠른 응답을 제공할 수 있는 **프록시 캐시 서버**를 두고 있다.

웹 브라우저에서 들고 있는 캐시는 **private** 캐시인 반면, 프록시 캐시 서버가 들고 있는 캐시는 **public** 캐시라고 볼 수 있다.

#### Cache-Control 에서의 보완

- `cache-control: public` 이면, 응답이 public 캐시에 저장되어도 된다는 뜻.

- 반대로 `private`이면 저장하지 말라는 뜻
  
  - 로그인 같은 사용자 정보가 이에 해당
  
  - 캐시 기본값은 `private`라고 이해해도 된다.

- `s-maxage`는 프록시 서버 전용 max-age 값

- `Age` 는 origin 서버 응답 후 프록시 서버에 **머물고 있던 시간** 값.

---

## 캐시 무효화

### Cache-Control 에서의 캐시 무효화

이 응답은 절대로 캐싱하면 안 된다 싶다면,

`no-cache`, `no-store`, `must-revalidate` 를 셋 다 입력해서 리턴해야 한다.

- no-cache: 데이터 캐시 허용. 항상 origin 서버 검증

- no-store: 데이터 캐시 불허용

- must-revalidate: 캐시 만료 후 최초 조회 시 **origin 서버에 검증**해야 함.
  
  - origin 서버 접근 실패 시 반드시 오류 발생 (**504**)
  
  - 캐시 유효 시간 내라면 캐시 사용

HTTP 1.0 이하 버전을 위해 `Pragma: no-cache` 까지 넣으면 완벽

#### no-cache와 must-revalidate를 같이 쓰는 이유

**프록시 캐시 서버가 존재하는 경우**를 대비하기 위한 방법.

1. 클라이언트가 no-cache 설정과 함께 ETag 를 요청

2. 프록시 캐시 서버는 no-cache를 보고 origin 서버 포워딩 시도
   
   **이 때 순간적인 네트워크 단절로 인해 origin 서버 접근이 불가하다면?**

3. 프록시 캐시 서버 설정에 따라서는, 그냥 스스로의 데이터를 200 응답으로 돌려주는 케이스도 존재한다는 것

4. 반면 **must-revalidate**가 함께 박혀서 왔다면, origin 서버 접근이 막혔을 때 **504**가 반드시 떨어지게 되어있다.

금전과 관련된 통신에서 캐시로 인한 비즈니스 오류가 발생할 여지가 있다.

그걸 차단하기 위해서는 둘다 써있어야 함.


