# HTTP 기본

---

## 모든 것이 HTTP

**HyperText Transfer Protocol**

HTML, TEXT는 기본이고,

이미지, 음성, 영상, 파일

JSON, XML 같은 API 용 데이터

거의 모든 형태의 데이터를 전송하는 데 사용 중이다.

### HTTP의 역사

#### HTTP/0.9

- 1991년

- GET 만 지원. HTTP 헤더 없음

#### HTTP/1.0

- 1996년

- 메서드, 헤더 추가

#### HTTP/1.1

- 1997년

- 지금 가장 많이 사용하는, 가장 중요한 버전

#### HTTP/2

- 2015년

- 성능 개선

#### HTTP/3

- 진행 중

- TCP 대신 **UDP** 사용, 성능 개선

### 기반 프로토콜

#### TCP

- HTTP/1.1, HTTP/2

#### UDP

- HTTP/3

### HTTP 특징

- 클라이언트 서버 구조

- 무상태 프로토콜, 비연결성

- HTTP 메시지 사용

- 단순함, 확장 가능

---

## 클라이언트 서버 구조

Request - Response 구조

**역할 분리**에 초점 - **각기 독자적인 발전이 가능**

- 서버에 비즈니스 로직, 데이터 처리를 몰빵

- 클라이언트에 UI 처리를 몰빵

---

## 무상태 프로토콜

서버가 클라이언트의 상태를 보존하지 않는다.

- 장점: **서버 확장성**이 높음
  
  - 서비스 이용자의 **context**를 서버 간에 전달하지 않아도 된다.
  
  - 리소스에 대한 식별자(URI)와 전문 인터페이스만 정확하게 입력되면, 어떤 서버가 받더라도 정확한 응답을 줄 수 있는 설계
  
  - 서버가 고장나서 다른 서버로 failover 됐거나, 서버를 확충해도 상관없다.

- 단점: 클라이언트가 추가 데이터를 전송해야 함

### Stateless의 실무적 한계

모든 것을 무상태로 설계할 수는 없다.

대표적인 게 **로그인**

- 로그인한 상태는 서버에 유지해야 한다.

- 일반적으로, 브라우저의 **쿠키**와 서버의 **세션** 등을 조합하여 상태를 유지하게 됨.

대신 최대한 Stateless는 유지할 수 있도록 설계해야 한다.

---

## 비 연결성

HTTP는 기본적으로 **연결을 유지하지 않는** 모델이다.

- 일반적으로 동시 접속자가 아무리 많더라도, 실제 서버에서 실시간 처리 중인 요청은 그보다 훨씬 적게 유지되기 때문.

- 서버 자원을 **효율적으로 사용**하기 위한 방법

### 비 연결성의 한계와 극복

- 연결이 유지되지 않았을 시, **TCP/IP 연결을 새로 맺어야 한다.**
  
  - 3 way handshake 시간이 추가됨

- 브라우저가 요청하는 자원은 HTML에서 그치지 않고, 이미지나 js, css 등 순차적으로 많은 요청이 이루어진다.
  
  - 그 때마다 매번 연결을 수립해야 하는 문제

현재는 **HTTP 지속 연결**로 해결 중.

- HTTP/2, HTTP/3 을 거치면서 더 최적화되는 중

- 연결 수립 후 수십 초 동안은 **Keep alive** 시킴으로써, 필요로 하는 자원을 지속적으로 응답받는 구조.

### Stateless를 기억하자

대용량 트래픽을 제어하기 위해서는 Stateless가 매우 중요하다.

---

## HTTP 메시지

현대 웹은 웬만한 건 모두 HTTP로 주고받고 있다.

### 구조

1. start-line (시작 라인) [필수]

2. header (헤더) [필수]

3. empty line (공백 라인, CRLF) [필수]

4. message body [옵션]

요청, 응답 모두 위 구조를 따라야 한다.

### 시작 라인

#### 요청 메시지

start-line = request-line

request-line = **method** SP **request-target** SP **HTTP-version** CRLF

##### HTTP 메서드

GET, POST, PUT, DELETE 중에 하나

- 서버가 수행해야 할 동작을 지정하는 의미

##### 요청 대상

absolute-path[?query] 로 구성

#### 응답 메시지

start-line = statue-line

status-line = HTTP-version SP status-code SP reason-phrase CRLF

- status-code: HTTP 상태 코드. 요청의 성공 실패
  
  - 200: 성공
  
  - 400: 클라이언트 요청 오류
  
  - 500: 서버 내부 오류

### HTTP 헤더

header-filed = field-name ":" OWS field-value OWS

#### 용도

HTTP 전송에 필요한, 모든 **부가정보** (메타데이터)

- 메시지 바디의 내용, 크기, 압축, 인증, 클라이언트 정보 등등

- 표준 헤더는 엄청 많다.

- 필요하면 임의의 헤더를 넣어서 보낼 수 있다.

### HTTP 메시지 바디

실제 전송할 데이터에 해당.

HTML, 이미지, JSON 등 byte로 표현 가능한 모든 데이터 가능

### 소결

HTTP는 **단순하고 확장 가능하다.**


