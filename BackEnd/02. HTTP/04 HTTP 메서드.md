# HTTP 메서드

---

## API URI에 대한 고민

URI는 Uniform **Reosource Identifier**

- URI 설계에서 가장 중요한 건, **리소스 식별**

- URI에 담는 정보는 **리소스**에 한정된다. 리소스에 대한 **동작**은 담겨있으면 안 된다.
  
  - 잘못된 예시 : `/member/add` `/add-member`

- 리소스에 대한 **동작**을, **메서드**로 지정한다.

### 리소스와 행위를 분리

**URI는 리소스만 식별한다.**

리소스와, 해당 리소스를 **대상으로 하는 행위**를 분리한다.

- 리소스는 명사, 행위는 동사

- 행위는 **메서드**

---

## HTTP 메서드 - GET, POST

### HTTP 메서드 종류

### 주요 메서드

GET: 리소스 조회

POST: 요청 데이터 처리. 주로 등록

PUT: 리소스를 대체. 해당 리소스가 없으면 생성

PATCH: 리소스에 대한 부분 변경

DELETE: 리소스 삭제

### 기타 메서드 (참고만)

HEAD: GET과 동일한데, 메시지 부분 제외하고 헤더까지만 반환

OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명

CONNECT: 대상 자원으로 식별되는 서버에 대한 터널 설정

TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행

### GET

**리소스 조회**

서버에 전달할 데이터는 **query**를 통해서 전달.

- 메시지 바디 사용해서 데이터 전달이 **가능은 한데,**

- 지원하지 않는 경우가 많다. 권장하지 않음

### POST

**요청 데이터 처리**

**메시지 바디**를 통해, 서버로 요청 데이터를 전달한다.

서버는 요청 데이터를 처리

- 사실상 모든 기능을 수행 가능하다. 주로 등록 시 사용

#### 요청 데이터에 대한 처리?

공식 스펙 상 표현은

- 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청 (...)

정리하자면,

- 해당 리소스 URI에 대해 POST 요청이 올 시,

- 그 요청 데이터를 어떻게 처리할 지는 **리소스마다** 따로 정해야 한다.

- 즉, 정해진 것이 없다.

### 정리

1. 새 리소스 생성

2. 요청 데이터 처리
   
   - 단순 데이터 생성, 변경이 아닌 **프로세스 처리**
   
   - 그 결과로 새로운 리소스가 생성되는 것이 아니라, 프로세스 상태가 변경될 수도 있다.
   
   > ##### 절차지향이 불가피한 케이스
   > 
   > URI에 동사를 담지 않는 게 최선이지만, 그건 이상적인 내용이고 담을 수밖에 없는 경우가 있다.
   > 
   > ex) POST /orders/orderId/**start-delivery**
   > 
   > 이런 경우를 **컨트롤 URI**라고 하는데,
   > 
   > 사실상 객체지향의 예외라고 이해 가능하다.

3. 다른 메서드로 처리하기 애매한 경우
   
   - 조회 동작인데, GET을 사용하기에는 HTTP 바디가 필요한 경우

즉, 사실상 **애매하면 POST**

- 그렇다고 모든 걸 POST 처리하면 안 된다.

- 대표적으로 GET
  
  - GET에 대해서는 서버 측 캐싱이 이루어지는 경우가 많다.
  
  - 단순 조회에 대해 응답 속도가 빨라지고, 서버 자원도 아낄 수 있음

---

## HTTP 메서드 - PUT, PATCH, DELETE

### PUT

**리소스를 대체**

- 있으면 대체하고, 없으면 생성.

- **완전히** 대체한다.

중요한 건, **클라이언트가 리소스를 완전히 식별한다는 점**

- 클라이언트가 URI 지정하는 시점에 **리소스 위치를 완전히 알고 있어야 한다.** (리소스의 ID값을 알고 있다)

- POST와 명백한 차이

#### 리소스의 완전한 대체

필드A, 필드B가 존재하는 리소스에 대해

필드A만 수정할 목적으로 PUT을 보낸다면?

- 필드B가 삭제되는 효과 발생

PUT을 리소스 **수정**이라는 개념으로 쓰면 사고난다.

PUT은 **완전한 대체**

### PATCH

리소스의 **부분 변경**

위와 같은 예시에서 더 적당한 메서드다.

- PATCH를 지원하지 않는 서버가 있을 수도 있는데,

- 그럼 POST를 쓰

### DELETE

리소소의 **제거**

---

## HTTP 메서드의 속성

각 메서드에 대해 5가지 속성을 부여하여 구분할 수 있다.

1. 요청에 Body가 있는가

2. 응답에 Body가 있는가

3. 안전 (Safe)

4. 멱등 (Idempotent)

5. 캐시 가능

### 안전

**Safe**

호출해도 리소스를 **변경하지 않는다.**

대표적으로 **GET**

- 안전에 대한 관점은 **해당 리소스**.

- GET의 로그가 쌓여서 발생하는 장애 이런거는 포함X

### 멱등

**Idempotent**

`f(f(x)) = f(x)`

한 번 호출하든 두 번 호출하든 100번 호출하든, 결과가 똑같다.

- GET: 항상 동일한 조회

- PUT: 자원의 **대체**이기 때문에 최종 결과는 항상 동일

- DELETE: 자원의 **삭제**이기 때문에 최종 결과는 항상 동일

- **POST가 멱등이 아님.**

#### 활용법 - 자동 복구 메커니즘

앞선 요청의 fail 시 클라이언트가 같은 요청을 반복해도 괜찮은가?

판단기준은 멱등 여부.

#### 리소스가 다른 곳에서 변경된다면?

GET은 기본적으로 멱등인데, 다른 사용자가 GET과 GET 사이에 PUT을 때리면 GET 결과는 바뀐다.

- 멱등은 **외부 요인으로 중간에 리소스가 변경되는 것까지 고려하지 않는다**.

- 즉, 위와 같은 케이스를 감안하더라도 GET은 멱등

### 캐시 가능

**Cacheable**

응답 결과 리소스를 **캐시해서 사용해도 되는가**?

- GET, HEAD, POST, PATCH 는 가능

- 실제로는 **GET**, **HEAD** 정도만 캐시 사용

- POST, PATCH는 HTTP body까지 캐시 키로 구현해야하므로 사용이 어렵다.


