# 컴포넌트 스캔

---

## 컴포넌트 스캔과 의존관계 자동 주입

굳이 `@Configuration` 클래스에다가 스프링 빈을 하나씩 등록해야할까?

- 귀찮기도 하고, 빼먹기도 쉽다.

- 그래서 컴포넌트 자동으로 스캔하고 의존관계를 주입해주는 기능이 있다.

`AutoAppConfig` 클래스를 새로 만들고, `@ComponentScan` 어노테이션을 달아준다.

빈 등록이 필요한 구체화 클래스들에는 `@Componenet`를 달아주고,

구체화 클래스 간의 의존관계를 등록하기 위해 각 생성자에 `@Autowired`를 달아준다.

- `AutoAppConfig`는 `@Component`가 달려있는 클래스들을 불러모아 생성하고 스프링 컨테이너에 등록할 때,

- 각 클래스는 `@Autowired`로 지정된 바에 따라 의존관계를 형성하는 방식.

- 생성자에 명시된 파라미터들을 프로젝트 내에서 **타입** 기준으로 찾아서, 주입시켜준다.
  
  - 별도의 지정이 없는 한, 라이브러리를 포함해서 **모든** 자바 코드를 뒤져서 찾아준다.

---

## 탐색 위치와 기본 스캔 대상

### 시작 위치 지정

`@ComponentScan` 에서 `basePackages` 옵션을 넣어줄 수 있다.

- 스캔을 시작할 위치를 지정하는 옵션이다.
  
  - 컴포넌트 스캔의 범위를 한정할 수 있다.

- 지정하지 않은 경우의 기본값은, 설정 정보 클래스의 위치
  
  - 애초에 설정 정보 클래스 위치를 프로젝트 최상단에 두는 게 국룰이다.
  
  - SpringBoot에서도 이 방법을 사용하고 있다.
    
    - `@SpringBootApplication`에 `@ComponentScan` 이 포함되어 있다.

### 기본 스캔 대상

`@Component`가 컴포넌트 스캔 대상인데,

`@Controller`, `@Service`, `@Repository`, `@Configuration`은 모두 `@Component`를 포함하고 있는 어노테이션이기 때문에 당연히 스캔 대상이 될 수 있다.

> 어노테이션 간에 **상속관계** 같은 것은 없다.
> 
> 어노테이션이 특정 어노테이션을 들고 있거나 하는 것은 자바가 원래 지원하는 기능이 아니고, 스프링이 지원하는 기능이다.
> 
> 혹시라도 착각하지 말 것

- 위에서 언급된 어노테이션들은 각기 특수한 기능을 담고 있거나, 의미있는 표시로 사용된다.

---

## 필터

`@ComponentScan`에 `includeFilters`와 `excludeFilters` 옵션이 존재한다.

- 커스텀 어노테이션을 만들고, 필터링 대상으로 만듦으로써 컴포넌트 스캔의 범위에 넣거나 뺄 수 있다.

- 기본적으로 필터가 어노테이션을 인식하도록 만드는데, 타입을 직접 지정해버리는 경우도 가능하다.

물론, 웬만해서는 사용하지말자. 다들 스프링부트 기본설정 따라가는 중인데 괜히 헷갈린다.

---

## 중복 등록과 충돌

### 자동 등록끼리 충돌

컴포넌트 스캔을 통해 자동으로 빈을 등록할 때, 굳이 이름을 동일하게 설정하거나 해서 중복 등록되는 경우가 생길 시 런타임에 exception이 터져준다.

### 수동 등록과 자동 등록 간의 충돌

컴포넌트 스캔이 걸려있음에도 불구하고 `@Configuration` 클래스에서 직접 `@Bean`을 등록해주는 경우가 있을 수 있다.

수동 등록된 빈이 컴포넌트 스캔 대상이기도 한 경우, 수동 등록되는 빈이 **우선권을 가지게 된다**.

- 수동 빈이 자동 빈을 **오버라이딩** 한다.

- 자세히 보면 로그에도 그 사실이 적혀있다.

단, 스프링부트의 경우 이러한 *수동 등록과 자동 등록 간 충돌*이 개발자가 의도하기보다 **설정 정보가 꼬인 것이라고 보는 게 타당**하다는 판단을 내렸다.

- 스프링부트에서는 이런 경우에 대해 자동 등록 간 충돌처럼 런타임 exception을 터뜨려버리고 있다.

- 대신 application.properties에서 overriding 허용 여부를 결정해줄 수 있게 했다. (기본값이 false)


