# 빈 스코프

---

## 빈 스코프란?

모든 스프링 빈이 컨테이너 시작과 함께 생성되고 종료될 때 소멸하는 것이 아니다.

그러한 빈은 **싱글톤 스코프**를 가진 빈이고, 그 외에도 다양한 **스코프**가 지원되고 있다.

### 다양한 빈 스코프

#### 싱글톤

기본 스코프로, 스프링 컨테이너의 **시작과 종료까지 유지**되는 가장 넓은 범위의 스코프

#### 프로토타입

스프링 컨테이너가 해당 빈의 **생성과 의존관계 주입까지만 관여**하고 이후에는 관리하지 않는 스코프.

#### 웹 관련 스코프

- **request**: **웹 요청이 들어오고 나갈 때까지** 유지되는 스코프

- **session**: **웹 세션이 생성되고 종료될 때까지** 유지되는 스코프

- **application**: 웹의 **서블릿 컨텍스트와 같은 범위**로 유지되는 스코프

특정 클래스를 Bean으로 등록할 때, `@Scope` 애노테이션을 사용해서 스코프를 지정할 수 있다.

---

## 프로토타입 스코프

싱글톤 스코프의 빈을 조회할 시, 스프링 컨테이너는 **항상 같은 인스턴스**의 스프링 빈을 반환한다.

하지만 해당 빈이 **프로토타입 스코프**인 경우, 스프링 컨테이너는 **항상 새로운 인스턴스를 생성해서 반환**해준다.

- 그리고 반환된 인스턴스는 컨테이너에서 관리하지 않는다.

즉, 프로토타입 빈을 **관리할 책임은 해당 빈을 받은 클라이언트에게 있다**.

- `@PreDestroy` 같은 종료 메서드가 자동으로 호출되지 않기 때문에,

- 혹시 필요하다면 클라이언트가 직접 호출해야 한다.

### 프로토타입 빈 특정 정리

스프링 컨테이너에 **요청할 때마다** 새로 생성된다.

스프링 컨테이너는 프로토타입 빈의 **생성, 의존관계 주입, 초기화**까지만 관여한 뒤 더 이상 관리하지 않는다.

따라서, 스프링 컨테이너 종료 시 **소멸 메서드가 호출되지 않는다.**

---

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

### 예제 코드 요약

**싱글톤 빈이 프로토타입 빈을 주입받은 경우 문제가 발생**

- 의도 자체는, 싱글톤 빈을 **사용**하는 과정에서 **프로토타입 빈**을 매번 생성하는 것인데,

- 이걸 단순히 싱글톤 빈에 프로토타입 빈을 **주입**하는 방식으로 구현하면 프로토타입은 **최초 1번 생성 후 주입되는 것**이지, 싱글톤 빈을 **사용할 때마다** 생성되는 것이 아니다.

- 즉, 프로토타입 빈을 사용한 의도를 달성할 수 없다.

- 무식하게 구현하는 방법은 있다.
  
  - 싱글톤 빈이 `ApplicationContext` 를 주입받아버린 후, 프로토타입 빈이 필요한 로직마다 **프로토타입 빈을 `getBean()` 해서 사용하는 것**

---

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결

### 스프링 컨테이너에 요청하기

위에서 언급한 가장 간단한 방법이다.

사용할 때마다 항상 새로운 프로토타입 빈이 생성되는 것을 보장할 수 있다.

### Dependency Lookup (DL)

의존관계를 외부에서 주입(DI)받는 것이 아니라, 빈이 **직접 필요한 의존관계를 찾는 것**을 **Dependency Lookup**이라고 한다.

- **의존관계 조회** (DL)

위와 같은 방식은 DL을 구현하기 위해 `ApplicationContext`를 아예 주입받아버리는 방식에 해당.

- 스프링 컨테이너에 지나치게 종속적인 코드

- 단위 테스트가 어려워짐

- **DL 정도만 제공**하는 무언가가 필요하다.

### ObjectFactory, ObjectProvider

**지정한 빈을 컨테이너에서 찾아주는 DL 서비스**를 제공하는 클래스들이다.

`ObjectFactory`에서 편의 기능을 추가한 게 `ObjectProvider`.

싱글톤 빈이 프로토타입 빈을 **직접 주입받는 게 아니라**,

`ObjectProvider`를 주입받은 이후 로직에서 `getObject()`하여 **DL을 처리**하면 매번 새로운 프로토타입 빈을 사용할 수 있게 된다.

- 기능이 단순하므로, 단위테스트를 만들거나 mock 코드를 만들기가 훨씬 쉬워진다.

- **DL**만 사용하기에 최적화된 클래스.

#### 특징

`ObjectFactory` 

- 기능이 단순, 별도 라이브러리 필요 없음, 스프링 의존적

`ObjectProvider` 

- `ObjectFactory`를 상속받음. 옵션, 스트림 처리 등 편의 기능 확보, 스프링 의존적

### JSR-330 Provider

마지막 방법.

`javax.inject.Provider` 라는 **자바 표준**을 사용하는 방법.

`ObjectProvider` 대신 `Provider` 를 싱글톤 빈에 주입하고, `get()` 메서드로 프로토타입 빈을 DL 처리한다.

사용 방법이 `ObjectProvider` 와 완전히 동일하다.

- 자바 표준이기는 한데, 정작 Gradle에서 라이브러리를 추가해서 사용해야한다는 단점이 있다.

- `get()` 메서드 단 하나만 제공하는 단순한 라이브러리.

### 정리

프로토타입 빈은 **사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요할 때** 사용한다.

그런데 실무적으로 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에, 사용할 일은 극히 드물다.

다만, `Provider`는 프로토타입 빈 뿐만 아니라 **DL이 필요한 경우에** 언제든지 사용해볼 수 있다.

### 참고

실무에서 `Provider` 혹은 `ObjectProvider` 중에 뭘 사용할 것인가?

- `ObjectProvider`는 DL을 위한 편의 기능을 많이 제공해주고, 스프링 외 별도 의존관계 추가가 필요 없어서 편리하다.

- 문제는, 스프링에 전적으로 의존하는 코드이며 `Provider`라는 자바 표준과 기능이 많이 겹친다는 점.
  
  - *그래도 표준인데...* 라는 고민이 안 생길 수가 없다.

다만 스프링은 현재 *사실상 업계 표준*의 지위에 해당한다.

- 자바 표준과 스프링 고유 기능이 겹치는 순간에, 자바 표준을 반드시 골라야한다거나 할 필요가 그렇게 크지 않다.

- 단순히 `Provider` 뿐만 아니라 자바 표준과 스프링이 겹치는 경우는 꽤 많은데, 대부분의 경우 스프링이 더 편리하고, 별도 라이브러리 주입이 필요없기 때문에 스프링 사용을 권장하게 된다.

---

## 웹 스코프

### 웹 스코프의 특징

**웹 환경**에서만 동작한다.

프로토타입과 달리 스프링이 **해당 스코프의 종료시점까지 관리**해준다.

- **종료 메서드가 호출**된다.

### 웹 스코프 종류

#### request

- HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프

- 각각의 HTTP 요청마다, 별도의 빈 인스턴스를 생성하고 관리한다.

#### session

- HTTP Session과 동일한 생명주기를 가지는 스코프

#### application

- `ServletContext`와 동일한 생명주기를 가지는 스코프

#### websocket

- 웹 소켓과 동일한 생명주기를 가지는 스코프

---

## request 스코프

### 웹 환경 추가

`build.gradle` 에 `spring-boot-starter-web` 의존성을 추가하고 애플리케이션을 구동시키면, 8080 포트에 Tomcat이 작동한다.

#### 참고

스프링부트는 Web 라이브러리가 없으면 기본적으로 `AnnotationConfigApplicationContext`를 사용해서 애플리케이션을 구동한다.

Web 라이브러리가 추가되면, 웹 관련 설정과 환경을 위해 `AnnotationConfigServletWebServerApplicationContext`를 사용해서 애플리케이션을 구동하고 있다.

### 예제 코드 요약

- `MyLogger` 클래스를 **request 스코프**로 작성한다.
  
  - 웹 애플리케이션에서 각 요청에 대한 로그를 UUID 기반으로 관리하는 클래스라는 컨셉

- `MyLogger` 클래스를 `Controller`와 `Service`에 주입하고, 로깅 관련 공통처리를 한다.

- 애플리케이션을 실행시켰을 때, 구동에 실패한다.
  
  - `MyLogger` 가 싱글톤 빈 (`Controller`와 `Service`)에 대한 의존성을 가지고 있어서 애플리케이션 구동 시점에 생성 및 주입되어야 하는데,
  
  - request 스코프여서 충돌이 발생하는 것.

---

## 스코프와 Provider

위 문제를 해결하기 위해 `ObjectProvider`를 사용해본다.

- `MyLogger`를 직접 싱글톤 빈에 주입하는 것이 아닌,

- `ObjectProvider` 에서 **DL 처리**함으로써 애플리케이션을 정상적으로 구동시킬 수 있다.

- `MyLogger`가 HTTP 요청 단위로 생성 및 소멸되면서, UUID 기반으로 로그를 관리하는 모습을 확인 가능하다.
  
  - 동일한 HTTP 요청이라면, `Controller`에서 `getObject()` 한 것과 `Service` 에서 `getObject()` 한 결과 (`MyLogger`)가 동일한 것을 확인할 수 있다.
  
  - 스프링이 request 기반으로 빈을 관리해주는 것.

---

## 스코프와 프록시

동일한 문제를 해결하면서도,

`Provider`로 일일이 클래스를 찾아오는 불편함을 해결하기 위해 프록시 객체를 사용하는 방법이 있다.

`MyLogger`에서 `@Scope` 를 선언할 때 `proxyMode` 값을 설정해준다.

- `proxyMode = ScopedProxyMode.TARGET_CLASS`

- 적용 대상이 인터페이스라면 `INTERFACES` 라고 써야 함

이렇게 하면, 스프링은 `MyLogger`의 **더미 프록시 클래스**를 만들어두고, **HTTP request와 상관없이 싱글톤 빈에 프록시 클래스를 주입하는 방식**으로 애플리케이션을 띄워버린다.

- 실제로 구동 이후 `MyLogger`의 주소값을 찍어보면 `CGLIB` 라이브러리가 개입하고 있음을 확인 가능

### 프록시 객체의 동작 정리

- CGLBI라는 라이브러리로, 싱글톤 빈에 주입될 프록시 객체를 만들어서 주입한다.

- 가짜 프록시 객체는 내부적으로 `MyLogger`는 DL하는 로직을 들고 있다.

- 클라이언트가 `mylogger.logic()` 를 호출하면, 프록시 객체가 먼저 요청을 받아서 request 스코프의 실제 객체를 호출하는 방식.

- 이 때 프록시 객체는 원본 클래스를 **상속**받고 있기 때문에, 클라이언트 입장에서는 이러한 조작에 대해 알지 못한다.

- 프록시 객체는 실제 request scope와는 전혀 관계가 없고 **단순히 DL 로직만** 있기 때문에, 사실은 **싱글톤 빈**이다.

### 프록시 객체의 특징 정리

- 프록시 객체 덕분에 클라이언트는 마치 **싱글톤 빈**을 사용하듯이 request scope를 사용할 수 있다.

- 이 때 핵심 아이디어는, **객체에 대한 조회를 실제 필요한 시점까지 지연 처리**한다는 것에 있다.

- 웹 스코프가 아니어도 이와 같은 프록시 객체의 원리는 계속 사용하게 된다.

- 중요한 건 스프링이 그러한 처리가 있을 때 **클라이언트가 모를 수 있도록** **다형성**을 적극 적용하고 있다는 것. 

### 주의할 점

얼핏 보기에는 싱글톤 빈이기 때문에, 꼭 필요한 경우가 아니라면 사용하지 말자. 유지보수가 아주 어렵고 테스트도 안 된다.


