# 객체 지향 설계와 스프링

---

## 스프링의 탄생

### EJB

**Enterprise Java Beans**

2000년대 자바 진영 표준 기술은 EJB였다.

- 지금의 스프링이나 JPA 같은 게 전부 다 들어있는 종합선물세트.

- 분산 환경, ORM 기술 (Entity Bean) 같은 것이 잘 지원되었다.

근데 문제는 **엄청 비싸고**, **진짜 어렵고**, **느리다**.

무엇보다도 EJB에 **극도로 의존적인** 코드가 만들어져야했다.

개발자들이 엄청 고통받았다고.

그에 반발하여 나온 개념이 **POJO**

- Plain Old Java Object.

- EJB에 의존적이지 않은 자바 오브젝트를 쓰겠다는 것

그 결과 등장한 것이 **스프링**과 **하이버네이트**라는 걸출한 오픈소스.

시장에서 점차 EJB를 대체하기 시작했다.

- 특히 **하이버네이트**는 **ORM** 분야에서 EJB 엔티티빈을 거의 완전히 대체해서, 자바 표준진영이 공식적으로 인정하기에 이르렀다.

- Hibernate를 거의 복붙해서 **JPA**라는 표준 인터페이스를 만들고, 하이버네이트는 그 **구현체**의 지위가 되었다.

### 스프링 역사

2002년에 로드 존슨의 책에서 출발함.

- EJB의 문제점을 지적하면서, 오늘날 스프링의 핵심 개념과 기반 코드를 모두 담고 있는 책.

- BeanFactory, ApplicationContext, POJO, IoC 등.

그 책을 출발점으로 한 오픈소스 프로젝트가 유겐 휠러에 의해 시작됐다.

- 전통적인 EJB라는 겨울을 넘어, 새로운 시작이라는 의미의 Spring.

초기에는 **XML** 기반으로 설정이 이루어졌는데, 점차 자바 코드로 설정하는 방향으로 수정이 이루어졌다.

2014년에 **스프링 부트**가 출시되면서 편의성이 크게 개선됐고,

2017년에는 리액티브 프로그래밍을 지원하기 시작했다.

---

## 스프링이란?

### 스프링 생태계

기본적으로 여러 기술의 모음집이다.

**필수**에 해당하는

- **스프링 프레임워크**
  
  - 가장 중요한 핵심기술

- **스프링 부트**

**선택**사항에 해당하는

- 스프링 데이터

- 스프링 세션

- 스프링 시큐리티

- 스프링 Rest Docs

- 스프링 배치

- 스프링 클라우드

- 등등.. 이외에도 굉장히 많다.

### 스프링 프레임워크

여러 부분으로 나누어 볼 수 있다.

- 핵심 기술
  
  - 스프링 DI 컨테이너, AOP, 이벤트

- 웹 기술
  
  - 스프링 MVC, 스프링 WebFlux

- 데이터 접근 기술
  
  - 트랜잭션, JDBC, ORM 지원, XML 지원

- 기술 통합
  
  - 캐시, 이메일, 원격접근, 스케줄링

- 테스트
  
  - 스프링 기반 테스트 지원

- 언어
  
  - 코틀린, 그루비

### 스프링 부트

스프링을 **편리하게 사용**하도록 지원. 최근에는 사실상 기본임

- Tomcat 같은 내장 웹 서버가 존재
  
  - 스프링 애플리케이션을 **단독으로** 쉽게 생성 및 실행할 수 있음
  
  - 빌드하고 서버 띄우는 게 한 번에!

- 손쉬운 빌드 구성을 위한 starter 디펜던시 제공

- 스프링 외 외부 라이브러리 **버전**에 대한 자동 구성

- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공

- 관례에 의한 간결한 설정

### 스프링은 왜 만들었는가?

#### 이 기술의 핵심 컨셉은?

스프링은 기본적으로 **자바** 기반 프레임워크인데,

자바는 원래부터 객체 지향 언어.

- 스프링은, 자바라는 **객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크**이다.

- **좋은 객체 지향 애플리케이션**을 개발할 수 있게 도와준다.

---

## 좋은 객체 지향 프로그래밍

### 객체 지향?

프로그램을 여러 개의 독립된 단위인 **객체들의 모임**으로 파악하는 것.

객체들 간 메시지를 주고받고, 데이터를 처리하는 **협력**이 이루어진다.

프로그램을 **유연하고 변경에 용이하게** 만들 수 있다.

유연성의 핵심이자 객체 지향의 핵심은, **다형성**이다.

### 다형성

#### 역할과 구현을 분리

자동차 모델이 바뀐다고 해서 운전자가 매번 다른 방식으로 운전할 필요는 없다.

자동차라는 **역할**을 각 모델로 **구현**하고 있기 때문.

즉, **역할과 구현으로 구분**하는 것은 세상을 단순화하고, 유연하고 변경이 편리한 시스템을 만들 수 있다.

핵심은 **클라이언트**.

- 클라이언트는 대상의 **역할**(**인터페이스**)만 알면 되고,

- 구현 대상의 **내부 구조**를 전혀 몰라도 되며,

- 구현 대상의 내부 구조 변경에 영향을 받지 않고,

- 더 나아가 구현 대상 **자체가 바뀌어도** 영향을 받지 않는다.

#### 자바 언어의 경우

자바는 다형성을 지원한다.

- 인터페이스에서 역할을 정의하고,

- 인터페이스를 클래스로 구현한다.

애초에 객체 설계 단계에서 역할과 구현을 명확히 분리하여, **역할**을 **먼저 부여**하고 그 역할을 수행하는 구현 객체를 만드는 것.

**오버라이딩**을 통해, 인터페이스를 구현한 객체를 **실행 시점에 유연하게 변경**할 수 있다.

#### 다형성의 본질

인터페이스를 구현한 객체 인스턴스를 **실행 시점에 유연하게 변경**할 수 있다.

- 확장 가능한 설계.

<u>다시 말해, **클라이언트를 변경하지 않고** 서버의 구현 기능을 유연하게 변경할 수 있다.</u>

단, **인터페이스를 안정적으로 잘 설계**하는 것이 극도로 중요해진다.

- 인터페이스 변경은 프로그램 구조 전체에 영향을 줘버리기 때문.

### 스프링과 객체 지향

스프링은 다형성을 극대화하여 이용할 수 있게 도와준다.

IoC, DI 모두 **다형성**을 활용하여 역할과 구현을 편리하게 다루는 테크닉들이다.

---

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

### SRP 단일 책임 원칙

하나의 클래스, 하나의 책임

하나의 책임이라는 기준이 모호한데,

가장 중요한 기준은 **변경**이다.

- 변경이 있을 때 **파급 효과**가 적으면, SRP를 잘 따른 것.

### OCP 개방-폐쇄 원칙

*아주 중요한 원칙*

소프트웨어 요소가 **확장에는 열려 있으나 변경에는 닫혀 있어야 한다**.

- 확장을 하는데 기존 코드의 변경이 없다?

- **다형성**을 사용하면 가능하다.

인터페이스를 구현하는 새로운 클래스를 만들면, **기존 코드를 변경하지 않고 기능을 확장**한 게 맞다.

#### 문제점

다형성을 적용한 상태라고 해도 **클라이언트가 구현 클래스를 직접 선택**하는 경우라면, 클라이언트의 코드는 *변경되어야 한다*.

분명 다형성을 사용했는데도 OCP 원칙을 지키는 게 **불가능**한 상황

- 객체를 생성하고, 연관관계를 맺어주는 **별도의 조립 및 설정자**가 필요한 시점인 것

### LSP 리스코프 치환 원칙

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, **하위 타입의 인스턴스**로 바꿀 수 있어야 한다.

다형성을 활용할 것이라면, **하위 클래스가 인터페이스의 규약을 충실하게 다 지켜야 한다**는 것.

- 그래야 구현체를 믿고 사용할 수 있다.

### ISP 인터페이스 분리 원칙

특정 클라이언트를 위한 인터페이스 여러 개가, 범용 인터페이스 하나보다 낫다.

인터페이스가 명확해지고, 대체 가능성을 높이는 방법.

클라이언트에게 주는 영향도도 줄어든다.

### DIP 의존관계 역전 원칙

*아주 중요한 원칙*

구현 클래스에 의존하지 말고, **인터페이스에 의존**하라는 뜻.

- 구체화에 의존하지 말고, **추상화에 의존**한다.

다시 말해 **역할에 의존**하는 설계를 해야 한다.

- 그래야 구현체를 변경할 수 있기 때문.

클라이언트가 구현 클래스를 직접 선택하는 경우라면, **OCP와 마찬가지로 DIP도 위반**하는 상황이다.

### 정리

- 객체 지향의 핵심은 다형성

- 다형성만으로는, **구현 객체 변경 시 클라이언트 코드도 함께 변경**된다.

- 즉, **다형성만으로는 OCP와 DIP를 지킬 수 없다.**

---

## 객체 지향 설계와 스프링

### 스프링과 객체 지향

스프링은, **다형성과 OCP, DIP**를 **모두 가능하도록** 만든다.

- 핵심은 **DI와 DI 컨테이너**

클라이언트 코드 변경 없이 기능 확장이 가능해졌다.

---

## 정리

- 모든 설계에는 **역할과 구현이 분리**되어야 한다.
  
  - 구현체가 **유연하게 변경**되는 것이 좋은 객체 지향 설계이다.
  
  - 코드 관점에서는 **모든 설계에 인터페이스를 부여**하는 방식으로 가능하다.

- 단. 인터페이스 도입에는 **추상화**라는 비용이 발생
  
  - 기능을 확장할 가능성이 없는 경우라면 구현 클래스를 직접 사용하는 것도 괜찮다.
