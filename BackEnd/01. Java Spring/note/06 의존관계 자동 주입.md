# 의존관계 자동 주입

---

## 다양한 의존관계 주입 방법

총 4가지 방법이 존재한다.

- 생성자 주입

- 수정자 주입 (setter)

- 필드 주입

- 일반 메서드 주입

### 생성자 주입

생성자를 통해서 의존 관계를 주입받는 방법.

현재의 예제 코드가 사용하는 방식.

- 생성자의 파라미터로 주입 대상 객체를 넣어두고,

- 상단의 `@Autowired` 처리한 것

생성자 호출 시점에 **딱 1번만** 호출되는 것이 보장되므로,

**불변, 필수** 의존관계에서 사용된다.

- 애초에 주입 대상 객체가 필드 상에 `final` 로 선언되어 있음.

- `final`로 선언된 필드는, 객체 생성 시점에 초기화가 **반드시** 일어나야 한다. (Java 자체 정의)

**생성자가 단 1개만 존재하는 경우**에는, 생성자 위에다가 `@Autowired`를 달아주지 않아도 된다.

- Spring Bean으로 선언되어 있다면 스프링이 알아서 달아준다.

### 수정자 주입 (setter)

필드에 붙어있는 `final`을 제거하고, 해당 필드에 대한 `setter` 메서드를 만든 다음, `@Autowired`를 상단에 달아준다.

- 스프링 빈이 생성/등록되는 과정은 기본적으로 **객체 생성 -> 의존관계 주입** 순서로 이루어지는데,

- 생성자 주입의 경우 Java 코드 논리 상 객체 생성 과정에서 의존관계 주입이 발생한다.

- 수정자 주입은 그와 달리, **위 순서를 충실히 따라가는 방식**.

**선택, 변경** 가능성이 있는 의존관계에서 사용해야 한다.

- 단, setter 메서드에 붙은 `@Autowired`에다가 `required=false`를 달아줘야 선택적인 적용이 가능하다.

> #### 자바빈 프로퍼티 규약
> 
> 클래스의 필드 값을 직접 변경하는 대신,
> 
> `setter`와 `getter` 메서드를 통해서만 값을 수정하거나 읽어오는 규칙.

### 필드 주입

선언된 필드에 `@Autowired`를 달아서 즉시 주입해버리는 방법.

코드가 매우 간결하다.

그러나, 스프링 컨테이너(**DI 프레임워크**)를 사용하지 않는 단순 Java 수준의 단위테스트가 사실상 불가능해진다.

- 특정 객체의 메서드를 실행하고 싶을 때, Java 수준에서 해당 객체에 의존관계를 주입해줄 방법이 없기 때문.

- **사용하지 말자!**

단, `@SpringBootTest` 를 사용할 때는 써도 된다.

혹은 Config 객체처럼 Spring 돌릴 때만 쓰는 객체 정도는 써도 된다.

### 일반 메서드 주입

아무 메서드에서도 `@Autowired`를 붙일 수 있다.

- 논리상 setter 주입이랑 거의 동일하다.

- 굳이 사용하지 않는다.

---

## 옵션 처리

`@Autowired` 를 사용하지만 **주입할 스프링 빈은 존재하지 않거나** null 인 경우, 별도의 처리가 필요하다.

- 그냥 사용하면 `required=true`가 기본으로 걸려있기 때문.

세 가지 방법이 있다.

- `@Autowired(required=false)`

- null일 수 있는 파라미터에 `@Nullable` 붙이기

- null일 수 있는 파라미터에 `Optional<>` 을 감싸

생성자 주입에서도 `@Nullable`을 사용한 옵션 처리가 가능하다.

---

## 생성자 주입을 선택하라!

### 불변

대부분의 의존관계는 애플리케이션 종료시점까지 변경될 일이 없다. 변경이 안 되는 게 정상이다.

수정자 주입을 사용할 시, setter를 public으로 열어야한다는 점에서도 문제가 있다.

- 누가 실수로 변경할 수도 있다.

### 누락

**프레임워크 없이** 순수한 자바 코드를 **단위 테스트**하는 경우가 많다.

- 필드 주입의 경우, 객체 생성과 의존관계 주입이 **별도의 절차**로 구성되어 있기 때문에, 외부에서 해당 객체를 가져다가 사용하려 할 때 **의존관계의 누락을 알아차리는 게 쉽지 않다.**

- 필드 주입 시, 의존관계를 누락시켜도 객체 생성 자체는 가능하다.
  
  - 정확히는, **컴파일 에러가 발생하지 않는다.**

- 반면 생성자 주입을 사용할 시, 의존관계가 누락된 테스트코드는 **컴파일 단계에서 에러가 발생한다.**
  
  - 개발자가 객체에 내장된 의존관계를 즉시 파악하고,
  
  - **필요로 하는 객체를 직접 생성해서 집어넣어 줌으로써**
  
  - 프레임워크의 도움 없이도 테스트를 진행시킬 수 있다.

### final 키워드

필드에 명시된 객체에 `final` 키워드를 넣을 수 있다는 점도 큰 장점이다.

- 자바 컴파일러는, `final` 키워드가 붙은 필드가 생성자에서 초기화되지 않으면 에러를 선언한다.

- 생성자를 직접 코딩할 때 누락되는 경우가 없게 된다.

Java 문법 상, final 키워드를 사용 가능한 의존관계 주입 방법은 오직 생성자 주입 뿐이다.

### 결론

기본적으로 생성자 주입을 항상 사용하되, 의존관계가 필수값이 아닌 경우에만 제한적으로 **수정자 주입 방식**을 옵션으로 활용한다.

- 생성자 주입과 수정자 주입은 동시에 사용할 수 있기 때문.

---

## 롬복과 최신 트렌드

```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
}
```

**어노테이션 프로세서** 기반으로 자바 코드를 간결하게 만들어주는 `lombok` 라이브러리 덕분에, 위와 같이 **생성자 주입**을 사용하면서도 보기 쉽고 만들기도 쉬운 코드를 만들 수 있다.

---

## 조회 빈이 2개 이상인 문제

인터페이스와 그 **구현체를 모두** `@Component`로 선언해두고, 제3의 클래스에서 해당 인터페이스를 `@Autowired` 해둔 상태로 스프링을 작동시키면,

의존관계 자동주입 과정에서 인터페이스의 **타입**으로 조회한 결과가 unique하지 못하고 2개 이상 나오기 때문에 오류가 발생한다.

### @Autowired의 필드 명 매치

`@Autowired`는 최초에는 타입으로 매칭을 시도하지만, 여러 개의 빈이 조회되면 **필드 명**으로 조회해서 매칭을 시도해준다.

### @Qualifier 사용

구현체에 `@Component`와 함께 `@Qualifier` 어노테이션을 선언하면, 스캔 과정에서 해당 빈을 식별할 수 있는 이름을 따로 부여해줄 수 있다.

- `@Autowired` 때 혹은 생성자 파라미터 선언 때 `@Qualifier`를 넣어서 특정 빈을 지정해줄 수 있다.

### @Primary 사용

`@Autowired`가 작동할 때, 여러 개의 빈이 매칭될 시 우선순위를 부여해주는 어노테이션.

괜히 복잡하게 별도의 식별자를 부여하고 할 필요가 없다.

### 활용방안

메인으로 작동하는 스프링 빈과 가끔 명시적으로 작동하는, 서브 역할의 빈이 있을 때,

- 메인에 대해서는 `@Primary`를 선언해서 기본값으로 사용하고,

- 서브에 대해서는 `@Qualifier`를 선언해서 *일부러 불편하게* 사용해주는 게 정석적인 방식이다.

혹시 둘이 겹칠 때, 우선순위가 잡히는 건 당연히 `@Qualifier` 쪽이다.

---

## 애노테이션 직접 만들기

`@Qualifier`에서 식별자를 String으로 직접 입력하는 건, 컴파일 타임에 오타 감지를 할 수가 없어서 다소 위험하다.

```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
} 
```

위와 같이 해당 식별자에 해당하는 애노테이션을 직접 만들고, 사용처에서는 `@MainDiscountPolicy` 같이 재정의된 애노테이션을 가져다가 쓰면, 오타 위험 등을 줄일 수 있다.

- 단, 기본적으로 자바에서 애노테이션에서는 **상속** 개념이 없다. 위와 같은 방식은 스프링이 지원해주는 방식.

- 즉, 무분별한 재정의는 자제할 필요가 있다.

---

## 조회한 빈이 모두 필요할 때
