# 의존관계 자동 주입

---

## 다양한 의존관계 주입 방법

총 4가지 방법이 존재한다.

- 생성자 주입

- 수정자 주입 (setter)

- 필드 주입

- 일반 메서드 주입

### 생성자 주입

생성자를 통해서 의존 관계를 주입받는 방법.

현재의 예제 코드가 사용하는 방식.

- 생성자의 파라미터로 주입 대상 객체를 넣어두고,

- 상단의 `@Autowired` 처리한 것

생성자 호출 시점에 **딱 1번만** 호출되는 것이 보장되므로,

**불변, 필수** 의존관계에서 사용된다.

- 애초에 주입 대상 객체가 필드 상에 `final` 로 선언되어 있음.

- `final`로 선언된 필드는, 객체 생성 시점에 초기화가 **반드시** 일어나야 한다. (Java 자체 정의)

**생성자가 단 1개만 존재하는 경우**에는, 생성자 위에다가 `@Autowired`를 달아주지 않아도 된다.

- Spring Bean으로 선언되어 있다면 스프링이 알아서 달아준다.

### 수정자 주입 (setter)

필드에 붙어있는 `final`을 제거하고, 해당 필드에 대한 `setter` 메서드를 만든 다음, `@Autowired`를 상단에 달아준다.

- 스프링 빈이 생성/등록되는 과정은 기본적으로 **객체 생성 -> 의존관계 주입** 순서로 이루어지는데,

- 생성자 주입의 경우 Java 코드 논리 상 객체 생성 과정에서 의존관계 주입이 발생한다.

- 수정자 주입은 그와 달리, **위 순서를 충실히 따라가는 방식**.

**선택, 변경** 가능성이 있는 의존관계에서 사용해야 한다.

- 단, setter 메서드에 붙은 `@Autowired`에다가 `required=false`를 달아줘야 선택적인 적용이 가능하다.

> #### 자바빈 프로퍼티 규약
> 
> 클래스의 필드 값을 직접 변경하는 대신,
> 
> `setter`와 `getter` 메서드를 통해서만 값을 수정하거나 읽어오는 규칙.

### 필드 주입

선언된 필드에 `@Autowired`를 달아서 즉시 주입해버리는 방법.

코드가 매우 간결하다.

그러나, 스프링 컨테이너(**DI 프레임워크**)를 사용하지 않는 단순 Java 수준의 단위테스트가 사실상 불가능해진다.

- 특정 객체의 메서드를 실행하고 싶을 때, Java 수준에서 해당 객체에 의존관계를 주입해줄 방법이 없기 때문.

- **사용하지 말자!**

단, `@SpringBootTest` 를 사용할 때는 써도 된다.

혹은 Config 객체처럼 Spring 돌릴 때만 쓰는 객체 정도는 써도 된다.

### 일반 메서드 주입

아무 메서드에서도 `@Autowired`를 붙일 수 있다.

- 논리상 setter 주입이랑 거의 동일하다.

- 굳이 사용하지 않는다.

---

## 옵션 처리

`@Autowired` 를 사용하지만 **주입할 스프링 빈은 존재하지 않거나** null 인 경우, 별도의 처리가 필요하다.

- 그냥 사용하면 `required=true`가 기본으로 걸려있기 때문.

세 가지 방법이 있다.

- `@Autowired(required=false)`

- null일 수 있는 파라미터에 `@Nullable` 붙이기

- null일 수 있는 파라미터에 `Optional<>` 을 감싸

생성자 주입에서도 `@Nullable`을 사용한 옵션 처리가 가능하다.

---

## 생성자 주입을 선택하라!

### 불변

대부분의 의존관계는 애플리케이션 종료시점까지 변경될 일이 없다. 변경이 안 되는 게 정상이다.

수정자 주입을 사용할 시, setter를 public으로 열어야한다는 점에서도 문제가 있다.

- 누가 실수로 변경할 수도 있다.

### 누락

**프레임워크 없이** 순수한 자바 코드를 **단위 테스트**하는 경우가 많다.

- 필드 주입의 경우, 객체 생성과 의존관계 주입이 **별도의 절차**로 구성되어 있기 때문에, 외부에서 해당 객체를 가져다가 사용하려 할 때 **의존관계의 누락을 알아차리는 게 쉽지 않다.**

- 필드 주입 시, 의존관계를 누락시켜도 객체 생성 자체는 가능하다.
  
  - 정확히는, **컴파일 에러가 발생하지 않는다.**

- 반면 생성자 주입을 사용할 시, 의존관계가 누락된 테스트코드는 **컴파일 단계에서 에러가 발생한다.**
  
  - 개발자가 객체에 내장된 의존관계를 즉시 파악하고,
  
  - **필요로 하는 객체를 직접 생성해서 집어넣어 줌으로써**
  
  - 프레임워크의 도움 없이도 테스트를 진행시킬 수 있다.

### final 키워드

필드에 명시된 객체에 `final` 키워드를 넣을 수 있다는 점도 큰 장점이다.

- 자바 컴파일러는, `final` 키워드가 붙은 필드가 생성자에서 초기화되지 않으면 에러를 선언한다.

- 생성자를 직접 코딩할 때 누락되는 경우가 없게 된다.

Java 문법 상, final 키워드를 사용 가능한 의존관계 주입 방법은 오직 생성자 주입 뿐이다.

### 결론

기본적으로 생성자 주입을 항상 사용하되, 의존관계가 필수값이 아닌 경우에만 제한적으로 **수정자 주입 방식**을 옵션으로 활용한다.

- 생성자 주입과 수정자 주입은 동시에 사용할 수 있기 때문.

---

## 롬복과 최신 트렌드

```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
}
```

**어노테이션 프로세서** 기반으로 자바 코드를 간결하게 만들어주는 `lombok` 라이브러리 덕분에, 위와 같이 **생성자 주입**을 사용하면서도 보기 쉽고 만들기도 쉬운 코드를 만들 수 있다.

---

## 조회 빈이 2개 이상인 문제

인터페이스와 그 **구현체를 모두** `@Component`로 선언해두고, 제3의 클래스에서 해당 인터페이스를 `@Autowired` 해둔 상태로 스프링을 작동시키면,

의존관계 자동주입 과정에서 인터페이스의 **타입**으로 조회한 결과가 unique하지 못하고 2개 이상 나오기 때문에 오류가 발생한다.

### @Autowired의 필드 명 매치

`@Autowired`는 최초에는 타입으로 매칭을 시도하지만, 여러 개의 빈이 조회되면 **필드 명**으로 조회해서 매칭을 시도해준다.

### @Qualifier 사용

구현체에 `@Component`와 함께 `@Qualifier` 어노테이션을 선언하면, 스캔 과정에서 해당 빈을 식별할 수 있는 이름을 따로 부여해줄 수 있다.

- `@Autowired` 때 혹은 생성자 파라미터 선언 때 `@Qualifier`를 넣어서 특정 빈을 지정해줄 수 있다.

### @Primary 사용

`@Autowired`가 작동할 때, 여러 개의 빈이 매칭될 시 우선순위를 부여해주는 어노테이션.

괜히 복잡하게 별도의 식별자를 부여하고 할 필요가 없다.

### 활용방안

메인으로 작동하는 스프링 빈과 가끔 명시적으로 작동하는, 서브 역할의 빈이 있을 때,

- 메인에 대해서는 `@Primary`를 선언해서 기본값으로 사용하고,

- 서브에 대해서는 `@Qualifier`를 선언해서 *일부러 불편하게* 사용해주는 게 정석적인 방식이다.

혹시 둘이 겹칠 때, 우선순위가 잡히는 건 당연히 `@Qualifier` 쪽이다.

---

## 애노테이션 직접 만들기

`@Qualifier`에서 식별자를 String으로 직접 입력하는 건, 컴파일 타임에 오타 감지를 할 수가 없어서 다소 위험하다.

```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
} 
```

위와 같이 해당 식별자에 해당하는 애노테이션을 직접 만들고, 사용처에서는 `@MainDiscountPolicy` 같이 재정의된 애노테이션을 가져다가 쓰면, 오타 위험 등을 줄일 수 있다.

- 단, 기본적으로 자바에서 애노테이션에서는 **상속** 개념이 없다. 위와 같은 방식은 스프링이 지원해주는 방식.

- 즉, 무분별한 재정의는 자제할 필요가 있다.

---

## 조회한 빈이 모두 필요할 때

### 예제 코드 요약

- `OrderServiceImpl` 의 경우, `DiscountPolicy` 인터페이스를 상속받는 2개의 구현체 중 하나를 주입받기 위해 `@MainDiscountPolicy` 라는 커스텀 애노테이션을 사용하였다.
  
  - `FixDiscountPolicy` 가 `@MainDiscountPolicy` 애노테이션을 가지고 있어서, 다른 곳에서 해당 애노테이션을 기반으로 가져다 쓸 수 있었다.

- 테스트코드에서는 서비스 클래스가 그저 `DiscountPolicy`를 주입받는데, 대신 그 형태를 `List`와 `Map`으로 주입받는다.
  
  - `private final Map<String, DiscountPolicy> policyMap`
  
  - `private final List<DiscountPolicy> policies;`

- 위와 같이 하면 어떤 구현체가 주입되는지를 **빈 등록 시에 무조건 지정함 없이, 모든 구현체를 주입받은 채로 사용**할 수 있다.
  
  - 실제 무슨 구현체를 사용하는 지는 **동적으로 지정**하는 것

- 서비스 로직에서 **특정 구현체**를 사용하겠다는 식으로 코드를 구성하면, 그 때 해당 구현체를 가져다 쓰는 식으로 **전략 패턴**을 구현할 수 있다.

- ```java
  int discountPrice = discountService.discount(member, 10000, "fixDiscountPolicy");
  
  public int discount(Member member, int price, String discountCode) {
      DiscountPolicy discountPolicy = policyMap.get(discountCode);
      return discountPolicy.discount(member,price);
  }
  ```

- **다형성**을 극한으로 사용하는 모습이라고 할 수 있다.

---

## 자동, 수동의 올바른 실무 운영 기준

### 편리한 자동 기능을 기본으로 사용하자

**자동을 선호하는 추세**다.

- 스프링부트도 **컴포넌트 스캔**을 기본으로 사용하고 있다.

설정 정보와 실제 동작 부분을 명확하게 나누는 것이 이상적이기는 한데, 자동 주입의 편의성이 너무 압도적이다.

- `@Component` 하나 입력하면 끝날 일을, 굳이 `@Configuration` 클래스 찾아가서 빈 등록하고 있는 것은 딱히 효율적이지 못하다.

- 앱 구조 관리 측면에서도 위험성이 발생한다.

무엇보다도, 자동 빈 등록을 사용하더라도 OCP, DIP 상 문제가 없다.

### 수동 빈 등록은 언제 사용할까?

기본이 자동, 필요할 때 수동.

애플리케이션은 크게 **업무 로직**과 **기술 지원 로직**으로 나눠진다.

- **업무 로직**: 비즈니스 요구사항을 개발할 때 추가 또는 변경되는 부분. 컨트롤러, 서비스, 리포지토리 쪽

- **기술 지원**: 기술적인 문제, 공통 관심사(AOP) 처리할 때 사용되는 부분. DB 연결, 로그 처리 등

업무 로직의 경우, **자동 기능**을 적극 사용하자.

- 양적으로도 많고, 개발 시의 패턴이 유사한 경우가 대부분이다.

- 자동으로 처리하는 게 문제 발생 시 대응하기 쉽다.

기술 지원 로직의 경우, **수동 기능**을 사용하는 것도 좋은 방법이다.

- 양적으로 적은데, 수정 시의 **영향도**가 압도적이다.

- 근데 그 영향도 파악이 어려운 경우가 많기 때문에,

- 가급적 수동 빈 등록을 사용해서 명확하게 드러내주는 게 좋다.

**애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 명시적으로 나타나게 하는 것이 유지보수하기 좋다.**

#### 비즈니스 로직 중 다형성을 적극 활용할 때

대표적인 케이스가, 앞선 예제의 `DiscountPolicy`.

사실 예제 코드는 다른 사람이 이해해서 활용하기가 매우 어려운 편이다.

- 자동 등록을 사용하면서도, 실제 구현체가 무엇인지 힌트가 딱히 없는 상황

이런 경우 **수동 빈으로 등록**하거나, 최소한 **특정 패키지에 같이 묶어두는 정도**는 해줘야 한다.

- 딱 보고 이해가 될 수 있도록.
