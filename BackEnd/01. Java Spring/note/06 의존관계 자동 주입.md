# 의존관계 자동 주입

---

## 다양한 의존관계 주입 방법

총 4가지 방법이 존재한다.

- 생성자 주입

- 수정자 주입 (setter)

- 필드 주입

- 일반 메서드 주입

### 생성자 주입

생성자를 통해서 의존 관계를 주입받는 방법.

현재의 예제 코드가 사용하는 방식.

- 생성자의 파라미터로 주입 대상 객체를 넣어두고,

- 상단의 `@Autowired` 처리한 것

생성자 호출 시점에 **딱 1번만** 호출되는 것이 보장되므로,

**불변, 필수** 의존관계에서 사용된다.

- 애초에 주입 대상 객체가 필드 상에 `final` 로 선언되어 있음.

- `final`로 선언된 필드는, 객체 생성 시점에 초기화가 **반드시** 일어나야 한다. (Java 자체 정의)

**생성자가 단 1개만 존재하는 경우**에는, 생성자 위에다가 `@Autowired`를 달아주지 않아도 된다.

- Spring Bean으로 선언되어 있다면 스프링이 알아서 달아준다.

### 수정자 주입 (setter)

필드에 붙어있는 `final`을 제거하고, 해당 필드에 대한 `setter` 메서드를 만든 다음, `@Autowired`를 상단에 달아준다.

- 스프링 빈이 생성/등록되는 과정은 기본적으로 **객체 생성 -> 의존관계 주입** 순서로 이루어지는데,

- 생성자 주입의 경우 Java 코드 논리 상 객체 생성 과정에서 의존관계 주입이 발생한다.

- 수정자 주입은 그와 달리, **위 순서를 충실히 따라가는 방식**.

**선택, 변경** 가능성이 있는 의존관계에서 사용해야 한다.

- 단, setter 메서드에 붙은 `@Autowired`에다가 `required=false`를 달아줘야 선택적인 적용이 가능하다.

> #### 자바빈 프로퍼티 규약
> 
> 클래스의 필드 값을 직접 변경하는 대신,
> 
> `setter`와 `getter` 메서드를 통해서만 값을 수정하거나 읽어오는 규칙.

### 필드 주입

선언된 필드에 `@Autowired`를 달아서 즉시 주입해버리는 방법.

코드가 매우 간결하다.

그러나, 스프링 컨테이너(**DI 프레임워크**)를 사용하지 않는 단순 Java 수준의 단위테스트가 사실상 불가능해진다.

- 특정 객체의 메서드를 실행하고 싶을 때, Java 수준에서 해당 객체에 의존관계를 주입해줄 방법이 없기 때문.

- **사용하지 말자!**

단, `@SpringBootTest` 를 사용할 때는 써도 된다.

혹은 Config 객체처럼 Spring 돌릴 때만 쓰는 객체 정도는 써도 된다.

### 일반 메서드 주입

아무 메서드에서도 `@Autowired`를 붙일 수 있다.

- 논리상 setter 주입이랑 거의 동일하다.

- 굳이 사용하지 않는다.

---

## 옵션 처리

`@Autowired` 를 사용하지만 **주입할 스프링 빈은 존재하지 않거나** null 인 경우, 별도의 처리가 필요하다.

- 그냥 사용하면 `required=true`가 기본으로 걸려있기 때문.

세 가지 방법이 있다.

- `@Autowired(required=false)`

- null일 수 있는 파라미터에 `@Nullable` 붙이기

- null일 수 있는 파라미터에 `Optional<>` 을 감싸

생성자 주입에서도 `@Nullable`을 사용한 옵션 처리가 가능하다.

---

## 생성자 주입을 선택하라!

### 불변

대부분의 의존관계는 애플리케이션 종료시점까지 변경될 일이 없다. 변경이 안 되는 게 정상이다.

수정자 주입을 사용할 시, setter를 public으로 열어야한다는 점에서도 문제가 있다.

- 누가 실수로 변경할 수도 있다.

### 누락

**프레임워크 없이** 순수한 자바 코드를 **단위 테스트**하는 경우가 많다.

- 필드 주입의 경우, 객체 생성과 의존관계 주입이 **별도의 절차**로 구성되어 있기 때문에, 외부에서 해당 객체를 가져다가 사용하려 할 때 **의존관계의 누락을 알아차리는 게 쉽지 않다.**

- 필드 주입 시, 의존관계를 누락시켜도 객체 생성 자체는 가능하다.
  
  - 정확히는, **컴파일 에러가 발생하지 않는다.**

- 반면 생성자 주입을 사용할 시, 의존관계가 누락된 테스트코드는 **컴파일 단계에서 에러가 발생한다.**
  
  - 개발자가 객체에 내장된 의존관계를 즉시 파악하고,
  
  - **필요로 하는 객체를 직접 생성해서 집어넣어 줌으로써**
  
  - 프레임워크의 도움 없이도 테스트를 진행시킬 수 있다.

### final 키워드

필드에 명시된 객체에 `final` 키워드를 넣을 수 있다는 점도 큰 장점이다.

- 자바 컴파일러는, `final` 키워드가 붙은 필드가 생성자에서 초기화되지 않으면 에러를 선언한다.

- 생성자를 직접 코딩할 때 누락되는 경우가 없게 된다.

Java 문법 상, final 키워드를 사용 가능한 의존관계 주입 방법은 오직 생성자 주입 뿐이다.

### 결론

기본적으로 생성자 주입을 항상 사용하되, 의존관계가 필수값이 아닌 경우에만 제한적으로 **수정자 주입 방식**을 옵션으로 활용한다.

- 생성자 주입과 수정자 주입은 동시에 사용할 수 있기 때문.

---

## 롬복과 최신 트렌드

```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
}
```

**어노테이션 프로세서** 기반으로 자바 코드를 간결하게 만들어주는 `lombok` 라이브러리 덕분에, 위와 같이 **생성자 주입**을 사용하면서도 보기 쉽고 만들기도 쉬운 코드를 만들 수 있다.

---
