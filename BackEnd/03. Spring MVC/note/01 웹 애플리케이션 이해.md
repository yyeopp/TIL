# 웹 애플리케이션 이해

---

## 웹 서버, 웹 애플리케이션 서버

### 웹 서버 (Web Server)

HTTP 기반으로 동작

**정적 리소스** 제공, 기타 부가기능

- HTML, CSS, JS, 이미지, 영상

대표적인 웹 서버는 NGINX, APACHE

### 웹 애플리케이션 서버 (WAS)

HTTP 기반으로 동작

사실상 웹 서버 기능을 포함하고 있음

프로그램 **코드**를 수행해서 **애플리케이션 로직**을 수행

- 동적 HTML, HTTP API(JSON) 반환

- 서블릿, JSP, 스프링 MVC 등의 기술

대표적인 WAS는 Tomcat, Jetty, Undertow

### 웹 서버와 WAS의 차이

**웹 서버는 정적 리소스, WAS는 애플리케이션 로직**

사실은 경계가 모호한 편.

- 양자의 기능을 충분히 넘나들 수 있다.

보통, 자바가 **서블릿 컨테이너** 기능을 제공하면 WAS라고 함.

### 웹 시스템 구성 - WAS, DB

WAS랑 DB 만으로도 충분히 시스템 구성이 가능하다.

- WAS에서 정적 리소스를 제공하는 것도 무방하기 때문

하지만 WAS 하나로 너무 많은 일을 수행하면,

- **서버 과부하** 우려가 크고,

- 단순 정적 리소스 리턴하는 작업 때문에 **값비싼 애플리케이션 비즈니스 로직**이 수행되지 않는 것이 효율적이지 못하다.

- WAS 장애 시 **오류 화면**조차 노출이 불가할 수 있다.

### 웹 시스템 구성 - WEB, WAS, DB

정적 리소스를 웹 서버가 처리해주고,

동적인 애플리케이션 로직이 필요할 때 WAS에 요청을 위임하는 방식.

- **효율적인 리소스 관리**가 가능하다.

- 안정성이 증가한다.
  
  - 웹 서버는 단순 정적 리소스만 제공하는 수준이기 때문에 잘 죽지 않는다.
  
  - 애플리케이션 로직이 동작하는 WAS 서버가 죽었을 때, WEB에서 오류 화면을 제공해줄 수 있다.

---

## 서블릿

HTML Form 데이터를 HTTP 로 전송받았을 때, 서버에서 처리해야 하는 업무는? 

WAS 서버를 내가 전부 다 직접 구현해야한다면?

- 서버 TCP/IP 연결 대기, 소켓 연결

- HTTP 요청 메시지 파싱

- POST 방식인지, URL은 무엇인지

- Content-Type 확인

- HTTP 메시지 바디 내용 파싱

- 저장 프로세스 실행

- **비즈니스 로직 실행**
  
  - **데이터베이스 저장 요청**

- HTTP 응답 메시지 생성
  
  - HTTP 시작 라인
  
  - Header
  
  - 메시지 바디 (HTML)

- TCP/IP에 응답 전달, 소켓 종료

할 일이 이만큼이나 많은데, **대부분이 반복적이고, 비즈니스 로직과 관계가 없다.**

**서블릿**을 지원하는 WAS는, 위의 업무 중에 **개발자가 직접 관여하는 게 의미있는 부분**인 **비즈니스 로직, DB 접근**을 제외한 나머지 부분을 **전부 자동화**해준다.

- HTTP **요청** 정보를 편리하게 사용할 수 있는 `HttpServletRequest` 클래스

- HTTP **응답** 정보를 편리하게 사용할 수 있는 `HttpServletResponse` 클래스

- 개발자는 두 가지 객체를 이용해서, HTTP 요청에 대한 비즈니스 로직만 처리한다.

#### 서블릿의 HTTP 요청, 응답 흐름

- HTTP 요청 인입

- WAS가 Request, Response 객체를 만들어서 **서블릿 객체** 호출

- 개발자는 Request 객체에서 HTTP 요청 정보를 꺼내서 사용

- 개발자가 Response 객체에 HTTP 응답 정보를 입력

- WAS가 Response 객체에 담겨있는 내용으로 HTTP 응답을 생성하고, 반환

### 서블릿 컨테이너

톰캣처럼 서블릿을 지원하는 WAS를 **서블릿 컨테이너**라고 함.

- 서블릿 객체의 생성, 초기화, 호출, 종료하는 **생명주기**를 관리

**서블릿 객체**의 경우 **싱글톤**으로 관리

- 서블릿 자체를 고객의 요청 때마다 생성할 필요는 없다.

- 모든 고객의 요청은 서블릿 객체 인스턴스에 접근함
  
  - **공유 변수** 사용 시에 주의가 필요.

- 최초 로딩 시점에 서블릿 객체가 생성되고, 서블릿 컨테이너 (WAS) 종료 시 함께 소멸

JSP도 서블릿으로 변환 되어서 사용

**동시 요청**을 위한 **멀티 쓰레드 처리**를 지원함

---

## 동시 요청 - 멀티 쓰레드

### 쓰레드

애플리케이션 코드를 **하나하나 순차적으로 실행**하는 것이 쓰레드.

자바의 경우 메인 메서드를 처음 실행할 때 **main**이라는 이름의 쓰레드가 시작하는 방식.

- **main** 쓰레드가 없으면 자바 애플리케이션 실행 자체가 불가하다.

쓰레드는 한번에 한 줄의 코드를 수행하고,

**동시 처리**가 필요하다면 **쓰레드를 추가로 생성**해야하는 것.

- **서블릿 객체**를 호출하는 것이 **각각 별개의 쓰레드**이기 때문에,

- 서블릿 컨테이너가 클라이언트의 **다중 요청**을 처리할 수 있는 것.

- 만약 서블릿을 호출하는 것이 **단 하나의 쓰레드**라면, 해당 WAS는 구조적으로 다중 요청 처리가 불가능하다.
  
  - 멀리 갈 것 없이 그냥 자바 선에서 끝난다고 이해해도 됨.

#### 만약 요청마다 쓰레드를 생성해서 사용한다면?

##### 장점

- 동시 요청 처리 가능

- 리소스가 허용할 때까지 처리 가능함

- 쓰레드 지연 시 다른 쓰레드가 영향받지 않음

##### 단점

- 쓰레드의 생성 비용은 매우 비싸다.

- 쓰레드의 **컨텍스트 스위칭** 비용이 발생

- 쓰레드 생성에 제한이 없다는 점 자체.
  
  - **CPU나 메모리 임계점**을 넘겨서 서버가 아예 죽을 수 있다.

### 쓰레드 풀

WAS는 **쓰레드 풀**이라는 개념을 도입하여 사용 중이다.

구동 시점에 쓰레드를 **미리 일정한 개수만큼 생성**해두고, HTTP 요청이 들어올 때마다 할당 및 반환하는 것.

#### 특징

**요청마다 쓰레드를 생성하는 방식의 단점을 보완한다**

- 필요한 쓰레드가 쓰레드 풀에 보관되고, 관리

- 생성 가능한 쓰레드의 최대치를 관리
  
  - 톰캣은 기본값이 200

#### 사용

- 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 풀에서 꺼내 사용하고

- 사용 종료 시 쓰레드를 풀로 반납한다.

- 쓰레드 풀이 비어있으면, 요청을 기다리거나 타임아웃 설정값만큼 대기하도록 설정할 수 있다.

#### 장점

- 쓰레드가 미리 생성되어 있기 때문에, **쓰레드 생성 및 종료 비용**이 절약되고, 응답이 빠르다.

- 쓰레드 **최대치**가 존재하므로, 서버 안정성이 확보된다.

### 쓰레드 풀 실무 팁

최대 쓰레드 값은 WAS의 **주요 튜닝 포인트**

- 너무 낮게 설정하면?
  
  - 서버 리소스가 여유로운데도 클라이언트 응답이 지연되는 비효율적인 상황 발생

- 너무 높게 설정하면?
  
  - 순간적으로 요청이 몰렸을 때, CPU나 메모리 리소스 임계점을 넘겨버릴 우려

#### 쓰레드 풀의 적정 숫자

애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 **모두 다르다.**

**성능 테스트**를 해보는 게 정확하다.

- 최대한 실제 서비스와 유사하게 성능 테스트를 진행

- 툴: Apache ab, Jmeter, nGrinder

### WAS는 멀티 쓰레드 지원한다

**멀티 쓰레드에 대한 부분을 WAS가 처리한다는 것이 결국은 핵심**

- 개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않는다.
  
  - **생산성**을 굉장히 많이 향상시켜주는 포인트

- 그저 싱글 쓰레드 프로그래밍을 하듯이 코드를 개발할 수 있음.

물론 멀티 쓰레드 환경인 것은 변하지 않기 때문에,

**싱글톤 객체**(서블릿, 스프링 빈)는 주의해서 사용해야 한다.

---

## HTML, HTTP API, CSR, SSR

### HTML 페이지

WAS가 클라이언트의 HTML을 받아서, **동적으로** 필요한 HTML 파일을 재생성해서 리턴한다.

웹 브라우저의 역할은 **HTML 해석**에 그침

### HTTP API

WAS가 클라이언트로부터 HTML이 아닌 **데이터**를 전달받는다.

- 주로 JSON 형식 사용

WAS가 해당 데이터를 재가공해서 리턴한다. 꼭 HTML 형식이 아니어도 되는 것.

이러한 구조에서는 데이터 형식만 맞춘다면 **다양한 시스템에서 WAS를 호출해 결과물을 조회**할 수 있다.

- 웹과 서버, 앱과 서버, 서버와 서버 간 통신 모두 가능

웹 브라우저는 데이터만 주고받고, UI 화면이 필요하면 직접 프로세싱해낸다.

#### HTTP API의 다양한 시스템 연동

주로 **JSON**형태로 데이터 통신

UI 클라이언트와의 통신으로는

- 앱 클라이언트

- 웹 브라우저에서 JS를 통한 API 호출

- React, Vue.js 같은 웹 클라이언트

서버와의 통신으로는

- 주문 서버와 결제 서버 간의 통신 (MSA)

- 기업 간의 데이터 통신

### SSR - 서버 사이드 렌더링

**서버에서 최종 HTML을 생성**해서 클라이언트에 전달한다.

주로 정적인 화면에 사용함

- JSP, 타임리프 등

### CSR - 클라이언트 사이드 렌더링

웹 브라우저가 자바스크립트를 사용해, 최종 HTML을 동적으로 생성함

주로 동적인 화면에 사용

- 웹 환경임에도 마치 앱처럼 필요한 부분만 변경하는 페이지

- React, Vue.js 등

#### 렌더링 과정은?

- 웹 브라우저가 HTML을 요청함
  
  - 데이터 부분이 다 비어있는, 껍데기 정적 HTML

- 웹 브라우저가 자바스크립트를 요청함
  
  - 자바스크립트에는 클라이언트 측 로직과, HTML 렌더링 코드가 담겨있음

- 웹 브라우저가 HTTP API로 데이터를 요청함

- 자바스크립트로 최종 HTML을 렌더링

---

## 자바 웹 기술 역사

### 과거 기술

#### 서블릿

- 1997년

- HTML 생성이 어려운 편

#### JSP

- 1999년

- HTML 생성이 상대적으로 편리함

- 비즈니스 로직까지 JSP 파일에 들어가면서, JSP의 역할이 너무 방대해짐

#### 서블릿, JSP 조합 MVC 패턴

- 모델, 뷰, 컨트롤러로 역할을 나누어 개발

- 비즈니스 로직과 화면 렌더링을 철저하게 구분해보고자 하는 것이 핵심

#### MVC 프레임워크 춘추전국시대

- 2000년대

- MVC 패턴을 자동화하고, 웹 기술을 편리하게 사용할 수 있는 기능을 지원하는 **프레임워크**가 계속 만들어지던 시절

- 스트럿츠, 웹워크, 스프링MVC(구버전) 등

### 현재 사용 기술

#### 애노테이션 기반 스프링 MVC

`@Controller` 의 위대함..

나머지 MVC 프레임워크를 다 사장시키고 자바 웹 기술을 통일

#### 스프링부트의 등장

**서버를 내장**한 스프링 MVC 프레임워크

- 과거에는 서버에 WAS (Tomcat) 을 직접 설치하고, 소스는 war 파일 형태로 만들어서 설치된 WAS에 배포하는 방식
  
  - 개발자가 신경쓸 부분이 많음

- 스프링부트는 빌드 결과인 jar 파일에 WAS 서버를 포함시켜버림
  
  - 빌드 및 배포가 매우 단순

### 최신 기술 - 스프링 웹 기술의 분화

- **Web Servlet** - Spring **MVC**

- **Web Reactive** - Spring **WebFlux**

#### 스프링 웹 플럭스

##### 특징은?

- **비동기 Non-Blocking** 처리

- **최소 쓰레드, 최대 성능** - 쓰레드의 **컨텍스트 스위칭** 비용을 효율화

- **함수형** 스타일 - 동시처리 코드 효율화

- 서블릿 기술 사용하지 않음

##### 단점

- 기술적 난이도가 매우 높은 상황

- RDB 지원 부족

- 일반 MVC의 쓰레드 모델도 충분히 빠른 상황이라, 대체할 이유가 적음

- 실무에서 사용하기에 **오버스펙**일 가능성 높음

### 자바 뷰 템플릿 역사

뷰 템플릿은, **HTML을 편리하게 생성하는 뷰 기능**

#### JSP

속도가 느리고, 기능이 부족

#### 프리마커, 벨로시티

속도 문제를 해결했고, 기능이 다양한 편

#### 타임리프(Thymeleaf)

**내추럴 템플릿** 

- HTML의 **모양**을 유지하면서 뷰 템플릿을 적용

스프링 MVC와 강력한 연계성

- 스프링에서 밀어주는 중

성능 측면에서는 프리마커, 벨로시티가 더 좋지만, 충분히 빠름


