# MVC 프레임워크 만들기

---

## 프론트 컨트롤러 패턴

**프론트 컨트롤러 서블릿** 하나로 **모든** 클라이언트의 요청을 받는다.

프론트 컨트롤러가, 요청에 맞는 컨트롤러를 **찾아서 호출**

- 입구를 하나로 만듦으로써

- **공통 로직**을 일괄적으로 처리한다.

이 때, 프론트 컨트롤러를 제외한 나머지 컨트롤러는 **서블릿을 사용할 필요가 없어진다**.

### 스프링 웹 MVC와 프론트 컨트롤러

스프링 웹 MVC의 핵심 또한 **FrontController**이다.

웹 MVC의 `DispatcherServlet`이 프론트 컨트롤러 패턴으로 구현되어 있다.

---

## 프론트 컨트롤러 도입 - v1

### 예제 코드 요약

- 서블릿과 유사한 로직을 가진 (서블릿은 아닌) 컨트롤러 **인터페이스**를 제작한다.

- 기능 별 컨트롤러를 해당 인터페이스에 의존하여 구현한다.

- `FrontController` 를 만들어서 유일한 서블릿으로 선언한다.
  
  - `urlPath` 에서 `/*` 로 경로를 선언해서, 특정 url 이하 모든 요청을 인입시킨다.

- FrontController 는 Map으로 실제 URI 와 컨트롤러를 매핑시켜 가지고 있다.

- 요청이 들어왔을 때, `if - else` 처리하여 요청에 부합하는 컨트롤러로 요청을 이관 및 처리한다.
  
  - Unknown URI에 대해서는 **404** 처리한다.

---

## View 분리 - v2

앞선 코드에서는 모든 컨트롤러가 뷰로 이동하는 부분에서 중복이 있었다.

하드코딩도 많아서 안전하지 않다.

### 예제 코드 요약

- 기본적으로 v1의 구조적 리팩토링

- `Controller`가 직접 JSP 경로를 지정해서 렌더링 처리를 담당하던 부분을, `FrontController` 로 이전한다.

- `Controller`는 `MyView`라는 클래스를 반환처리하고,

- `FrontController` 가 해당 클래스의 `render()` 메서드를 호출하면 비로소 JSP 포워딩이 이루어진다.

- **화면 렌더링**이라는 역할을 컨트롤러로부터 분리해준 것에 의미가 있다.

---

## Model 추가 - v3

### 서블릿 종속성 제거

컨트롤러 코드에 서블릿 Req, Rsp가 파라미터로 들어와 있다.

- 컨트롤러를 동작시키려면 **서블릿 기술을 반드시 알아야 한다**.

- 테스트가 어렵다.

사실 컨트롤러가 필요로 하는 건 Req 내부 파라미터 정보이기 때문에, 요청 파라미터만 `Map` 으로 넘기도록 바꿔본다.

- `Model` 을 사용한다는 의미가 된다.

### 뷰 이름 중복 제거

컨트롤러에서 지정하는 뷰 이름에는 중복이 많다.

컨트롤러가 뷰의 **논리명**만 지정해도 되도록 하고, 물리적인 위치는 **프론트 컨트롤러가 처리하도록** 단순화한다.

- 물리적인 경로가 바뀐 경우, **프론트 컨트롤러만 고쳐도 된다**.

### 예제 코드 요약

- `Controller` 인터페이스에서 서블릿 관련 코드를 제거하고, 요청 파라미터가 담긴 Map에 의존하도록 한다.
  
  - `FrontController` 에서 대신 서블릿 관련 코드에 의존하면서 `paramMap` 을 생성해 넘겨준다.

- `Controller` 가 뷰에서 사용할 `Model` 을 반환하는 과정에서도 서블릿 관련 코드에 의존하지 않기 위해, `ModelView` 라는 클래스를 생성한다.
  
  - 해당 클래스에서 `Model`에 해당하는 데이터를 `Object` 형으로 가져가고,
  
  - v2에서 개선했던 `View` 에 대한 부분도 함께 다뤄준다.
    
    - `View` 도 그대로 사용하지는 않는다.
    
    - 뷰 이름의 중복을 제거하기 위해, 컨트롤러에서는 뷰의 논리명만 `MyView`에 담아서 리턴하도록 한다.

- 프론트 컨트롤러는 이제 다음과 같은 역할을 담당하게 된다.
  
  - 클라이언트 요청을 적절한 컨트롤러로 이관
  
  - 컨트롤러에서 `ModelView` 를 반환받음
  
  - `View`에 해당하는 부분을 `viewResolver` 처리
    
    - 논리 경로를 실제 절대 경로로 변경해주는 공통작업
  
  - `View` 가 `Model`에 담긴 데이터를 렌더링하도록 지시

- `MyView`는 이제 `Model` 로 묶여있는 데이터를 렌더링하는 역할을 가져간다.
  
  - `response.setAttribute()` 처리하는 작업
  
  - JSP 포워딩까지.

---

## 단순하고 실용적인 컨트롤러 - v4

v3의 단점은, 컨트롤러 개발자가 `ModelView` 객체를 항상 생성하고 반환해야하는 부분이 **번거롭다.**

- 아키텍처 설계는 좋지만, 사용성이 떨어지는 부분.

### 예제 코드 요약

- `ModelView` 클래스를 애초에 FrontController 에서 생성해서 컨트롤러로 넘겨준다.

- Controller에서 `Model`에 담을 내용이 있다면 자유롭게 담으면 되고, 리턴값은 `ViewName` 만 String으로 처리한다.

- 컨트롤러에서 `ModelView`를 직접 만드는 부분만 제거했지만, 프레임워크 사용성이 크게 개선된다.

---

## 유연한 컨트롤러 - v5

### 어댑터 패턴

v4까지의 프론트 컨트롤러는 **단 하나의 컨트롤러 인터페이스만 사용**할 수 있다.

**어댑터 패턴**을 사용하면, 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있다.

#### 핸들러 어댑터

프론트 컨트롤러가 컨트롤러를 호출하려면, **핸들러 어댑터**를 반드시 통해서 호출해야 한다.

#### 핸들러

컨트롤러의 이름은 **더 넓은 의미의** 핸들러로 변경된다.

어댑터를 거쳐서 핸들러를 호출하기 때문에, 컨트롤러가 아니라 하더라도 무엇이든 그 자리에 들어갈 수 있다.

### 예제 코드 요약

- 프론트 컨트롤러는 부팅 시점에 다음 정보들을 로딩한다.
  
  - 클라이언트 요청 URL에 따른 컨트롤러(핸들러) 매핑 정보
  
  - 컨트롤러(핸들러)에 대한 핸들러 어댑터 매핑 정보

- 클라이언트 요청을 받으면 그에 부합하는 **핸들러**를 찾고,

- 핸들러에 부합하는 **어댑터**를 찾은 다음,

- **어댑터를 호출하여 실제 핸들러가 작동**할 수 있도록 구성한다.
  
  - 핸들러의 작동 방식은 기존 v4의 내용과 동일하다.
  
  - **다형성**을 적용해뒀기 때문에, 호출/반환 인터페이스만 유지하면 동일하게 작동하고 있다.

- 이로써 **어댑터 패턴**을 적용해 프론트 컨트롤러가 서로 다른 핸들러를 마음껏 사용할 수 있다.
  
  - 어댑터를 추가할 때, 프론트 컨트롤러에서 매핑 정보 몇 개만 추가하면 나머지 로직은 건드리지 않을 수 있다.

---

## 정리

#### v1 - 프론트 컨트롤러 도입

기존 구조 최대한 유지

#### v2 - View 분류

단순 반복되는 뷰 로직만 분리

- `MyView`

#### v3 - Model 추가

서블릿 종속성 제거,

뷰 이름 중복 제거

- `ModelView`

#### v4 - 단순하고 실용적인 컨트롤러

구현체에서 `ModelView`를 직접 생성하지 않도록 편리한 인터페이스 제공

#### v5 - 유연한 컨트롤러

어댑터 도입

유연하고 확장성 있는 프레임워크

# 
