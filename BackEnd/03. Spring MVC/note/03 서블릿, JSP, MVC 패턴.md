# 서블릿, JSP, MVC 패턴

---

## 서블릿으로 웹 애플리케이션 만들기

### 예제 코드 요약

- `HttpServlet` 을 상속받는 **웹 서블릿**을 여러 개 제작한다.
  
  - 각 서블릿은 request로부터 비즈니스 로직 처리와 화면 렌더링을 고유 `url-pattern` 에 맞춰서 진행한다.

- 화면 렌더링은 `setContentType("text/html")` 상황에서, `PrintWriter.write()` 메서드에 HTML을 직접 String으로 써넣는 방식이다.
  
  - 자바 로직으로 동적인 HTML 구현이 가능하다.

### 템플릿 엔진으로의 전환

서블릿으로 **동적인 HTML을 만드는 것**은 얼마든지 가능하다.

하지만 코드가 **극히 복잡하고 비효율적**이다.

자바 코드로 HTML을 만드느니, 차라리 **HTML 에서 동적으로 변경해야 할 부분만 자바 코드를 넣는 방식**이 편리할 것.

- **템플릿 엔진**이 이런 문제를 해결하기 위해 출시되었다.

템플릿 엔진으로는 JSP, Thymeleaf, Freemarker, Velocity 등

---

## JSP로 웹 애플리케이션 만들기

### 예제 코드 요약

- `<%@ page contentType="text/html;charset=UTF-8" language="java" %>` 로 시작하는 jsp 파일을 여러 개 만들어서, 동일한 웹 페이지를 구현한다.

- jsp 파일은 HTML 껍데기에 자바 코드가 섞여있는 듯한 모습인데, 실제로는 **서블릿으로 변환되어 실행**된다.
  
  - 그래서 **로직 흐름이나 파일 형태가 서블릿과 거의 유사**해보이며, 복붙도 가능한 수준
  
  - `HttpServletRequest` 와 `HttpServletResponse` 클래스는 별도의 import 없이도 자연스럽게 가져다 쓸 수 있다.

- `<% %>` 태그를 사용해서 자바 코드를 직접 입력할 수 있고,

- `<%= %>` 태그를 사용해서 자바 코드 결과물을 출력할 수 있다.

### 서블릿과 JSP의 한계

JSP로 전환하면, 서블릿 개발 시의 화면 렌더링을 위해 HTML을 만드는 작업이 비교적 편리해진다.

하지만 JSP도 **비즈니스 로직과 화면 렌더링 코드가 섞여있다는 단점**을 피할 수가 없다.

- 자바 코드, 리포지토리까지 모두 HTML과 섞여있는 코드

- JSP 하나가 너무 많은 역할을 하고 있다.

- 유지보수가 **불가능**

### MVC 패턴의 등장

비즈니스 로직은 다른 곳에서 처리하고, **JSP는 목적에 보다 부합하도록 HTML로 화면(view)을 그리는 일에 집중**하도록 한다는 사상

- **MVC 패턴**의 등장

---

## MVC 패턴 - 개요

### 너무 많은 역할

하나의 서블릿이나 JSP만으로 **비즈니스 로직**과 **뷰 렌더링**을 모두 처리하는 방식은 유지보수가 불가능한 코드를 만들어낸다.

- 간단히 UI 변경할 일이 있을 때, 비즈니스 로직을 함께 건드려야 하는 불합리성

#### 변경의 라이프 사이클

비즈니스 로직과 뷰 렌더링의 **변경 라이프 사이클**이 다르다는 점이 문제의 핵심이다.

UI 일부 수정과 비즈니스 로직 수정은 서로 다른 요구사항에서 발생할 가능성이 높고, 일반적으로 서로 영향을 주지 않는다.

#### 기능 특화

JSP는 애초에 **뷰 템플릿**으로, 화면 렌더링에 최적화되어 있다.

**화면 렌더링** 업무에 집중할 수 있도록 해주자.

### Model View Controller

MVC 패턴은, 하나의 서블릿이나 JSP로 처리하던 프로그램 코드를 **컨트롤러**와 **뷰** 영역으로 역할을 분리한 것이다.

#### 컨트롤러(Controller)

HTTP 요청을 받아서 파라미터 검증, 비즈니스 로직 실행, 뷰에 데이터를 전달 (**Model**)

#### 모델(Model)

뷰에 출력할 데이터를 담아둠.

뷰가 직접 비즈니스 로직이나 데이터 접근하지 않도록 함

#### 뷰(View)

모델에 담겨있는 데이터를 사용해서 화면을 그림

주로 HTML 생성

#### 참고

컨트롤러에 비즈니스 로직을 넣는 것은 지양하도록 한다.

- 컨트롤러가 너무 많은 역할을 담당하지 않도록.

비즈니스 로직을 담당하는 **서비스 계층**을 별도로 만들어서 처리하는 것이 정석.

---

## MVC 패턴 - 적용

서블릿을 컨트롤러로, JSP를 뷰로 사용해서 MVC 패턴을 구현할 수 있다.

### 예제 코드 요약

- 서블릿 컨트롤러를 만들고, 내부 로직에서는 단순히 **JSP 파일을 호출하는 내용**만 담도록 한다.

- JSP 호출은 `RequestDispatcher` 를 사용한다.
  
  - `dispatcher.forward(request, response)` 하면, 지정한 path 에 있는 JSP 파일을 호출한다.
  
  - JSP 파일이 호출되는 로직은 **리다이렉트가 아니다**. 서버에서 메서드 호출하듯이 바로 **포워딩**하는 방식.
    
    - 리다이렉트는 클라이언트로 **응답이 나갔다가** 클라이언트가 다시 리다이렉트 경로로 요청을 주는 방식.
      
      - 클라이언트가 인지 가능하고, URL 경로도 변경됨
    
    - 포워드는 서버 내부에서 호출이 발생하므로, 클라이언트가 인지하지 못함

- 이런 방식으로 사용하는 JSP는 `webapp` 경로 중에서도 `WEB-INF` 하위에 있는 것이 바람직하다.
  
  - 웹 서버는 기본적으로 절대경로로 파일시스템 접근이 열려있지만,
  
  - `WEB-INF` 하위의 파일에 대해서는 컨트롤러를 반드시 거쳐서 들어갈 수 있도록 정해져 있다.

- 서블릿에서 개념적으로 Model에 해당하는 것은 `request.setAttribute()` 
  
  - Attribute에 데이터를 담아서 JSP로 포워딩하면,
  
  - JSP에서는 `${}` 표현식으로 Attribute에 담긴 데이터를 편하게 가져다쓸 수 있다.

### 정리

클라이언트의 요청은 **항상** 컨트롤러가 받는다.

- 컨트롤러도 서비스 로직을 별도로 호출해서, 비즈니스 로직을 분리한다.

- 비즈니스 로직 결과물은 모델에 담겨서 뷰로 반환된다.

- 뷰로 반환될 때 **포워딩**이 적용되며, 뷰 파일인 jsp 는 웹 서버에서 직접 접근할 수 없도록 막아둔다. (`WEB-INF`)

JSP에서 뷰 로직을 구현할 때는 `jstl` 라이브러리를 사용해서, 자바 코드를 보다 더 배제하는 방향으로 한다.

---

## MVC 패턴 - 한계

컨트롤러에서 중복이 너무 많다.

필요하지 않은 코드도 많다.

### MVC 컨트롤러의 문제점

#### 포워드 중복

View로 이동하는 코드가 항상 중복 호출된다.

#### ViewPath 중복

`prefix` 부분과 `suffix` 부분이 모두 중복이다.

해당 부분에서 변경이 발생하면, **전체 코드를** 변경해야 한다.

#### 사용하지 않는 코드

`HttpServletRequest` , `HttpServletResponse`를 반드시 다 사용하는 것이 아닌데, 계속 파라미터로 들고 다녀야 한다.

- 해당 클래스는 테스트케이스에 활용하기도 어렵다.

#### 핵심: 공통 처리가 어려움

컨트롤러의 모든 `service` 메서드에서 처리해야하는 로직을 공통화해줄 필요가 있다.

보다 정확히는, 컨트롤러 **호출 전**에 공통 기능 처리가 필요하다.

이걸 해결하기 위해 등장한 것이 **프론트 컨트롤러** 패턴.

- **입구를 하나로 통일한다.**

- 스프링 MVC의 핵심도 프론트 컨트롤러.


