# 관계 데이터 모델과 관계 연산자

---

# 관계 데이터 모델과 관계 연산자

## 데이터베이스 시스템

응용 프로그램은 기본적으로 host lang + data lang

Data lang 쪽이 100% **SQL**

- 1970년대에서부터 ISO가 data lang인 SQL을 표준화해놓고 있다.
- SQL이 애플리케이션에 꽂혀있는 걸 embedded SQL이라고 한다.
  - 한 번 프로그램에 입력되면 한 시간에도 수십 만 번 호출되기 때문에 잘 바뀌는 일도 없다.

SQL로 데이터를 검색하고 갱신하는 시스템이 **DBMS**

DBMS가 관리하는 데이터는 2가지

- 데이터베이스의 전체 구조인 schema
  - **스키마 또한 데이터다!**
- schema에 따라 입력되는 실제 데이터 Data

DBMS의 기반 지식은 관계 데이터 모델 (RDB)이다.

---

# 관계 데이터 모델

## 관계 데이터 구조

모든 데이터를 잘 쪼개서 **테이블**로 표현하여 저장한다.

- 학문적인 명칭은 **정규화**
- SQL을 잘 다루려면, 데이터가 어떻게 쪼개져있는지 전체 구조를 파악하는 게 가장 중요하다.
  - **설계**를 파악하는 능력이 필요하다는 뜻

### 용어

Domain, Attribute, Record type, Record instance(tuple)

### 다중값 속성

하나의 attribute에는 하나의 value만 입력되어야 한다.

- 단일값 속성만 허용
- *set value*는 허용되지 않는다.
  - 최근의 RDBMS는 편의상 key값이 아닌 attribute에 대해 set 자료형 입력을 허용해주고 있다.
  - 그래도 FK에 대해서는 set value가 엄격하게 금지됨. PK는 말할 필요도 없고..

**정규화**가 덜 된 것이라고 말할 수 있음.

## 관계 데이터베이스

관계 데이터 구조를 이용해 데이터베이스를 구축함.

tuple들을 모아서 relation (테이블)을 형성.

정보를 조회하고자 할 때는, 필연적으로 테이블을 여러 개 거쳐야 함

그 때 필요한 도구가 **SQL**

---

# 관계 제약

### 건전한 상태 (sound state)

데이터베이스가 **무결**한 상태를 유지해야 한다.

- 테이블 하나에 튜플이 30억 개 담겨있는데, 어떤 FK가 다른 테이블에 없다면?
- 데이터베이스 전체를 신뢰할 수 없다. 통째로 폐기해야 하는 상황

즉, 데이터베이스에 저장된 데이터는 정확하고, 데이터 간의 불일치가 없어야 한다.

### 무결성 제약

건전한 상태를 위한 제약.

## 기본키와 외래키

### 기본키

테이블에서 튜플을 unique하게 식별할 수 있는 **속성의 집합**.

### 외래키

어떤 테이블의 PK에 있는 값만을 갖는 **속성의 집합**

FK는 기본적으로 흔히 말하는 *키* 가 아니다. 일반 속성에 불과. 하지만 다른 테이블에서는 PK여야 한다.

- FK 여러 개를 묶은 집합을 PK로 사용하게 되는 경우가 많다.

### 부모-자식 테이블

**자식 테이블**은 FK가 정의된 테이블.

**부모 테이블**은 FK가 *참조하는* PK가 정의된 테이블

- 자식 테이블은 부모 테이블에 의존한다.

## 무결성 제약

### **개체 무결성**

entity integrity

PK에 관한 내용으로,

PK 값은 UNIQUE해야 하고 NOT NULL해야 한다.

### 참조 무결성

referential integrity

FK에 관한 내용으로,

FK 값은 부모 테이블의 PK 값과 **같거나** 아예 **NULL** 값을 가져야 한다.

---

# 관계 대수

대수(algebra)는 연산자와 피연산자로 구성.

피연산자와 결과값은 모두 동일한 **데이터 타입**이어야 한다.

### 관계 대수

relational algebra

**릴레이션** 조작을 위한 대수 연산자.

다시 말해 **테이블** 간의 대수 연산. 당연히 그 결과값도 테이블로 계산된다.

### 폐쇄 성질

피연산자와 연산 결과는 모두 같은 데이터 타입이어야 한다는 제약 조건.

아무리 복합적인 연산을 시도해도, 그 결과값의 데이터 타입은 그대로 유지된다.

## 관계 대수의 연산자 (관계 연산자)

릴레이션 간의 연산자 종류들.

크게 집합 연산자, 순수 관계 연산자, 확장된 관계 연산자로 분류

- SQL 문법을 알기 전에 관계 대수식을 먼저 알자
- 프로그래밍은 결국 전부 다 수학으로 표현되는 것. SQL 이면에는 대수학이 있다.

---

# 집합 연산자

## 합집합, 교집합, 차집합

union compatible 해야 해당 연산이 가능하다.

- attribute의 개수가 같아야 하고, 대응되는 pair 간의 domain이 동일해야 한다.

## 카티션 프로덕트

집합 간의 **곱하기 연산**이라고 보면 된다.

union compatible하지 않아도 된다.

---

# 순수 관계 연산자

## select

릴레이션의 **수평적 부분집합**. horizontal subset

특정 조건식을 만족시키는 튜플들로 구성된 부분집합을 결과값으로 도출한다.

### project

릴레이션의 **수직적 부분집합. vertical subset**

타겟이 되는 **속성 리스트**만으로 구성된 부분집합.

project 연산의 결과값 내에서 중복된 튜플이 존재한다면, **제거된다.**

- 집합 정의상 당연하다.
- project 연산에서는 **중복**에 대한 생각을 반드시 할 것
- 만약 타겟 속성에 PK를 포함시킨다면, 자동적으로 중복이 배제되어 있을 것

### 질의

특정 테이블에서 어떤 데이터를 뽑아내는 질의를 생성할 때,

기본적인 순서는 셀렉트 → 프로젝트다.

## join (inner join)

기본적으로 두 개의 테이블을 한 개의 테이블로 묶는 연산

- 같은 결과를 서브쿼리를 이용해서 만들어낼 수도 있긴 하다. 성능도 더 좋음
- 근데 기본 원리가 join 비슷하기 때문에 join을 제대로 알고 서브쿼리로 넘어갈 필요

**카티션 프로덕트를 응용**하는 연산이다.

- 두 테이블 간의 카티션 프로덕트를 만들어놓고 생각하면 편하다.
- 그런만큼 성능 상 매우 위험한 연산이라는 점을 명심

### 세타조인

카티션 프로덕트의 결과물에, 조건식을 적용하여 셀렉트하는 것과 같다.

### 등가조인

세타조인에서 조건식의 연산자가 = 인 경우

### 자연조인

1단계: 피연산 테이블의 **공통되는 속성**을 **조인 속성으로 두고 등가조인**한 뒤,

2단계: 결과값에서 **중복**되는 조인 속성 중 하나를 **제거**하는 연산.

수학적으로는,

- 양쪽 테이블의 속성집합 간 교집합을 속성집합으로 사용한 가운데
- 양쪽 테이블을 합집합.

---

# 확장된 관계 연산자

## outer join

조인 대상이 되는 양쪽 테이블에서 결과에 포함되지 않는 튜플도 결과에 포함시키는 연산

대응되지 못한 속성값은 NULL 값으로 채워진다.

방향을 left나 right로 표시해서 사용하게 된다.

## 그룹 연산과 집계 연산

### 그룹 연산 (group operator)

기준 속성 값이 **같은** 튜플끼리 그룹핑함.

그룹핑 결과에 대해서는 따로 visualizing하지 않음.

그룹핑 이후 집계 연산이 이루어지면, 그룹의 개수만큼 집계 연산이 발생

### 집계 연산 (aggregate operator)

기준 속성 값에 대해 **통계치**를 계산한다.

- count, sum, avg, min, max, stddev, varian 등

집계 연산의 결과값 또한 릴레이션인 점 잊지 말 것

- AVG 결과값이 16 으로 나왔어도,
- single attribute + single tuple의 상태인 것

## 작명 연산

관계 대수식이 복잡할 때 중간 결과가 되는 릴레이션에 이름을 붙이고, 그 속성의 명칭을 변경하는 기능

---

# SQL 질의문

## SQL 검색문

일반 형식은 select from where.

- select가 project 연산자의 타켓 속성 리스트
- from이 join 연산자의 조인 조건식
- where이 select 연산자의 튜플 조건식
