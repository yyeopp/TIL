# DML - 단일 테이블 검색문과 갱신문

---

# SQL DML

검색을 위한 query와 갱신을 위한 query

# 검색문의 형식

## SELECT 문

일반적인 형식은 `select-from-where`

거기에 `join + on` `group by + having` `order by` `limit` 정도를 추가할 수 있음

- MySQL은 `from` 절을 생략할 수 있음
  - `length()` 같은 내장함수 사용하기 위함
- Oracle은 `from` 절을 생략할 수 없음 → 표준을 준수
  - 대신 `dual` 이라는 dummy table을 사용

## select문의 실행 순서

```sql
select
from
where
group by
    having
order by
limit
```

1. `FROM` 실행 대상 테이블을 참조한다.
2. `WHERE` 조건에 맞는 튜플만 선택한다.
3. `GROUP BY` 기준 컬럼의 값에 따라 튜플들을 그룹핑한다.
4. `HAVING` 각 그룹별로 조건에 맞는 그룹을 선택한다.
5. `SELECT` 선택된 튜플에서, 기술된 컬럼이나 표현식만 출력 및 계산한다.
6. `ORDER BY` 튜플을 정렬한다.
7. `LIMIT` 정해진 범위의 튜플만 출력한다.

## SELECT 문의 종류

여러 개의 테이블이 입력되고, **하나의** 테이블이 출력된다.

- 관계 대수의 **closure property**

출력 테이블 형태에 따라,

- 다중행 질의
- 다중값 질의
- 단일값 질의

---

# 검색문의 SELECT 절

## SELECT문의 SELECT절

검색 결과에서 출력한 컬럼들을 명세한다.

관계 대수 상에서는 **project** 연산자에 해당한다.

### ALL과 DISTINCT

ALL 조건은 **디폴트** 값으로, 결과값의 튜플이 중복되어도 그대로 다 출력한다.

DISTINCT 조건은 project 연산자 기존 정의대로 중복을 제거한다.

### column alias

컬럼에 출력용 별칭을 부여한다.

`AS` 를 사용

- 표준 SQL에서 alias는 오직 **출력용이다.**
  - where, group by에서 사용하면 안 된다.
  - select, order by에서만 사용
- MySQL에서는 group by에서 허용해주고 있다.
  - 편하긴 한데, 사용하지 않는 방향으로..

## WITH 절을 이용한 임시 테이블 생성

**임시 테이블**을 통해 **두 개의 검색문을 연결**하는 장치.

with절로 검색(서브쿼리)한 실행 결과 테이블을 **메모리에 임시로 저장**하여, 주 검색문(메인쿼리)에서 사용할 수 있도록 함.

주 검색문 실행 완료 시 임시 테이블은 삭제

- 관계 대수에서는 rename 연산자.

서브쿼리처럼 두 개의 테이블을 연결하는 기능으로 사용하는 의미도 있지만,

단일 테이블 조회 시 **쿼리문의 가독성을 높이는** 장치로도 사용할 수 있다.

- 대신 단일 테이블 조회에 대한 퍼포먼스는 감소한다.
- 임시 테이블에 대해서는 **인덱스** 부여가 불가능하다는 점에서도 퍼포먼스 감소가 크다.

## 새로운 컬럼 생성

산술 표현식을 넣거나, 문자열을 새로 생성함으로써 기존 테이블에 없던 새로운 컬럼을 생성

- 일반적인 수식 연산자, `concat` 함수

`CASE` 표현식을 통해 `IF-THEN-ELSE` 기능을 제공한다.

- 특정 컬럼을 비교연산자 `=` 로 다중 비교한다면 `case expr` 이렇게 시작
- `else`를 생략 시 디폴트 값은 NULL

---

# 검색문의 WHERE 절

결과 테이블에서, 튜플 조건식이 true로 떨어지는 튜플만을 선택하는 절

관계 대수에서는 select 연산자

## 연산자의 종류

일반적인 비교 연산자, SQL 연산자, 논리 연산자로 구분

- 비교 연산자 중 `!=` 의 의미를 가지는 건 `<>`라는 걸 주의
- SQL 연산자는 자연어와 매우 유사하게 구성됨
  - between + and, in, not in, like, not like, is null, is not null
  - in 연산자는 다중행으로 비교하는 것도 가능하다
- 비교 연산자, SQL 연산자가 논리 연산자보다 높은 우선순위를 가짐

### NULL

값이 존재하지 않는 것을 표현할 떄 사용.

ASCII 코드 00 값으로 저장된다.

어떤 값과도 계산 혹은 비교할 수 없음

- NULL이랑 산술 연산하면 결과는 항상 NULL
  - 보통 `coalesce()` 함수를 적용하여 NULL을 숫자 0으로 대체해서 활용하는 편
- NULL이랑 비교 연산하면 결과는 항상 FALSE
  - NULL을 위한 고유 연산자인 `is null` 과 `is not null` 사용 가능
  - `where attribute = null` 이라고 썼으면, where절의 결과가 항상 false 이므로 **비어있는 테이블**이 결과값으로 출력됨
    - *에러가 아님*

---

# 검색문의 GROUP BY 절과 HAVING 절

GROUP절은 기준 컬럼 값에 대해 동일한 값을 가지는 튜플들을 그룹핑한다.

그 중에서도 HAVING 절을 통해 원하는 조건을 만족하는 특정 그룹만 선별할 수 있다.

그룹핑하는 이유는 보통 **집계 함수**를 통해 **통계치**를 생성하기 위함.

- group by 절을 사용할 때는, select에 **기준 컬럼**을 적어주는 게 예의다.

## 집계 함수 (Aggregate Functions)

*다중행 내장 함수*에 해당한다.

- 입력은 다중행, 출력은 **단일값**

주요 함수들은 count, sum, avg, min, max, stddev, varian, group_concat

- `count(*)` 하면 **PK 컬럼** 값의 개수를 카운팅해준다.
- `group_concat()` 은 잘 안 배우는데 자주 씀

집계 함수를, **WHERE 절에서 사용하는 건 불가능**

- WHERE 절은 기본적으로 단일 튜플에 대한 조건식이기 때문

### COUNT() 함수

기준 컬럼에 대해 **NULL이 아닌** 값의 개수를 리턴한다.

- 기준 컬럼에 PK가 들어간다면 결과는 `count(*)`와 동일
  - **PK의 일부**를 넣었다고 해도 결과는 동일하다.
  - `count`는 중복을 제거해주지 않고 **NULL만 제외**하기 때문
  - PK의 일부라면, **무조건 NOT NULL**이다.
- 기준 컬럼을 NON_PK로 잡았다면, NULL이 있을 수 있으므로 결과값이 전체 튜플 개수보다 작거나 같다.
- DISTINCT 조건을 넣어서 중복을 제거해줄 수도 있다.

### GROUP_CONCAT() 함수: 비표준 함수

기준 컬럼의 값들을 **모두 연결하여 하나의 문자열 리스트로 생성**하는 함수

- distinct, order by 옵션 지정 가능.
- separator도 따로 지정 가능. 디폴트는 콤마
- GROUP BY 절과 함께 응용하는 방법이 쓸만하다.

## GROUP BY 절

### GROUP BY 절이 생성하는 임시 테이블

GROUP BY 절 실행 시, **그룹핑 기준 컬럼**과 **집계 함수 기준 컬럼**만으로 구성된 임시 테이블이 메모리에 생성된다.

- 메모리에 없는 컬럼은 당연히 select할 수 없다.

group by를 걸어둔 상태에서, select절에 그룹핑 기준 컬럼도, 집계 함수도 아닌 일반 컬럼을 조회하도록 한다면 그 결과값에는 아무 의미가 없다.

- 아예 에러를 내기도 하는데, MySQL에서는 에러가 안 나도록 모드 조정을 할 수 있다.

### 집계 함수의 중첩은 허용되지 않음

보다 정확히는, GROUP BY를 이중으로 적용하는 게 불가한 것.

집계 함수를 중첩적으로 사용하고 GROUP BY를 걸었을 때, 해당 그룹핑이 어떤 집계 함수에 적용되는 건지가 불분명하기 때문이다.

## HAVING 절

GROUP BY 절로 생성한 그룹을 조건에 맞춰 **필터링**하는 기능

- WHERE은 **튜플**에 대한 조건식이라는 점에서 정확히 구분해야 함
  - WHERE 절은 집계 함수를 사용할 수 없음
- HAVING 절의 그룹 조건식에서는, GROUP BY 절에 의해 생성되는 **임시 테이블의 컬럼**만 사용 가능하다.

WHERE 절과 HAVING 절을 적절히 조화하면 복잡한 조건을 적용해서 데이터를 추출할 수 있음

슬슬 어려워지는 부분

---

# 검색문의 ORDER BY 절

기준 컬럼 값을 이용하여, 튜플을 정렬함.

오름차순 asc, 내림차순 desc

- 디폴트는 asc
- 컬럼명 대신 column alias나 column의 위치도 명시하여 사용 가능

NULL에 대해, string으로 정렬을 하면

- MySQL과 SQL Server는 가장 작은 값으로 간주하고
- Oracle은 가장 큰 값으로 간주하고 있다.
- 표준이 없다.

---

# 검색문의 LIMIT 절

select 문이 출력하는 튜플의 최대 개수를 제한한다.

offset과 row_count를 입력할 수 있다.

- offset이므로, index는 0부터 시작한다.

## Top-N Query

**순위** 기능을 제공하는 쿼리. 동점자 처리에 대한 부분을 고려해야 함

### 윈도우 함수를 이용한 처리

행 간의 관계를 쉽게 처리하기 위한 함수.

MySQL에서는

- `ROW_NUMBER()` 함수로 튜플에 일련번호를 부여하거나
- `RANK()` 함수로 동점자를 고려한 튜플 순위를 제공하는 함수가 있다.

Oracle에서는 `ROWNUM` 이라는 시스템 컬럼으로 적용된 상황

- select 절에 넣으면, 가상의 컬럼인 rownum이 자동으로 입력되는 기능

### 윈도우 함수 주의사항

전역으로 넣는 것과 아닌 것의 차이

---

# 갱신문 (INSERT, DELETE, UPDATE)

기본적으로 단일 테이블에 적용하는 것이므로 문법만 알면 달리 파고들 게 없다.
