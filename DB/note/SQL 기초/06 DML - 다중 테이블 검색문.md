# DML - 다중 테이블 검색문

---

# 관계 대수 연산자

Binary Operator 중,
집합 연산자 전부
  - 합집합(UNION), 교집합(INTERSECTION), 차집합(DIFFERENCE), 카티션 프로덕트(Cartesian product)
- 순수 관계 연산자 join
- 확장된 관계 연산자 outer join

세 가지가 다중 테이블 검색문에 관여한다.

## 집합 연산자

E.F.Codd가 제시했다고.

SQL 표준에서는

- 합집합: UNION
- 교집합: INTERSECT
- 차집합: EXCEPT
- 카티션 프로덕트: CROSS JOIN

## 관계 연산자

순수 관계 연산자는

- 셀렉트, 프로젝트, 조인(inner), 디바이드

확장된 관계 연산자는 outer join

SQL 표준에서는,

- 셀렉트를 WHERE 절로
- 프로젝트는 SELECT 절로
- 조인을 inner join, outer join 으로
- 디바이드는 없다.


# 집합 연산자

## 집합 연산자

**형식이 동일한** 두 개의 테이블을 하나로 합치는 연산.

**Union compatible** 제약조건이 중요하다.

- 컬럼 개수가 동일해야 하고,
- 동일 위치의 컬럼이라면 데이터 타입이 **상호 호환** 가능해야 한다.
  - *동일한 데이터 타입* 까지는 아니여도 된다.
  - 컬럼명도 달라도 된다.

UNION, INTERSECT, EXCEPT, CROSS JOIN

## 집합 연산자의 형식

두 개의 SELECT 문으로 각각 결과 테이블을 작성한 후, (union compatible)

그 사이에 UNION, INTERSECT, EXCEPT 연산자를 넣으면 된다.

`ORDER BY`의 경우 **최종 결과**에 대한 정렬이므로, 중간에 넣으면 안 되고 마지막에만 기술한다.

- `UNION` 시 `DISTINCT` 나 `ALL` 옵션을 넣을 수 있다. 디폴트는 `DISTINCT`.
- MySQL에서는 UNION만 제공된다.

## UNION 연산 (합집합)

하나의 테이블에서 동일한 컬럼에 대해 UNION 연산을 하는 경우라면, 사실 WHERE 절에서 **OR** 연산을 수행하는 게 더 간단하다.

두 개의 SELECT 문은 **독립적으로 실행**되고,

DISTINCT 옵션이 걸려있다면 중복 제거를 위한 정렬 작업이 내부적으로 발생한다.

- 두 집합 사이에 중복이 없다고 확신한다면, ALL을 붙여주는 게 성능에 유리하다!

## INTERSECT 연산 (교집합)

UNION과 사용 방법이 같다. 하지만 MySQL의 경우 제공하지 않는 연산

INTERSECT를 사용하지 않는다면,

- 동일 테이블, 동일 컬럼에 대해서는 단순히 `AND` 연산으로
- 다중 테이블 상황이라면 WHERE절에서의 `IN + 서브쿼리` 으로 처리한다.

## EXCEPT 연산 (차집합)

마찬가지로 MySQL에 없다.

사용하지 않는다면,

- `AND + NOT` 연산을 쓰거나
- `NOT IN + 서브쿼리` 를 사용한다.

---

# 조인 (관계 연산자)

## JOIN 연산

**형식이 다른** 두 개의 테이블을 하나로 만든다.

- 두 테이블의 튜플을 하나로 이어 붙여서 **새로운 튜플**을 생성할 수 있다.

조인을 하려면, 두 테이블에 **공통의 조인 컬럼**이 존재해야 한다.

- 일반적으로 해당 컬럼은 **PK-FK** 관계를 가지고 있다. (**등가 조인**)
- 그렇지 않은 경우를 비등가 조인이라고 한다. (Cartesian product)

## JOIN 연산의 구현: Nested Loop Algorithm

기본적으로 JOIN 연산은, 프로그래밍 언어로 따졌을 때 이중 for 문이다.

어떤 쪽을 driving table로 잡을 것인가 잘 골라야, 성능 이슈를 잡을 수 있다.

## 다중 조인의 실행계획 (Execution Plans)

**중간 결과의 크기**는 다중 조인의 성능을 좌우한다.

- 기본적으로 두 테이블 간의 곱하기 연산이기 때문.

DBMS는 기본적으로 **Query optimizer**를 들고 있다.

- 가능한 실행계획을 전부 세우고 시뮬레이션을 돌려서, 그 중 최적 성능의 다중 조인을 실제로 실행시키는 것.
- 프로그래머가 조금 덜 신경써도 되긴 하지만, 애초에 잘 짜기도 해야 함

## 표준 SQL의 조인 연산

### WHERE 절 조인 (순수 관계 연산자)

WHERE 절에서 **검색 조건**과 **조인 조건**이 혼재된 형태.

- FROM 절에서 테이블 두 개를 그냥 콤마로 나열하고, WHERE 절에서 조인 조건을 서술
- 비교적 옛날에나 쓰던 방식이고, FROM 절 조인보다 기능이 적으며, 검색 조건과 섞여있어서 가독성도 낮다. 사용을 자제하자
- 물론 은행 코드는… 거의 대부분 이걸로 되어있을 것

기본적으로 INNER JOIN만 가능하다.

### FROM 절 조인 (확장된 관계 연산자)

FROM 절에서 **조인 조건**을 표현하는 것.

- 검색 조건과 명시적인 분리가 가능하여, 가독성이 비교적 좋다.

INNER, NATURAL, OUTER, CROSS JOIN이 모두 가능하다.

- INNER JOIN에 대해, ON 혹은 USING으로 등가 or 비등가 조인 조건을 서술

---

# WHERE 절 조인

```sql
SELECT t1.c1, t2.c2
FROM t1, t2
WHERE t1.c1 = t2.c2;
```

WHERE 절에서 비교연산자를 모두 사용할 수 있다.

- **등가 조인**의 경우 비교 연산자가 `=` 인 경우.
  - 거의 대부분 **PK-FK** 관계를 기반으로 한다.
- **비등가 조인**의 경우 비교 연산자가 `=` 이 아닌 경우.

## 테이블 별칭

FROM 절에서 테이블에 대해 alias를 선언하면, SELECT나 WHERE 절에서 활용할 수 있다.

- 가독성을 위해 가능하면 써주자.

---

# FROM 절 조인

## FROM 절 조인: 확장된 관계 연산자

---

# Outer Join

## 외부 조인 연산자

조인 조건을 **만족하지 않는** 튜플도 결과가 포함한다.

LEFT와 RIGHT JOIN이 있는데, 두 테이블 중 어느 쪽을 driving table로 할 것인지를 뜻한다.

FULL OUTER JOIN은, LEFT와 RIGHT한 결과를 UNION한 것과 동일하다.
