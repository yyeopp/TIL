# DML - 서브쿼리

---

# 서브쿼리

SQL문 (주로 SELECT) 안에 **포함되는 SELECT문**

- 메인쿼리와 서브쿼리로 구분

SQL문 거의 모든 위치에서 사용이 가능하다.

- SELECT 문에서 WHERE, SELECT, FROM, HAVING, ORDER BY 절
- 갱신문에서 INSERT의 VALUES, DELETE의 WHERE, UPDATE의 SET

## 주의사항

### 컬럼 참조의 제한

서브쿼리는 메인쿼리의 컬럼을 참조할 수 있으나, 메인쿼리는 서브쿼리의 컬럼을 참조할 수 없음

- 메인쿼리는 서브쿼리의 **결과물**만을 볼 수 있음
- 내부 동작에 대해서는 알지 못함. *black box* 같은 상태
- 단, FROM 절 서브쿼리는 동적으로 생성되는 inline view 테이블이므로, 일반 테이블처럼 다룸
  - 컬럼 참조 가능
  - 조인 테이블과 같은 취급

### ORDER BY 절 사용의 제한

WHERE절에 들어가는 서브쿼리는 ORDER BY 절을 사용하지 못한다.

- 정렬하는 게 애초에 의미없기 때문
- 메인쿼리 마지막에 들어가야 함


# WHERE 절 서브쿼리

## 분류

### 반환되는 결과의 형태에 따른 분류

**단일값** 서브쿼리

- 서브쿼리 결과가 1개 이하 단일값.
- 단일값 비교 연산자 사용 (=, <> 등등)

**다중값** 서브쿼리

- 서브쿼리 결과가 단일값들의 집합 (**컬럼 1개,** 다중행)
- 단일값 비교 연산자에 더해, `ANY`, `SOME`, `ALL` 이라는 한정자 사용 가능

**다중행** 서브쿼리

- 서브쿼리 결과가 다중값들의 집합 (**컬럼 여러개**, 다중행)
- 멤버쉽 연산자 `IN`, 존재 정량자 `EXISTS` 사용 가능

### 동작하는 방식에 따른 분류

**비연관** 서브쿼리

- 서브쿼리에 메인쿼리 컬럼이 없음
- 메인쿼리와 독립적으로, 1회 실행됨
- 메인쿼리에 **결과**만을 제공

**연관** 서브쿼리

- 서브쿼리에 메인쿼리 컬럼이 있음. 메인쿼리 테이블 값을 참조
- 메인쿼리의 **튜플마다** 서브쿼리가 실행됨
  - **조인**과 유사하게, 메인쿼리 테이블의 튜플 개수만큼 실행
- 메인쿼리 테이블을 **필터링**하는 느낌

## 비연관 서브쿼리

다중값 서브쿼리에 대해서는 **한정자**를 사용한 연산이 가능

- `ANY | SOME`: 서브쿼리의 결과 중 **어느 한 값이** 비교 결과를 만족시키면 true
- `ALL`: 서브쿼리 결과의 **모든 값**이 비교 결과를 만족시키면 true

다중행 서브쿼리에서는 멤버쉽 연산자, 존재 정량자 사용한 연산이 가능

- `IN`: 서브쿼리 결과 테이블의 어느 한 튜플이 특정 튜플과 동일하면 true
- `EXISTS`: 서브쿼리가 **있으면** true
  - 서브쿼리를 만족시키는 튜플을 1개라도 찾으면 더 이상 검색하지 않음
  - 연관 서브쿼리에서만 사용

## 연관 서브쿼리

서브쿼리에서 **메인쿼리 테이블의 컬럼을 사용**

메인쿼리와 서브쿼리 테이블의 컬럼을 모두 이용하는, **연관 조건**을 **서브쿼리의 WHERE 절**에 서술한다.

메인쿼리에서는 WHERE 절에서 **서브쿼리를 이용한 튜플 조건식**을 서술한다.

결과적으로 메인쿼리 테이블의 튜플을 **필터링**할 수 있다.

- 조인과 유사하나, 성능 면에서 우월하다.

### 연관 서브쿼리가 포함된 질의 실행

- 메인쿼리의 현재 튜플 컬럼 값을 읽고, 서브쿼리 연관 조건에 값을 대입한다.
- 메인쿼리 현재 튜플 값을 고정시키고 서브쿼리 테이블을 전부 조회하여, 조건을 만족하는 튜플들을 선택한다.
- 서브쿼리 결과물을 메인쿼리 튜플 조건식에 대입한다.
- 조건식이 true면, 메인쿼리의 현재 튜플이 선택된다.

메인쿼리 테이블에 n개 튜플이 있으면, 서브쿼리도 n번 실행

메인쿼리는 단 한 번만 실행된다.

### 연관 서브쿼리와 조인의 차이

**결과 테이블의 튜플 개수**

- 조인은 두 테이블의 **카티션 프로덕트**의 **부분집합**을 리턴한다.
  - 컬럼 자체도 두 테이블의 컬럼이 모두 포함된다.
  - 최악의 경우 두 테이블의 튜플 수를 곱한만큼의 결과물이 리턴된다.
- 연관 서브쿼리를 활용한 결과는, **메인쿼리 테이블**의 **부분집합**을 리턴한다.
  - 결과 테이블의 컬럼은 메인쿼리 테이블의 컬럼과 같다.
  - 최악의 경우라도 튜플의 최대 개수도 메인쿼리 테이블과 같다.
- 즉, 질의 중간 결과가 커지는 것을 막는 측면에서 유리하다.
- **메모리** 관리를 고려해야 하기 때문

**출력 가능한 컬럼**

- 조인은 두 테이블이 대등한 관계이기 때문에, 서로 자유롭게 컬럼을 참조할 수 있다.
- 연관 서브쿼리를 포함한 메인쿼리에서는 메인쿼리 테이블의 컬럼만 사용할 수 있다.
  - 즉, 한 테이블의 컬럼만을 포함하는 경우라면 웬만해서 연관 서브쿼리를 활용하자.

# 부록: 인덱스

기본적으로,

- 테이블 내 개개 튜플들이 하드디스크 상에 저장되는 위치는 완전히 랜덤이다.
- 디스크 상에서 튜플들이 sorting되어있다면 테이블 업데이트가 사실상 불가능하기 때문
- 별다른 인덱스 없이 테이블을 순회 탐색한다고 할 때, 각각의 튜플은 매번 디스크 IO해서 읽어야 한다 (최악의 경우)
- 튜플 하나에 200byte만 잡아도, 디스크 IO 최소 단위는 대체로 4kb 쯤 되므로 손실이 큼

특정 속성을 인덱스로 지정하면,

- 해당 속성의 value들을 모아서 BST로 만들고 관리
  - 해당 트리의 key는 컬럼의 실제 value들
  - 트리의 value는 해당 tuple이 존재하는 디스크 상 물리주소
  - 메모리에서 해당 트리 정보를 들고 있음
- 해당 속성에 대한 조회가 있을 시 메모리 상에서 탐색
  - BST이므로 log2 로 탐색 시간이 감소됨
- 서칭에 성공하면, 트리의 value를 참조하여 디스크 1회 조회만으로 원하는 튜플을 가져올 수 있음
  - 디스크 IO 회수를 획기적으로 단축시킨다는 점에서 속도 개선 효과가 크다.

그렇다면 모든 속성에 다 인덱스를 단다면?

- 인덱스 또한 데이터. 인덱스 용량 자체가 과도해지다보면 자칫 원본 테이블보다 커지기도 함
  - 인덱스는 기본적으로 메모리에 올려야하는데, 너무 크면 불가능
- 원본 테이블이 변경되면, 인덱스의 내용도 같이 변경되어야 함
  - 인덱스가 여러 개 달려있다면 그 관리비용도 커질 것

따라서, 조회가 자주 일어나는 속성 몇 개에 한정하여 인덱스를 다는 것이 바람직

- 그런 점에서 PK, FK는 당연히 인덱스가 필요

BST마저도 느려서, 요즘 DBMS는 모두 B-Tree를 사용 중

- 노드 안에 키 값이 여러 개라고 하는데 좀 어려움
- 검색 속도가 아주 빠름
- OS 파일시스템도 B-Tree 자료구조를 기반으로 한다고
