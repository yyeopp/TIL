# 알고리즘

---

# BFS

## 소개

루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법

깊이가 가장 얕은 노드부터 모두 탐색하고,

그 다음 깊이가 깊은 노드를 탐색하는 방식

## 특징

- 두 노드 사이 **최단경로**를 탐색하기 좋은 방식

- 주로 Queue를 사용

## 실생활?

- 바둑이나 오목 같은 게임 상황에서 보통 어디에 뒀을 때 어떻게 될 거고... 하면서 머릿속으로 계산한다
  
  - 이거는 DFS 예시임

---

# Dynamic Programming

## 소개

**optimization problem**

문제를 해결하는 최적의 답을 찾아야 하는 문제

maximum 혹은 minimum value를 가지는 solution을 찾는 문제들이 주를 이룬다.

## DP

optimization problem을 해결하는 **전략 중 하나**

**subproblem의 optimal solution을 활용**해서 problem의 optimal solution을 찾는 방식

겹치는 subproblems은 **한번만 계산하고 그 결과를 저장한 뒤 재사용**하는 특성

## 두 가지 접근 방식

### top-down

**recursive** 방식

subproblem 결과 저장은 **memoization**

- function 콜의 결과를 재귀적으로 저장

subproblems의 **일부만 계산**해도 최종 optimal solution을 구할 수 있을 때.

### bottom-up

**iterative** 방식 (for 루프를 돌면서)

subproblem 결과 저장은 **tabulation**

- 작은 값부터 테이블에 차근차근 넣어나가는.

**모든 subproblems을 계산**해야 최종 optimal solution을 구할 수 있을 때

### 어떤 걸 주로?

보통은 bottom-up.

top-down은 재귀적으로 콜하기 때문에 메모리 이슈 유발

function call을 계속 할 때마다 오버헤드 발생. 성능면에서 밀림

## 알고리즘 설계 순서

- 주어진 문제의 optimal solution이 **구조적으로 어떤 특징을 가지는지** 분석

- **재귀적 형태**로 optimal solution의 value를 정의

- 주로 bottom-up 방식으로 optimal solution의 value를 구함

- 지금까지 계산된 정보를 바탕으로 optimal solution을 구함

## 언제 사용?

- optimization problem이 **optimal substructure**여야 한다

- optimization problem이 **overlapping subproblems**를 가져야 한다.

### optimal substructure

optimization problem의 optimal solution이 subproblems의 optimal solutions를 **포함**하는 구조.

- optimal substructure가 아닌데도 optimal substructure라고 판단하는 것을 주의해야 한다.

- subproblems는 **독립적**이여한다.
  
  - subproblem의 solution은 다른 subproblem의 solution에 영향을 주면 안된다.

### overlapping subproblems

재귀적 형태의 알고리즘이 동작할 때 **동일한 subproblems을 여러번 해결**해야 하는 경우

---

---

# 자료구조

## 왜 필요한가?

정보를 제대로 다루기 위해. 효율적으로 다루기 위해.

- 서점에서 책을 찾을 때 어떻게 했었는지를 떠올리자.

- 정보를 접근하고, 인출하는 효율

일정한 규칙으로 정리된 자료가 **자료구조**

구조화된 자료에서 원하는 것을 빨리 찾아내는 방법이 **알고리즘**

---

# Queue

- FIFO

- First In First Out

**순서를 보장한다!!**

## 사례

- 은행: 번호표를 뽑는 시스템.

- 게임을 할 때 큐를 돌린다고 하는 경우

- 메신저

---

# Array, Dynamic Array, Associate array

## Array

**같은 타입**의 데이터들을 저장하는 자료구조

**연속된 메모리 공간**에 데이터들을 저장

데이터 각각의 이름은 없지만, **인덱스**로 접근 가능

- 인덱스가 0에서 시작하는 이유는, 배열 내 첫번째 원소로부터 나머지 원소가 연속적으로 저장되는 구조기 때문

- 인덱스값은, *첫번째 원소로부터 떨어진 정도*를 나타낸다.

### 2차원 배열의 경우

기본적으로 메모리는 linear한 형태여서, 2차원 배열이여도 결국엔 **선형으로 저장**된다.

이 때 0행 0열, 0행 1열, 1행 0열, 1행 1열 이런 순서로 저장됨

- 그래서 배열순회 순서 바꾸면 부하가 심해진다 했던 것

## String의 경우

String은 그 자체로 객체이기 때문에, 배열로 저장할 때 저장되는 값은 각 **String 객체를 가리키는 주소값**이다.

즉, 메모리 어딘가에 String 객체는 흩어져 있고,

**그 주소값**은 String 배열에 해당하는 **연속된 메모리 공간에** 따로 저장되는 방식

### 특징

연속된 메모리 공간에 데이터들을 저장하기 때문에, **cpu cache**를 통해 같은 배열에 있는 다른 데이터에 접근하는 시간을 단축할 수 있다.

## Dynamic array

자바의 경우 ArrayList. 크기가 동적으로 변화하는 배열

데이터가 추가/삭제되면, **별도의 배열**을 하나 새로 만들고 거기에 기존 자료를 복사해넣는 방식으로 작동한다.

## Associative array

연관배열.

key-value pair들을 저장하는 ADT

같은 key를 가지는 pair는 최대 한 개만 존재

자바의 경우 Map.

---

# HashMap

## Map

**key-value pair**들을 저장하는 ADT

같은 key를 가지는 pair는 최대 한 개만 존재.

dictionary라고 불리기도 함

- mapping 정보가 존재하는 경우 사용 가능

### Map의 구현체

hash table과 tree-based

## Hash table

**배열**과 **해시 함수**를 사용하여, map을 구현한 자료 구조

일반적으로 **상수 시간**으로 데이터에 접근하기 때문에 빠르다.

### Hash function

임의의 크기를 가지는 type의 데이터를 **고정된 크기를 가지는 type의 데이터로 변환**하는 함수

- hash table에서 임의의 데이터를 **정수로 변환하는** 함수

- 변환된 결과를 *hash*라고 한다.

### Hash table은 어떻게 동작하는가?

- 기본적으로 table은 **자체 capacity**를 가진다.
  
  - 배열이라고 할 때 길이가 8짜리 배열이라고 생각

- key값을 hash function에 넣는다

- 도출된 hash에 대해 **%8** 해서 값을 구한다.

- 해당 위치에 자료를 삽입하는 방식

그런데, **서로 다른 key값**의 hash를 구해서 modular 연산을 한 결과가 **table상 동일한 위치**를 가리키고 있을 때가 있다.

- **Hash Collision.**

### Hash collision

- key는 다른데, hash가 같을 때.

- key와 hash가 모두 다른데, hash % map_capacity의 결과가 같을 때.

#### 해결방법

##### Separate chaining

> ##### 상황
> 
> 특정 key값으로 hash function을 돌려서 table에 가보니 이미 저장된 값이 존재함
> 
> 저장된 값의 key와 **equal test**를 했는데, false로 나옴
> 
> (true라면, 그냥 **value값을 대체**하게 됨)

이 때, 해당 table을 **LinkedList같은 자료형**으로 구현해놓고, 이미 저장된 pair에서 **새로운 pair를 레퍼런스로 참조**하도록 하는 것

이를 통해 해당 **index에 두 개 이상의 값을 넣을 수** 있음.

> 이후 key값을 통해 value를 get해오고자 한다면?

hash function을 돌려서 index를 찾은 뒤, 저장된 값의 key값과 입력된 key값이 **일치하는 지 확인**.

불일치한다면 **그 다음 pair가 존재하는 지 확인**하고, key값 일치 여부를 확인.

위 과정을 반복하면 탐색에 성공할 수 있다.

##### Open addressing (linear probing)

> 아까와 동일한 상황에서,

지정된 key값의 *다음* key값이 비어있다면 해당 pair를 거기에 할당해주는 방식.

- index가 2로 나왔지만 **이미 채워져 있으니까 3으로** 저장하는 것

탐색 시, 입력한 key와 hash가 가리키는 key가 다르더라도 *데이터가 없다*고 바로 판단할 수 없고, **다음 key값까지 탐색해봐야** 한다.

- Hash collision의 가능성이 존재하기 때문.

특정 key를 삭제하고자 할 시, 그동안 발생한 hash collision의 흔적을 남기기 위해 해당 index를 **완전히 비우는 게 아니라** *deleted* 같은 **더미값을 남겨야 한다**.

- 이후 탐색을 위해.

### Hash table resizing

hash table을 채우다가, 데이터가 충분히 많이 차면 table의 **capacity를 늘려줄 필요**가 생긴다.

**특히 open addressing** 방식을 사용할 때 절대적으로 필요함

- hash값 자체는 그대로 사용하되, **모듈러 연산의 분모만 달라지는 방식**으로 새로운 table에 할당하면 됨

- 기존에 **hash collision**으로 다른 값의 index에 삽입된 데이터가 있었다면, 테이블 확장 시 **제자리를 찾아갈 수 있게 된다**.

Java의 HashMap은 **capacity의 75**%가 채워졌을 때 자동으로 확장하게 된다고 함 (**2배** 확장)

- 해시충돌 해결방법은 **separate chaining**
  
  - LinkedList와 Red-black tree를 혼용한다고..

- **default capacity는 16.**

---

# 트리

## 개념

**노드들의 집합**.

각 노드는 **값**과 다른 노드를 가리키는 **레퍼런스**들로 구성

## 주요 용어

### 간선

노드와 노드를 연결하는 선

구현 관점에서는 레퍼런스를 의미

### 루트 노드

트리의 최상단에 있는 노드

트리의 시작점

### 자녀 노드

모든 노드는 0개 이상의 자녀 노드를 가진다

### 부모 노드

자녀 노드를 가지는 노드

### 형제 노드

같은 부모를 가지는 노드들

### 조상 노드

부모 노드를 따라 루트 노드까지 올라가며 만나는 모든 노드

### 자손 노드

자녀 노드를 따라 내려가며 만날 수 있는 모든 노드

### 내부 노드

자녀 노드를 가지는 모든 노드

### 외부 노드

자녀 노드가 없는 노드

리프노드, 단말노드로 불림

### 경로

한 노드에서 다른 노드 사이의 노드들의 시퀀스

어디서 어디까지 가는 경로를 나타낼 때, 그 경로에 존재하는 모든 노드를 적시함.

### 경로의 길이

경로에 있는 노드들의 수

### 노드의 높이

노드에서 리프 노드까지의 가장 긴 경로의 간선 수

리프 노드의 높이는 0이 된다는 것

### 트리의 높이

루트 노드의 높이

### 노드의 깊이

루트 노드에서 해당 노드까지 경로의 간선 수

### 트리의 깊이

트리에 있는 노드들의 깊이 중 가장 긴 깊이.

루트 노드에서 가장 먼 리프노드를 찾아서 그 깊이를 찾으면 됨

트리의 깊이 == 트리의 높이

### 노드의 차수

노드의 자녀 노드 수.

### 트리의 차수

트리에 있는 노드들의 차수 중 가장 큰 차수

### 두 노드 사이의 거리

두 노드의 최단 경로의 간선 수

### 노드의 레벨

노드와 루트 노드 사이의 경로에서 간선의 수

루트 노드의 레벨은 0

### width (넓이)

임의의 레벨에서 노드의 수

### 노드의 크기

자신을 포함한 자손 노드의 수

### 트르의 크기

트리의 모든 노드의 수

### 서브 트리

각 노드의 자녀 노드들을 재귀적으로 서브 트리를 구성한다.

## 주요 특징

- 루트 노드는 하나만 존재

- 사이클이 존재하지 않음

- 자녀 노드는 하나의 부모 노드만 존재

- 데이터를 순차적으로 저장하지 않는 비선형 구조

- 트리에 서브 트리가 있는 재귀적 구조

- 계층적 구조

## 이진 트리

각 노드의 자녀 노드의 수가 최대 2인 트리

### left / right child

가 존재하게 됨

### full binary tree

모든 노드는 자녀 노드가 없거나 두 개.

### complete binary tree

마지막 레벨을 제외한 모든 레벨에서 노드가 빠짐없이 채워져 있고,

마지막 레벨은 왼쪽부터 빠짐없이 노드가 채워져 있는 트리.

### perfect binary tree

모든 레벨에서 노드가 빠짐없이 채워진 트리

### degenerate binary tree

모든 부모 노드는 하나의 자녀 노드만 가지는 트리

left skewed와 right skewed로 나뉨

### balaced binary tree

모든 노드에서 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 최대 1인 트리

---

# B-Tree

## 개념

탐색 성능을 높이기 위해 균형 있게 높이를 유지하는, Balanced Tree의 일종

모든 leaf node가 같은 level로 유지되도록 자동으로 밸런싱.

자식 node의 개수는 2개 이상이고,

node 내에서 key는 1개 이상일 수 있음.

K차 B-Tree는, node의 자식 수 중 최댓값이 K인 경우.

### 조건

- node의 key 수가 k개라면, 자식 node의 수는 k+1개

- node의 key는 반드시 정렬된 상태여야 한다.

- 자식 node들의 key는 현재 node의 key를 기준으로, 크기 순으로 나뉘게 된다.
  
  - 노드 내 각 key의 왼쪽 자식 노드가 가진 key는 항상 자신의 key보다 작아야 하고, 오른쪽 자식 노드가 가진 key는 항상 자신의 key보다 커야 한다.

- root node는 항상 2개 이상의 자식 node를 갖는다.

- M차 트리일 때, root node와 leaf node를 제외한 모든 node는 최소 M/2, 최대 M개의 서브트리를 갖는다.

- 모든 leaf node들은 같은 level에 있어야 한다.

### 사용하는 이유

일반적인 트리의 탐색은 평균 시간 복잡도가 log이지만,

트리가 완전히 편향된 최악의 경우에는 N이다.

- root에서 leaf까지 모든 node를 방문해야 하기 때문.

트리가 편향되지 않도록 항상 밸런스를 유지하는 트리를 만들 시, 최악의 경우에도 log의 시간이 보장된다.

---

---

# Computer Science

---

# 객체와 클래스

## 객체

**상태**가 있고 **행동**을 하는 실체

- 예시: 자동차(멈춰 있는 상태, 방향을 전환하는 행동), 사람(자는 상태, 걸어가는 행동)

## 클래스

어떠한 **속성**이 있고 **어떻게 행동**하는지를 기술한 **설계도**.

- 차를 만들 때 반드시 설계도가 필요하다.

- `설계도 == 차`는 아니지만 차는 설계도로부터 만들어진다.

클래스에서 어떤 속성과 행동이 존재한다고 **설계도를 그려놓고**,

**new 키워드를 통해 생성**하면 그게 객체다.

- **instantiate**한다고 말하고, 이렇게 만들어진 것을 **instance**라고 함. 객체랑 인스턴스는 혼용되는 편

### 정리

객체를 만드는 설계도인 클래스에 해당 클래스가 가지는 속성의 정보가 들어있고, 

구체적인 객체를 만들 때는 해당 속성을 구체적으로 정의하여 해당 객체의 상태로 만들어줄 수 있다.

- 내가 원하는 속성과 행동을 구체적으로 **기술한 것이 클래스** 

- 그렇게 **기술한 대로 실체화된 것**이 객체

---

# Process, Thread, MultiTasking

## 용어

### Program

컴퓨터가 실행할 수 있는 **명령어들의 집합**

### Process

컴퓨터에서 **실행 중인 프로그램**

각각의 프로세스는 **독립된 메모리 공간을 할당** 받는다.

각각 명령어들과 데이터들을 가진다.

### CPU

명령어를 실행하는 연산 장치

### 메인 메모리

프로세스가 **CPU에서 실행되기 위해 대기하는 곳**

### IO

파일을 읽고 쓰거나, 네트워크의 어딘가와 **데이터를 주고 받는 것**

입출력 장치와 데이터를 주고 받는 것

## 단일 프로세스 시스템

한 번에 하나의 프로그램만 실행됨.

과거의 컴퓨터

### 단점

CPU 사용률이 좋지 않다.

프로그램 실행 중 IO 작업이 있으면, CPU는 아무것도 안 하고 쉰다.

### 해결책

여러 개의 프로그램을 **메모리에 올려놓고 동시에 실행**시키자!

현재 프로세스에서 **IO 작업이 발생**하면, **다른 프로세스가 CPU에서 실행**된다.

- 멀티프로그래밍

## 멀티프로그래밍

**CPU 사용률을 극대화**시키는 게 목적

### 단점

CPU 사용 시간이 길어지면, 다른 프로세스는 **계속 대기**한다.

- 두 개의 프로세스를 모두 사용하려고 계획을 했어도, 이미 사용 중인 프로세스가 IO 같은 작업 없이 계속 진행 중이면 다른 프로세스에게는 기회가 없다.

### 해결책

프로세스는 한 번 CPU를 사용할 때 **아주 짧은 시간 (퀀텀)만 CPU에서 실행**되도록 하자!

- **아예 번갈아가면서 쓰는 것**. 아주아주 짧은 시간 단위까지 쪼개서.

- 이를 **멀티태스킹**이라고 함

## 멀티태스킹

프로세스의 **응답 시간을 최소화**시키는 데 목적

CPU 자체는 돌아가면서 쓰는 중이지만, 그 돌아가는 텀이 매우 짧기 때문에 사용자 입장에서는 **즉각적인 응답으로 느껴질 수** 있다.

### 여전한 단점

하나의 프로세스가 동시에 여러 작업을 수행하지는 못함

- 여러 프로세스를 활용하는 것도 문제

**프로세스의 컨텍스트 스위칭**은 무거운 작업임

프로세스끼리 **데이터 공유**가 까다로움 (독립적인 메모리 공간)

**듀얼 코어**가 등장했는데 잘 쓰고 싶음

- 해결책은, 스레드!

## Thread

### 특징

프로세스는 **한 개 이상의 스레드를 가질 수 있다.**

- 한 프로세스에서 여러 작업을 동시에 수행하기 위해.

**CPU에서 실행되는 단위는 스레드**가 됨.

같은 프로세스의 스레드들끼리는 **컨텍스트 스위칭이 가벼움**.

스레드들은 자신들이 속한 프로세스의 **메모리 영역을 공유함**.

- 컨텍스트 스위칭이 가벼워지고

- **데이터 공유가 쉬워짐**

## 멀티스레딩

**하나의 프로세스가 동시에 여러 작업**을 실행하는 데 목적.

각 작업은 **별도의 스레드 단위**로 실행되는데,

**멀티코어 CPU**가 등장한 후 이걸 100% 활용하기 위해 고안된 방법

- 꼭 멀티코어가 아니여도, **하나의 프로세스가 두 개 이상의 스레드를 가지고 있다면** 멀티스레딩에 해당함.

### 확장된 멀티태스킹 개념

기존에는 프로세스 단위로 cpu time을 나눠가졌다면,

**여러 프로세스와 여러 스레드**가 아주 짧게 쪼개진 **cpu time을 나눠갖는 것**으로 확장

- 하나의 코어에 대해 스레드나 프로세스가 **경합**을 벌여서, cpu time을 나눠가지게 된다면 멀티태스킹!

## 멀티프로세싱

두 개 이상의 프로세서나 코어를 활용하는 시스템.

---

# I/O

## I/O

데이터의 입출력

### 종류

- **network(socket)**

- file

- pipe

- device

### socket

네트워크 통신은 **socket을 통해 데이터가 입출력**된다.

두 컴퓨터 사이 네트워크 통신은 각각 socket을 이용하는 것

#### backend server는?

네트워크 상의 요청자들과 각각 소켓을 열고 통신하게 됨.

## block I/O

I/O 작업을 요청한 프로세스나 스레드가 **요청이 완료될 때까지 블락되는 I/O**

- 스레드에서 I/O를 요청하면 **스레드는 block**되고, kernal로 call이 들어감

- **kernal에서 I/O**를 시작해서, response까지 받아옴

- data가 kernel에서 **user space로 이동**하고,

- 스레드의 **block이 풀리고 이어서 작업**을 진행

### Socket에서 block I/O는?

보통 scoket에는 **send-buffer와 recv-buffer**가 존재한다.

read용 socket이라면 revc-buffer에 데이터가 접수될 때까지,

write용 socket이라면 send-buffer에서 데이터가 나갈 때까지

해당 스레드가 block된다.

## non-block I/O

프로세스/스레드를 블락시키지 않고, **요청에 대한 현재 상태를 즉시 리턴**함

- 스레드에서 I/O를 요청하면 kernal로 call이 들어감

- kernal에서 I/O를 요청하되, **일단 접수됐다는 의미에서 즉시 -1값을 리턴**함
  
  - 이후 kernal은 **알아서 response를 받아옴**

- 스레드가 알아서 진행되다가, **다시 한 번** kernal로 call을 요청

- kernal에서 아까 받은 **data를 user space로 전달**

스레드가 다른 작업을 이어서 수행하는 장점.

### Socket에서는?

read용 socket에 요청이 들어왔을 때, recv-buffer에 아무 데이터가 없더라도 read측 스레드는 중단되지 않고, 적절한 에러코드만 반환한다.

write용 socket에서 요청을 넣을 때, send-buffer가 전송되지 못해서 계속 꽉 차있더라도 write측 스레드는 중단되지 않는다.

### 이슈

그럼, I/O *작업 완료를 어떻게 확인할 것인가?*

## non-block I/O 결과처리방식

### 반복적으로 확인하기

어느 순간 동일한 call을 다시 보내는 방식

- 완료된 시간과 완료를 확인한 시간 사이의 갭으로 인해 처리 속도가 느려질 수 있음. 
  
  - response를 진즉 받아왔어도, **call을 넣기까지 gap**이 존재한다.

- 반복적으로 확인하다보니 **CPU를 낭비**함
  
  - 소켓이 여러 개일수록 이게 심각해짐

> ##### 그냥 block I/O 쓰면 안 됨?
> 
> 소켓 8개 쯤 열어두고 하나씩 스레드 멈춰서 처리하고 있는데, 그 중 하나에서 처리가 지연된다면?
> 
> 아예 데이터 송수신이 되지 않는 에러가 발생한다면?
> 
> - 다른 소켓이 죄다 셧다운되는 치명적인 현상 유발

### I/O multiplexing (다중 입출력) 사용

관심있는 I/O 작업들을 **동시에 모니터링**하고, 그 중 완료된 I/O 작업들을 한 번에 알려줌

#### Linux epoll

??

### Callback / signal 사용

널리 사용되지는 않는 것 같음

### io_uring

file I/O에 좋다나

### 핵심은..

non-block I/O를 통해 **I/O 요청 완료 전에도 다른 일을 할 수가 있다**는 것

---

# 비동기 프로그래밍

## 프로그래밍 관점에서?

### 동기 프로그래밍

여러 작업들을 순차적으로 실행하도록 개발하는 방식

- Task2는 Task1이 끝나기 전에 실행할 수 없음

### 비동기 프로그래밍

여러 작업들을 독립적으로 실행하도록 개발하는 방식

- Task1이 끝나기 전이라도 준비만 됐다면 Task2 를 실행할 수 있음

- 어떻게?

#### 멀티스레딩과는 다르다!

비동기 프로그래밍은 여러 작업을 동시에 실행하는 프로그래밍 방법론이고,

멀티스레딩은 비동기 프로그래밍의 한 종류가 됨 

### 비동기 프로그래밍을 가능하게 하는 것은?

#### multi-threads

여러 작업들을 멀티코어와 멀티스레드를 이용해 동시에 수행

#### non-block I/O

싱글 스레드가 I/O 작업을 하되 block없이 여러 개를 동시에 수행

### 결론

최근 추세는,

- 스레드를 적게 쓰면서도

- non-block I/O를 통해

전체 처리량을 늘리는 방향

## 백엔드 아키텍처 관점에서

하나의 서비스는 기능과 역할에 따라 **여러 개의 마이크로서비스**로 구성되고, **이들 사이 커뮤니케이션**이 빈번하게 발생함

### 동기 communication

마이크로서비스 간 **API call**을 넣었을 때, 그에 대한 response가 오기 전까지 대기하는 방식.

- 간단하지만, API call이 연속적으로 이루어지는 와중에 하나만 터져도 application 전체가 터질 수 있다는 위험이 존재

### 비동기 communication

핵심은 **Message Q**를 사용하는 것.

마이크로서비스 간 API call을 넣고싶을 때, Message Q를 넣어두고 알아서 할 일 하고 있는 것

각 마이크로서비스는 **Q를 watch**하고 있다가, 뭐가 생기면 가져와서 처리하는 방식.

- 이러면 application 전체가 마비되는 일은 잘 없다.

- 되도록 이렇게 설계하는 것이 **안정적**

단, 마이크로서비스 간의 쌍방향 데이터 전달이 잦은 경우, API를 활용하는 게 속도 면에서 유리할 수 있다.

---

# DB & DBMS & DB system

## DB

**전자적으로** 저장되고 사용되는 **관련있는 데이터들**의 **조직화된 집합**

## DBMS

사용자에게 **DB를 정의하고 만들고 관리하는 기능**을 제공하는 **소프트웨어 시스템**

DB를 정의하다 보면 *부가적인 데이터*가 발생한다.

### metadata

**database를 정의하거나 기술**하는 data.

- data about data

metadata 또한 **DBMS를 통해 저장 관리**된다.

- 데이터 유형, 구조, 제약조건, 보안, 저장, 인덱스, 사용자 그룹 등

## database system

database + DBMS + 연관된 applications

전부 지칭하는 용어

## data models

DB의 구조를 기술하는 데 사용될 수 있는 **개념들이 모인 집합**

- DB 구조를 **추상화해서 표현할 수 있는 수단**을 제공한다

여러 종류가 있으며 추상화 수준과 DB 구조화 방식이 조금씩 다르다

DB에서 읽고 쓰기 위한 기본적인 동작들도 포함된다.

- DB 구조: 데이터 유형, 데이터 관계, 제약 사항 등

### data models 분류

conceptual, logical, physical

#### comceptual

일반 사용자들이 쉽게 이해할 수 있는 개념들로 이루어진 모델

추상화 수준이 가장 높음

비즈니스 요구 사항을 추상화하여 기술할 때 사용

> Entity-relationship model이 대표적
> 
> 약간 사업 설계하는 느낌에 가까움

#### logical

이해하기 어렵지 않으면서도 디테일하게 DB를 구조화할 수 있는 개념들을 제공

데이터가 컴퓨터에 저장될 때의 구조와 크게 다르지 않게 DB 구조화를 가능하게 함

**특정 DBMS나 storage에 종속되지 않는 수준**에서 DB를 구조화하는 모델

> **relational data model**이 대표적
> 
> 맨날 사용하는 그 테이블. 대부분의 DBMS에서 사용
> 
> 그 외 object data model 등등

#### physical

컴퓨터에 데이터가 어떻게 파일 형태로 저장되는지를 기술할 수 있는 수단을 제공

data format, data orderings, **access path** 등

## schema & state

### database schema

**data model을 바탕**으로 **database의 구조를 기술**한 것

schema는 database를 설계할 때 정의되며, 한번 정해진 후 자주 바뀌지 않는다.

### database state

database에 있는 실제 데이터는 꽤 자주 바뀜

**특정 시점에 database에 있는 데이터**를 database state 혹은 *snapshot*이라고 한다.

혹은 database에 있는 현재 instances의 집합이라고도 함

### three-schema architecture

database system을 구축하는 아키텍쳐 중 하나

user application으로부터 물리적인 db를 분리시키는 목적

세 가지 레벨이 존재, 레벨마다 스키마가 존재

#### internal schema

물리적으로 데이터가 어떻게 저장되는지 physical data model을 통해 표현

access path 등 실체가 있는 내용

#### external schema

external views, user views라고도 불림

특정 유저들이 필요로 하는 데이터만 표현

그 외 알려줄 필요가 없는 데이터는 숨김

logical data model로 표현

#### conceptual schema

전체 db에 대한 구조를 기술

물리적인 저장 구조에 관한 내용은 숨김

entity, data type, relationships, user operations, constrains에 집중

logical data model로 표현

#### 정리

각 레벨을 독립시켜서, 어느 레벨에서의 변화가 상위 레벨에 영향을 주지 않기 위함.

대부분의 DBMS가 three level을 완벽하게 혹은 명시적으로 나누지는 않음

데이터가 존재하는 곳은 internal level.

## database language

### data definition language (DDL)

conceptual schema를 **정의**하기 위해 사용되는 언어

요즘은 이걸로 거의 모든 schema를 커버함.

### data manipulation language (DML)

db에 있는 data를 **활용**하기 위한 언어

추가 삭제 수정 등등

### 통합된 언어

요즘 DBMS는 DML, VDL, DDL을 따로 두지 않고 통합

**대표적인 게 SQL.**

---

# Relational data model

## in mathematics

### set

서로 다른 elements를 가지는 collection

하나의 set에서 elements의 순서는 중요하지 않다.

### relation in mathematics

두 집합 A, B 사이의 binary relation은,

A와 B의 **Cartesian product의 부분집합**이다.

### n-ary relation

**n개의 집합**이 있다고 했을 때,

**n-ary relatioin**은 n개 set에 대한 **Cartesian product의 부분집합.**

이 때 *각각의 연결* (1번에서 n번까지 쭉 이어지는 연결관계 하나)를 **tuple**이라고 함.

n개 집합에 대한 tuple을 n-tuple이라고 함.

### 결론

relation in mathematics는 아래와 같이 정의할 수 있다.

- **subset of Cartesian product** 이거나

- **set of tuples**

## data model로의 적용

id, name, grade, major, phoneNumber 같은 **domain**이 존재

- 앞서 수학 모델 상 **집합에 해당**

이걸 필요에 따라 **attribute**의 형태로 뽑아서, **tuple로 엮을 수** 있음

- phoneNumber를 두 번 가져다가 본인의 번호와 비상연락망 번호, 두 개로 구성하는 식

**tuple들의 모여있는 집합을 relation**이라고 하고,

**보통 table 형태**로 표현됨

- **각 행은 tuple**,

- **각 column은 attribute**

## 주요 개념

### domain

set of **atomic values**

*나눠질 수 없는 단위*만 domain이 되어야 한다

### attribute

**domain이 relation에서 맡은 역할**의 이름

### tuple

**각 attribute의 값으로 이루어진 리스트**. 일부 값은 *null*일 수 있다.

### relation

**set of tuples**

### relation schema

**relation의 구조**

relation의 이름과 attributes 리스트로 표기된다.

attributes와 관련된 **constraints**도 포함됨

### degree of a relation

relation schema에서 attributes의 수

### relational database

**relational data model에 기반하여 구조화된 database**

여러 개의 relations로 구성된다.

### relational database schema

relation schemas의 set과

*integrity constraints set*로 구성

## relation의 특징들

- 중복되는 tuple을 가질 수 없다.
  
  - *relation 자체가 set of tuples 이므로*

- relation의 tuple을 식별하기 위해 **attribute의 부분집합을 key로 설정**한다.
  
  - 주로 사용되는 게 id값

- relation에서 tuple의 **순서**는 중요하지 않다

- 하나의 tuple에서 attribute의 순서는 중요하지 않다

- attribute는 **atomic**해야한다.
  
  - address: 서울특별시 강남구 청담동 이러면 안됨
  
  - *다 잘라서 저장하는 게 바람직*

## null의 의미

아래 셋 중에 하나 혹은 여러 개

- 값이 존재하지 않는다
  
  - 시험점수: 시험을 안 봄

- 아직 무엇인지 알지 못한다
  
  - 시험점수: 아직 결과가 안 나옴

- 해당 사항과 관계가 없다
  
  - 전적대학: 편입을 안함

## keys

### superkey

relation에서 **tuples를 unique하게 식별**할 수 있는 **attributes set**

- 전체 attribute set은 당연히 가능

- id에 **중복이 없다면 id 하나로도 가능**

- 그 외에도 **여러 개를 묶었을 때 단일성이 보장된다면** 가능

### candidate key

**어느 한 attribute라도 제거하면** unique하게 **tuples를 식별할 수 없는 superkey**

- key or *minimal*superkey

- 억지로 여러 개를 묶어서 단일성을 보장했는데, 하나라도 빼면 단일성이 보장될 수 없는 경우

### primary key

relation에서 tuples를 unique하게 식별하기 위해 **선택된 candidate key**

- 보통 attribute **수가 적은 것**을 고름

- 그러다보니 주로 id값을 사용하는 것

### unique key

primary key가 아닌 candidate keys

- *alternate* key

### foreign key

**다른 relation의 PK를 참조**하는 **attributes set**

## constraints

relational database에서 relations들이 언제나 지켜줘야 하는 제약사항

### implicit constraints

relation은 중복되는 tuple을 가질 수 없다

relation 내에서 같은 이름의 attr를 가질 수 없다

### schema-based constraints

주로 DDL을 통해 schema에 직접 명시할 수 있음

#### domain constraints

attr의 value는 해당 attr의 domain에 속한 value여야 한다

#### key constraints

서로 다른 tuples는 같은 value의 key를 가질 수 없다

#### null value constraint

attr가 not null로 명시됐다면 null을 값으로 가질 수 없다

#### entity integrity constraint

PK는 value에 null을 가질 수 없다

#### referential integrity constraint

FK와 PK의 도메인이 같아야 하고,

PK에 없는 values를 FK가 값으로 가질 수 없다.

- 데이터의 일관성을 보장하기 위함.

- 백엔드를 다루다보면 자주 보게되는 exception

---

# DB 인덱싱

## 인덱스

데이터베이스의 테이블에 대한 **검색 속도**를 향상시켜주는 자료구조

기본적으로 테이블의 각 행은 메모리 공간 상의 **물리적 주소**를 가진다.

테이블의 특정 컬럼에 인덱스를 생성할 시

- 해당 컬럼의 **데이터를 정렬**하고

- 별도 메모리 공간에 해당 데이터의 **물리적 주소와 함께 저장**됨

- 컬럼의 값이 key, 물리적 주소가 value

## 장점

- 테이블을 **검색하는 속도와 성능**이 향상된다. 시스템의 전반적인 부하가 줄어든다.

핵심은, 인덱스에 의해 데이터들이 **정렬된 형태를 갖는다**는 점.

- 기존 where문이 full table scan을 했다면, 인덱스를 통해 정렬된 데이터에 대해서는 **즉시 접근**이 가능.

- order by나 min/max도 빠르게 수행 가능함

## 단점

- 인덱스를 관리하기 위한 추가 작업이 필요

- **추가 저장 공간**이 필요

- 잘못 사용하는 경우 오히려 검색 성능 저하

### DDL 작업 수행 시

**인덱스를 항상 정렬된 상태로 유지하기 때문에** DDL 작업 수행 시 추가 작업이 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스 추가

- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행

- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스 추가

즉, 인덱스 수정 작업이 필요하기 때문에 **데이터의 수정이 잦은 경우** 성능이 낮아진다.

그리고 데이터의 인덱스가 **제거되는 것이 아닌** *사용하지 않음*으로 처리하고 **남겨두기 때문에** 수정작업이 많으면 **실제 데이터에 비해 인덱스만 과도하게 커지는** 문제점이 발생할 수 있다.

- 이것이 별도 메모리 공간에 저장되므로, 추가 저장 공간이 많이 필요하게 된다.

## 올바른 사용?

- 데이터의 range가 넓고 중복이 적을수록

- 조회가 많을수록

- 정렬된 상태가 유용한 컬럼일수록

인덱스 사용이 효율적이다.

### 정리하면,

- **규모**가 큰 테이블

- DDL 작업 (insert, update, delete)이 **자주 발생하지 않는** 컬럼

- **where, order by, join**이 자주 사용되는 컬럼

- 데이터의 중복도가 낮은 컬럼

## 인덱스의 자료구조

Hash Table과 B+ Tree가 사용됨

### Hash Table

key와 value를 한 쌍으로 데이터를 저장하는 자료구조

**해시 충돌**이라는 변수가 존재하지만,

평균적으로 **O(1)의 시간**으로 데이터 탐색이 가능하다.

- key, value = 컬럼의 값, 데이터 위치로 구현

- 하지만, DB에서 자주 사용되는 **부등호 연산**에는 최적화가 되어있지 않아서 인덱스용으로 잘 사용되지 않는다.

### B+ Tree

기존의 B-Tree는 어느 한 데이터를 검색하는 데에는 효율적이지만,

**모든 데이터를 순회하는 데**에는 모든 노드를 방문해야 하므로 비효율성이 존재한다. 이를 개선한 것이 B+Tree

- B+Tree는 **오직 leaf node에만 데이터를 저장**하고, leaf node가 **아닌 node에서는 자식 포인터만 저장**한다.

- 이 때 **leaf node끼리는 LinkedList로 연결**되어 있다.

- 중간 node에서 leaf node까지 key를 올바르게 찾아가기 위해, 중간 node에서 key가 중복될 가능성이 존재한다.

#### 장점

- leaf node를 제외하고 데이터를 저장하지 않아, **메모리를 더 확보**한다.
  
  - 하나의 node에 더 많은 포인터를 가질 수 있어, 트리의 **높이가 낮아지고** 검색 속도가 높아진다

- Full scan을 하더라도 **leaf node의 LinkedList만 순회**하면 되므로 선형 시간이 소모된다.

#### 단점

- B+Tree는 특정 key에 접근하기 위해 **반드시 leaf node까지 **가야 한다.
  
  - B-Tree에서는 leaf 전에 만날 가능성이 있었다.

#### 인덱스에서 사용하는 이유

인덱스 컬럼은 **부등호를 이용한 순차 검색 연산**이 자주 발생할 수 있다.

이 때 LinkedList를 이용하면, 순차 검색을 효율적으로 할 수 있다.

## 결론

기본적으로 file 형태의 데이터는 **디스크에 선형구조로 저장**된다. disk의 구조가 원래 그렇다.

이걸 **단순하게 탐색하면 비효율적**이기 때문에 인덱스를 사용한다.

이 때 **인덱스를 비선형 자료구조로 저장**하면, 선형 자료구조에 비해 탐색이 압도적으로 빠르기 때문이다.

---

# DB 트랜잭션

## 개념

한 번 질의가 실행되면 질의가 **모두 수행되거나 모두 수행되지 않는**, **작업수행**의 **논리적 단위**

- 질의(query)를 하나의 묶음으로 처리해서, 중간에 실행이 중단되면 처음부터 다시 실행하는 rollback을 수행하고, 오류가 없이 실행을 마치면 commit을 하는 실행 단위

- 단위화된 것에 대해서는, **원자성**이 보장되어야 한다.

**TPS**: DBMS의 성능한 초당 트랜잭션의 실행 수로 측정된다.

## 사용 이유

**데이터 부정합을 방지**하기 위함.

DB서버에 여러 클라이언트가 동시에 엑세스하는 등의 상황이 흔하기 때문.

사실 프로세스를 병렬로 처리하지 않으면 간단하지만, 효율이 너무 떨어지기 때문에 **병렬로 처리하는 게 강제**됨. 이 때 부정합이 발생하는 상황을 방지하고자 트랜잭션을 사용

## 트랜잭션의 실행

디스크 상의 rawData는 그대로 존재하는 가운데,

트랜잭션으로 변화가 야기될 데이터만 clone을 떠서 메모리에 옮겨놓고 작업을 실행한다.

문제가 발생하면 해당 메모리를 날리면 되고, (rollback)

제대로 됐으면 disk에 write한다. 이게 commit

- 내용 자체는 간단한데, 이 모든 과정에서 **원자성**이 보장되는 지는 또 다른 문제.

## 특성 (ACID)

### 원자성 (Atomicity)

트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장.

**All or Nothing**의 개념으로, 작업 단위를 일부분만 실행하지 않음

### 일관성 (Consistency)

트랜잭션이 성공적으로 완료되면, 일관적인 DB상태를 유지하는 것.

**데이터 타입이나 constraint**들을 종전과 동일한 형태로 유지하는 것.

### 격리성 (Isolation)

트랜잭션 수행 시 다른 트랜잭션 작업이 끼어들지 못하도록 보장하는 것..

트랜잭션끼리 **서로 간섭할 수 없음.**

### 지속성 (Durability)

성공적으로 수행된 트랜잭션은 **영원히 반영**됨.
