# Chapter 1: 디자인 패턴과 프로그래밍 패러다임

---

# Section 2: 프로그래밍 패러다임

---

## Intro

프로그래밍 패러다임은, 프로그래머에게 **프로그래밍의 관점을 갖게 해주는** 역할을 하는 **개발 방법론**이다.

- **객체지향 프로그래밍**을 사용한다고 정해졌다면, 프로그래머들은 *프로그램*을 *상호 작용하는 객체들의 집합*으로 볼 수 있게 되고,

- **함수형 프로그래밍**을 사용한다고 정해졌다면, *상태 값을 지니지 않는 함수 값들의 연속*으로 볼 수 있게 된다.

프로그래밍 언어 자체가 특정 패러다임을 지원하기도 하는데, **jdk 1.8 이전의 자바**는 객체지향 프로그래밍만을 지원했다.

- **jdk 1.8부터는** 함수형 프로그래밍을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고

- 선언형 프로그래밍을 위해 스트림(stream) 등 표준 API 등이 추가되었다.

>  이에 대한 내용은 **Modern Java in Action**에서 자세히..

### 유형

크게 **선언형**, **명령형**으로 나눈다.

- 선언형은 **함수형**이라는 하위 집합을 가진다.

- 명령형은 **객체지향**, **절차지향**으로 나뉜다.

---

## 선언형과 함수형 프로그래밍

선언형 프로그래밍은, **무엇을** 풀어내는가에 집중하는 패러다임이다.

- **프로그램은 함수로 이루어진 것이다** 라는 명제가 담겨 있는 패러다임이다.

함수형 프로그래밍은 선언형 패러다임의 일종이다.

> 이에 대한 내용은 **Modern Java in Action**에서 자세히..

---

## 객체지향 프로그래밍

객체지향 프로그래밍(Object-Oriented Programming)은, **객체들의 집합으로 프로그램의 상호 작용을 표현**하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식.

**문제를 여러 개의 객체 단위로 나누어 작업하는 방식**

### 장점

- 코드 재사용성 증가: 상속

- 생산성 향상: 잘 설계된 클래스는 독립적인 객체로 여기저기서 사용할 수 있다.

- 자연적인 모델링

- 유지보수의 우수성: 캡슐화를 통해 추가, 수정을 하더라도 주변에 영향을 적게 줄 수 있다.

### 단점

- 설계에 많은 시간이 소요

- 처리 속도가 다른 패러다임에 비해 상대적으로 느림.

### 객체지향 프로그래밍의 특징

가장 큰 특징은, **클래스**를 이용해서 데이터 부분(**변수**)와 처리 부분(**함수**)를 하나의 **객체**(**인스턴스**)로 *묶어* **생성해서 사용**한다는 것.

#### 추상화

추상화(abstraction)란, 실제로 존재하는 객체들을 프로그램으로 만들기 위해, 그 **공통적인 특성과 기능**을 파악해서 필요없는 것은 제거하고 **핵심**을 **간추려내는 것**을 의미.

- **객체**가 상태와 행동을 가지는 실체로 현실 세계에 존재하는 것들 그 자체를 가리킨다면,

- **클래스**는 객체를 프로그래밍에 이용하기 위해 **객체에 어떤 특징이 있어야 한다고 정의**하는 **추상화된 개념**이다.

즉, 추상화는 **객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법**이다.

#### 캡슐화

캡슐화(encapsulation)는, 데이터와 코드의 **형태**를 외부로부터 알 수 없게 하고, **데이터의 구조와 역할, 기능**을 **하나의 캡슐형태로** 만드는 방법.

- 변수를 `private`으로 선언하여 **데이터를 보호하고**

- 보호된 변수는 `getter`나 `setter` 등의 **메서드를 통해서만 간접적으로 접근**할 수 있도록 허용.

이를 통해 불필요한 정보를 감출 수 있다.

#### 상속성

상속성(inheritance)은, 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것.

- 코드 재사용, 계층적 관계 생성, 유지보수성 측면에서 중요

#### 다형성

다형성(polymorphism)은, **상속**과 연관있는 개념으로 한 객체가 **상속을 통해 기능을 확장하거나 변경**하여, **다른 여러 형태(객체)로 재구성**되는 것.

- 한 부모 밑에서 태어난 자식들이 조금씩 다르다는 것.

대표적인 예시가 오버로드와 오버라이드고, 이것을 구현한 게 **오버로딩**과 **오버라이딩**

##### 오버로딩

하나의 클래스 안에서 같은 이름의 메서드를 여러 개 사용하지만, 각 메서드의 용도가 다르고 결과물도 다른 것을 말한다.

- 메서드의 타입, 매개변수 유형, 매개변수 개수 등으로 차이를 만들 수 있고,

- 컴파일 중 발생하는 점에서 **정적** 다형성이다.

##### 오버라이딩

하위 클래스가 상위 클래스에서 만들어진 메서드를 자신의 필요에 따라 재정의하여 사용하는 것.

- 런타임 중 발생하는 점에서 **동적** 다형성.

다형성을 통해, 클래스 간의 계층적 관계 내에서

- 같은 이름의 속성을 유지함으로써 그 속성을 사용하기 위한 **인터페이스를 유지**하고

- **메서드 이름을 낭비하지 않게** 된다.

- 프로그램의 복잡성이 증가할수록, 다형성은 **코드 재사용성**을 늘려준다는 점에서 **유지보수**가 용이하도록 도와줄 수 있다.

### 정리

객체지향 프로그래밍에서는 위 4가지 특징을 통해,

- 어떤 대상을 **추상화**하여 공통점을 찾고

- 그것을 *클래스*의 형태로 **캡슐화** 및 한 군데로 모아 *객체*를 만들고

- 새로운 객체가 **상속**받아 재사용이 가능하게 만들어 준다.

- 이 때 상속받은 객체는 **다형성**을 통해 상속받은 기능을 수정 또는 추가하여 재사용할 수 있다.

### 설계 원칙

**SOLID 원칙**을 지켜주어야 한다.

#### 단일 책임의 원칙: SRP(Single Responsibility Principle)

**모든 클래스는 각각 하나의 기능만을 가진다.**

- 해당 클래스가 제공하는 **모든 서비스**는 **단 하나의 책임을 수행하는 데 집중**되어야 한다는 원칙.

이게 필요한 이유는, 서로 다른 클래스들이 서로 영향을 미치는 **연쇄작용**을 줄일 수 있기 때문.

- **응집도는 높이고, 결합도는 낮춘다**고도 말할 수 있다.

또한 **책임을 적절히 분배하여** 코드 가독성 향상, 유지보수 용이에 기여한다.

#### 개방폐쇄의 원칙: OCP(Open Close Principle)

소프트웨어의 모든 구성요소가 **확장에는 열려있고, 변경에는 닫혀있어야 한다**는 원칙.

- 요구사항 변경 등 추가사항이 발생하더라도, **기존 구성요소에는 수정이 일어나지 않는** 가운데 **쉽게 확장은 가능**하고 **재사용도 가능**해야 한다는 뜻이다.

*관리가 용이하고 재사용이 가능한 코드*를 만드는 핵심적인 기반이 되고, **추상화**와 **다형성**을 고도로 사용할 필요가 있다.

##### 어떻게?

가장 중요한 건 클래스 설계 시, *변할 부분*과 *변하지 않을 부분*을 **명확히 구분**하는 것.

- 하나의 객체에 대해 변할 부분을 **추상화**하는 과정에서, 다른 모든 종류의 객체로부터 식별될 수 있는, **변하지 않는 객체의 본질적인 특징**을 정의해낼 가능성이 있다.

- `interface`는 바로 이러한 **본질적인 특징에 관한 약속**이 된다.

- 그리고 이걸 상속받은 클래스들은, **변하지 않을 부분들**의 *위*에서 **변하는 부분**들을 입맛에 맞게 정의할 수 있다.
  
  - 만약 기존에도 해당 인터페이스를 상속받아 사용하던 클래스가 있더라도, 인터페이스를 OCP에 맞게 잘 정의해놨다면 기능 추가 시 **새로운 클래스만 도입**하면 된다.
  
  - 인터페이스나 기존 클래스의 코드를 수정할 이유가 없다.

- 이렇게 만들어진 클래스들을 외부에서 사용할 때는, **인터페이스를 참조**함으로써 **다형성**이 주는 혜택을 누릴 수 있다.

#### 리스코브 치환의 원칙: LSP(the Liskov Substitution Principle)


