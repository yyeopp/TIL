# Chatper 4: 데이터베이스

---

# Section 5: 인덱스

---

> 해당 파트는 유튜브 **쉬운코드**의 강의를 바탕으로 작성됨

## 인덱스

인덱스는, 데이터베이스의 테이블에 대한 **검색 속도**를 향상시켜주는 **자료구조**

기본적으로 테이블의 각 행은 메모리 공간 상의 **물리적 주소**를 가진다.

테이블의 특정 컬럼에 인덱스를 생성할 시

- 해당 컬럼의 **데이터를 정렬**하고

- 별도 메모리 공간에 해당 데이터의 **물리적 주소와 함께 저장**됨

- 컬럼의 값이 key, 물리적 주소가 value

### 장점

- 테이블을 **검색하는 속도와 성능**이 향상된다. 시스템의 전반적인 부하가 줄어든다.

핵심은, 인덱스에 의해 데이터들이 **정렬된 형태를 갖는다**는 점.

- 기존 where문이 full table scan을 했다면, 인덱스를 통해 정렬된 데이터에 대해서는 **즉시 접근**이 가능.

- order by나 min/max도 빠르게 수행 가능함

### 단점

- 인덱스를 관리하기 위한 **추가 작업**이 필요

- **추가 저장 공간**이 필요

- 잘못 사용하는 경우 오히려 검색 성능 저하

### DDL 작업 수행 시

**인덱스를 항상 정렬된 상태로 유지하기 때문에** DDL 작업 수행 시 추가 작업이 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스 추가

- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행

- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스 추가

즉, 인덱스 수정 작업이 필요하기 때문에 **데이터의 수정이 잦은 경우** 성능이 낮아진다.

그리고 데이터의 인덱스가 **제거되는 것이 아닌** *사용하지 않음*으로 처리하고 **남겨두기 때문에** 수정작업이 많으면 **실제 데이터에 비해 인덱스만 과도하게 커지는** 문제점이 발생할 수 있다.

- 이것이 **별도 메모리 공간**에 저장되므로, 추가 저장 공간이 많이 필요하게 된다.

### 올바른 사용?

- 데이터의 range가 넓고 중복이 적을수록

- 조회가 많을수록

- 정렬된 상태가 유용한 컬럼일수록

인덱스 사용이 효율적이다.

### 정리하면,

- **규모**가 큰 테이블

- DDL 작업 (insert, update, delete)이 **자주 발생하지 않는** 컬럼

- **where, order by, join**이 자주 사용되는 컬럼

- 데이터의 중복도가 낮은 컬럼

---

## 인덱스의 자료구조

Hash Table과 B+ Tree가 사용됨

### Hash Table

key와 value를 한 쌍으로 데이터를 저장하는 자료구조

**해시 충돌**이라는 변수가 존재하지만,

평균적으로 **O(1)의 시간**으로 데이터 탐색이 가능하다.

- key, value = 컬럼의 값, 데이터 위치로 구현

- 하지만, DB에서 자주 사용되는 **부등호 연산**에는 최적화가 되어있지 않아서 인덱스용으로 잘 사용되지 않는다.

### B-Tree

#### 개념

탐색 성능을 높이기 위해 **균형 있게 높이를 유지**하는, Balanced Tree의 일종

모든 leaf node가 같은 level로 유지되도록 **자동으로 밸런싱**.

**자식 node의 개수는 2개 이상**이고,

node 내에서 key는 1개 이상일 수 있음.

**K차 B-Tree**는, node의 자식 수 중 최댓값이 K인 경우.

#### 조건

- node의 **key 수가 k개**라면, **자식 node의 수는 k+1개**

- node의 **key는 반드시 정렬된 상태**여야 한다.

- 자식 node들의 key는 현재 node의 key를 기준으로, **크기 순으로 나뉘게 된다**.
  
  - 노드 내 각 key의 **왼쪽** 자식 노드가 가진 key는 항상 자신의 key보다 작아야 하고, **오른쪽** 자식 노드가 가진 key는 항상 자신의 key보다 커야 한다.

- root node는 항상 2개 이상의 자식 node를 갖는다.

- M차 트리일 때, root node와 leaf node를 제외한 모든 node는 최소 M/2, 최대 M개의 서브트리를 갖는다.

- **모든 leaf node들은 같은 level에** 있어야 한다.

#### 사용하는 이유

일반적인 트리의 탐색은 평균 시간 복잡도가 log이지만,

**트리가 완전히 편향된 최악의 경우에는 N**이다.

- root에서 leaf까지 모든 node를 방문해야 하기 때문.

트리가 편향되지 않도록 항상 밸런스를 유지하는 트리를 만들 시, **최악의 경우에도 log의 시간이 보장**된다.

### B+ Tree

기존의 B-Tree는 어느 한 데이터를 검색하는 데에는 효율적이지만,

**모든 데이터를 순회하는 데**에는 모든 노드를 방문해야 하므로 비효율성이 존재한다. 이를 개선한 것이 B+Tree

- B+Tree는 **오직 leaf node에만 데이터를 저장**하고, leaf node가 **아닌 node에서는 자식 포인터만 저장**한다.

- 이 때 **leaf node끼리는 LinkedList로 연결**되어 있다.

- 중간 node에서 leaf node까지 key를 올바르게 찾아가기 위해, 중간 node에서 key가 중복될 가능성이 존재한다.

#### 장점

- leaf node를 제외하고 데이터를 저장하지 않아, **메모리를 더 확보**한다.
  
  - 하나의 node에 더 많은 포인터를 가질 수 있어, 트리의 **높이가 낮아지고** 검색 속도가 높아진다

- Full scan을 하더라도 **leaf node의 LinkedList만 순회**하면 되므로 선형 시간이 소모된다.

#### 단점

- B+Tree는 특정 key에 접근하기 위해 **반드시 leaf node까지** 가야 한다.
  
  - B-Tree에서는 leaf 전에 만날 가능성이 있었다.

#### 인덱스에서 사용하는 이유

인덱스 컬럼은 **부등호를 이용한 순차 검색 연산**이 자주 발생할 수 있다.

이 때 LinkedList를 이용하면, 순차 검색을 효율적으로 할 수 있다.

---

## 결론

기본적으로 file 형태의 데이터는 **디스크에 선형구조로 저장**된다. disk의 구조가 원래 그렇다.

이걸 **단순하게 탐색하면 비효율적**이기 때문에 인덱스를 사용한다.

**인덱스를 비선형 자료구조로 저장**하면, 선형 자료구조에 비해 탐색이 압도적으로 빠르기 때문이다.
