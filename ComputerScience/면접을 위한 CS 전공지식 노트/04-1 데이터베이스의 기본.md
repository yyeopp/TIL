# Chapter 4: 데이터베이스

---

# Section 1: 데이터베이스의 기본

데이터베이스는 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음이다.

데이터베이스를 제어, 관리하는 통합 시스템을 **DBMS**(DataBase Management System)라고 하며, DB 안에 있는 데이터들은 특정 DBMS마다 정의된 **쿼리 언어**를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다.

- DB 위에 DBMS가, 그 위에 응용프로그램이 있어 이러한 구조를 기반으로 데이터를 주고 받게 된다.

또한, DB는 **실시간 접근**과 **동시 공유**가 가능한 특성을 가진다.

---

## 엔터티

**엔터티**(entity)는 **여러 개의 속성**을 가진 **명사**를 의미한다. 사람, 장소, 물건, 사건, 개념 등이 엔터티가 될 수 있다.

- **회원**이라는 엔터티가 있다면, 속성으로는 이름, 아이디, 주소, 전화번호 등이 가능할 것이다.

- 이러한 **속성**은, **서비스의 요구 사항에 맞춰** 정해진다.
  
  - 특정 속성이 해당 엔터티에 존재하지만 서비스 요구 사항과는 무관하다면, 해당 속성은 사라지게 된다.

### 약한 엔터티와 강한 엔터티

엔터티는 **종속** 여부에 따라 약한 엔터티와 강한 엔터티로 나뉜다.

- A 엔터티가 혼자서는 존재하지 못하고 B의 존재 여부에 종속적이라면,

- A는 약한 엔터티이고 B는 강한 엔터티이다.

> 방은 건물 안에만 존재하므로, 방은 약한 엔터티이고 건물은 강한 엔터티이다.

---

## 릴레이션

Relation은 DB에서 **정보를 구분하여 저장하는 기본 단위**이다.

*엔터티*에 대한 데이터를 DB는 **릴레이션 하나에 담아서** 관리한다.

- *회원*이라는 엔터티의 속성들을 엮어서 데이터베이스에서 관리할 때, 릴레이션이 된다.

- 릴레이션이 관계형 DB에서는 **테이블**이 되고, NoSQL DB에서는 **컬렉션**이 된다.

### 테이블과 컬렉션

기본적으로 DB는 크게 관계형과 NoSQL로 나눌 수 있다.

- 대표적인 관계형 DB인 MySQL은, 레코드-테이블-데이터베이스의 구조를 가진다.
  
  - 레코드는 테이블 내의 **한 행**을 말한다.
  
  - 레코드가 쌓여서 테이블이 되고, 테이블이 쌓여서 DB가 되는 식.

- 대표적인 NoSQL DB인 MongoDB는, 다큐먼트-컬렉션-데이터베이스의 구조를 가진다.

---

## 속성

속성(attribute)은, **릴레이션에서 관리**하는 **구체적이고 고유한 이름을 갖는** 정보이다.

- **서비스의 요구 사항**을 기반으로 **관리해야 할 필요가 있는 속성**들만 엔터티의 속성이 된다.

---

## 도메인

도메인(domain)은, 릴레이션에 포함된 각각의 속성들이 **가질 수 있는 값의 집합**을 말한다.

- *성별*이라는 속성이 있다면, 도메인은 {남, 여}가 된다.

---

## 필드와 레코드

위 용어들을 기반으로, DB에서 필드와 레코드로 구성된 테이블을 만들 수 있다.

- *회원*이라는 엔터티는 member라는 **테이블**로 표현됨

- 해당 엔터티는 **속성**으로 이름, 아이디 등을 가지고, DB 상에서 name, ID의 **필드**로 표현됨.
  
  - DB에 필드값으로 집어넣는 속성은 **서비스 요구 사항**을 기반으로 관리할 필요성이 있는 속성들만 선별됨.
  
  - 테이블 구성 시, 각 속성에 맞는 **타입**을 정하는 것도 중요.
    
    - INT, VARCHAR, DATETIME 등

- 이 테이블에 쌓이는 행 단위의 데이터는 **레코드**. 튜플이라고도 함.

### 필드 타입

이러한 타입은 DBMS마다 다르다. MySQL을 기준으로 숫자, 날짜, 문자 타입을 알아본다.

#### 숫자 타입

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT가 있다.

- 용량은 각각 1,2,3,4,8 바이트

#### 날짜 타입

DATE, DATETIME, TIMESTAMP 등이 있다.

##### DATE

날짜 부분은 있지만 시간 부분은 없는 값. 용량은 3바이트

##### DATETIME

날짜 및 시간을 모두 포함하는 값. 용량은 8바이트

##### TIMESTAMP

날짜 및 시간을 모두 포함하는 값. 용량은 4바이트.

- DATETIME보다 지원하는 날짜 구간이 적다. (현실적인 수준에서만 존재)

#### 문자 타입

CHAR, VARCHAR, TEXT, BLOB, ENUM, SET이 있다.

##### CHAR와 VARCHAR

모두 사전에 입력된 **최대 글자수**에 맞춰서 문자를 입력할 수 있다.

하지만 차이점이 존재한다.

- CHAR는 테이블 생성 시 선언한 길이로 고정된 문자열이다. 0부터 255 사이의 값을 가지는데, 레코드를 저장할 때 **무조건** 선언한 길이 값으로 고정돼서 저장한다.
  
  - CHAR(100)으로 지정해놨다면, "세글자"만 입력해도 100글자에 해당하는 바이트가 사용된다.

- VARCHAR는 **가변 길이 문자열**이다. 0에서 65535 사이 값으로 지정할 수 있는데, 입력된 데이터에 따라 용량을 가변시켜 저장한다.
  
  - VARCHAR(1000)으로 지정해놨어도, "세글자"만 입력한다면 3글자에 해당하는 바이트가 사용된다.

- 지정된 형태에 따라 저장된 CHAR가 **검색에 유리**하기 때문에,
  
  - 검색을 별로 하지 않고 유동적인 길이를 가진 데이터는 VARCHAR로, 검색이 잦고 길이가 확실하게 고정된 데이터는 CHAR로 저장하는 것이 좋다.

##### TEXT와 BLOB

모두 **큰 데이터**를 저장할 때 사용된다.

- TEXT는 큰 문자열을 저장할 때 사용되어, 주로 게시판 본문을 저장할 때 쓴다.

- BLOB은 이미지, 동영상 등 아주 큰 데이터를 저장할 때 사용된다.

##### ENUM과 SET

모두 문자열을 **열거**한 타입이다.

- ENUM은 해당 필드에 들어갈 수 있는 값을 **상수**로 미리 지정해두고, insert 시 이 중 하나를 단일 선택해서 넣는 타입이다.
  
  - ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다.
  
  - 상수로 지정된 값들이 바이트로 매핑되어, **메모리를 적게 사용하는** 이점이 있다.
  
  - 최대 65535개의 요소를 넣을 수 있다.

- SET은 ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고, 비트 단위 연산이 가능하다는 점이 다르다.
  
  - 최대 64개의 요소를 넣을 수 있다.

즉, 공간적으로 이점을 볼 수 있는 타입이지만 자칫하면 개발 과정에서 ENUM이나 SET에 정의한 목록 자체를 수정해야 한다는 위험성을 가진다.

---

## 관계

DB에는 보통 여러 개의 테이블이 있고, 서로 관계가 정의되어 있다.

그 관계를 **관계화살표**로 나타내어 ERD diagram 상에 표시할 수 있다.

- 1:1, 1:N, N:M의 관계가 있다.

### N:M 관계

- 학생 테이블과 강의 테이블 간의 관계는 N:M으로 볼 수 있다.

- 보통 두 테이블을 직접적으로 연결하여 구축하기는 어렵고, 학생_강의 테이블을 따로 만들어서 1:N과 1:M의 관계를 가지는 두 관계로 분리하게 된다.

---

## 키

테이블 간의 **관계**를 조금 더 명확하게 하고 테이블 자체의 **인덱스**를 위해 설정된 장치.

테이블 내에서 **필드를 하나 이상 조합한 집합**으로 키를 만든다.

기본키(Primary), 외래키(Foreign), 후보키(Candidate), 슈퍼키(Super), 대체키(Alternate)가 있다.

> #### 유일성
> 
> 특정 키로 테이블을 조회했을 때, 중복되는 레코드가 없게 만든다면 유일성을 만족하는 키라고 한다.
> 
> #### 최소성
> 
> 되도록 **최소 필드만 써서** 형성한 키에 대해 최소성을 만족하는 키라고 한다.

### 기본키(Primary Key)

**유일성**과 **최소성**을 모두 만족하는 키들 중, PK로 **선정**된 키이다.

테이블 내 데이터 중 **고유하게** 존재하는 속성으로, 보통 자체 생성되는 ID값이 PK의 역할을 가져가게 된다.

- 자연키와 인조키 중 골라 설정한다.

#### 자연키

테이블 내에서 **중복되는 값들을 제외**하다가 중복되지 않는 것을 **자연스럽게** 뽑아낸 키를 자연키라고 한다.

언젠가는 변한다는 속성을 가진다.

#### 인조키

테이블 생성 시 인위적으로 생성한 고유 식별자를 인조키라고 한다.

- MySQL의 경우 auto increment로 설정하게 된다.

자연키와 달리 절대불변하는 속성을 가진다.

### 외래키(Foreign Key)

**다른 테이블의 PK**를 그대로 **참조**하는 값이다. **개체 간 관계**를 식별하는 데 사용된다.

### 후보키(Candidate Key)

**기본키가 될 수 있는 후보들**이다. 즉, PK를 포함하는 집합이다. 

유일성과 최소성을 동시에 만족하는 것이 후보키가 될 수 있다.

### 대체키(Alternate Key)

후보키가 두 개 이상인 경우, 어느 하나를 PK로 정하고 남은 후보키를 대체키라고 한다.

### 슈퍼키(Super Key)

**유일성만** 갖춘 키이다.

각 레코드를 유일하게 식별할 수 있는 성격을 가지지만, 최소성은 갖추지 못하기 때문에 **후보키를 포함하는 집합**이 된다.

- 테이블 내 모든 필드를 묶어서 키로 만들면, 웬만해서는 유일성을 갖출 수 있기 때문에 슈퍼키가 될 수 있다.

- 하지만 최소성을 만족시키지 못하는 비효율적인 키라는 점은 두말할 필요가 없다.
