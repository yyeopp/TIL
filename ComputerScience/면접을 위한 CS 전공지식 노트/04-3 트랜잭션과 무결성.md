# Chapter 4: 데이터베이스

---

# Section 3: 트랜잭션과 무결성

---

## 트랜잭션

**Transaction**은, 데이터베이스에서 **하나의 논리적 기능**을 수행하기 위한 **작업의 단위**이다.

데이터베이스에 접근하는 방법이 쿼리이므로, **여러 개의 쿼리들을 하나로 묶는 단위**로 볼 수도 있다.

특징으로 원자성, 일관성, 독립성, 지속성이 있어 이를 묶어 **ACID**라고 부르게 된다.

> **All or nothing**

**원자성**(atomicity)은, 트랜잭션과 관련된 일이 **모두 수행되었거나 모두 수행되지 않았거나를 보장**하는 특징이다.

트랜잭션 내에는 여러 로직이 존재할 수 있는데, 그 모든 로직들이 성공적으로 수행되었을 때에만 **커밋**하고 중간에 문제가 발생할 시 **롤백**함으로써 원자성을 보장한다.

- 여러 로직을 묶을 때 **외부 API를 호출하는 것**이 있으면 안 된다.

- 만약 불가피하다면, 롤백이 일어났을 때 어떻게 할 것인지 해결 방안이 있어야 하고 **트랜잭션 전파**를 신경써서 관리해야 한다.

#### 커밋(commit)

커밋은 **여러 개의 쿼리가 성공적으로 처리되었다고 확정하는** 명령어이다.

**트랜잭션 단위**로 수행되며, 변경된 내용은 모두 **영구적으로 저장**된다.

- 즉, *커밋이 수행되었다*는 *하나의 트랜잭션이 성공적으로 수행되었다*와 동일한 말이 된다.

#### 롤백(rollback)

트랜잭션 수행 중 에러 등의 이슈로 인해, 트랜잭션 이전으로 돌릴 필요가 발생할 시 롤백이 사용된다.

즉, 롤백은 **트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 되돌리는 일**을 말한다.

- 커밋과 롤백을 통해, **데이터의 무결성이 보장**될 수 있다.

- 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고, 해당 작업을 **그룹화**할 수 있다.

#### 트랜잭션 전파

트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다.

> 구체적인 내용은 Spring에서 학습

### 일관성(consistency)

**일관성**은 **허용된 방식**으로만 **데이터를 변경**해야 하는 것을 의미.

DB에 존재하는 모든 데이터는 여러 **조건과 규칙**에 의해 유효성을 보장받고 있는데, 이를 변경할 때는 그러한 조건과 규칙들을 모두 지켜야 한다.

- 특정 속성을 INT로 설정했는데 변경 이후에 VARCHAR가 되어있다면 일관성이 깨진 것.

### 격리성(isolation)

**격리성**은, **트랜잭션 수행 시 서로 끼어들지 못하는 것**을 말한다.

애초부터 여러 개의 트랜잭션을 **동기적으로 처리**하면 데이터 무결성이 *절대* 깨지지 않겠지만, 현실적으로 원만한 서비스를 제공하기 위해서는 DB로의 병렬 접근을 허용할 필요가 있다.

이 때 **복수의 병렬 트랜잭션이 서로 격리되어, 마치 순차적으로 실행되는 것처럼 작동**해야 한다.

- 격리성은 여러 개의 **격리 수준**으로 나뉘어, 격리성을 보장한다.

- **격리성**과 **동시성**이 *교환 관계*에 있는 가운데, 여러 개의 격리 수준이 그 둘 간의 타협점들을 설정하고 있다.

### 격리 수준과 이상현상

#### 레벨0: READ_UNCOMMITTED

가장 낮은 격리 수준으로, 각 트랜잭션에서의 **변경 내용이 commit되기 이전이라도 다른 트랜잭션에서 접근 가능**하다.

데이터 무결성을 위해서라면 사용하지 않는 것이 이상적이지만, 빠르기는 가장 빠르다.

#### 더티 리드(Dirty Read)

어떠한 트랜잭션에서 처리한 작업이 완료되지 않았음에도, 다른 트랜잭션에서 이를 볼 수 있게 됨으로써 사용자의 혼란을 유발하는 DB 이상현상이다.

READ_UNCOMMITED 격리 수준에서만 발생 가능하다.

#### 레벨1: READ_COMMITTED

온라인 서비스에서 가장 많이 사용되는 격리 수준으로, 오라클 DBMS에서 사용하고 있다.

**어떤 트랜잭션이 변경 중인 내용이라도 commit 이전에는 다른 트랜잭션에서 읽지 못하는** 격리 수준에 해당한다.

- 결과적으로 Dirty Read 현상은 방지할 수 있다.

이를 위해, UPDATE나 DELETE 쿼리에 대해 DB에서는 **Undo 영역**를 사용하게 된다.

- 트랜잭션 A에서 특정 레코드를 update하고 commit하기 전이라면, **실제 레코드가 update되는 것은 맞지만** 기존의 레코드는 **Undo 영역으로 백업**된다.

- 트랜잭션 B의 레코드 조회가 A의 commit 이전이라면, B는 Undo 영역에 있는 백업된 레코드를 읽게 된다.

> ##### Undo의 용도
> 
> - 트랜잭션의 격리 수준을 유지하면서도, **높은 동시성**을 제공 (위의 내용에 해당)
> 
> - 트랜잭션의 **롤백 대비용**으로도 사용된다.
>   
>   - 위 예시 속 트랜잭션 A에 대해 롤백이 필요하다면, Undo 영역에 있는 레코드를 가져다가 롤백하면 된다.

#### 반복 가능하지 않은 조회(Non-repeatable read)

**하나의 트랜잭션 내에서 같은 행에 대해 두 번 이상 조회를 할 때, 그 결과값이 달라 정합성에 어긋나게 되는** DB 이상현상을 말한다.

- 하나의 트랜잭션이어도 두 번 이상의 SELECT가 이루어지는 경우가 있는데, SELECT 작업 사이에 다른 트랜잭션이 해당 레코드를 UPDATE 또는 DELETE후 commit할 경우 앞뒤의 SELECT 결과는 달라지게 된다.

- 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업을 처리해야 한다면 문제가 발생할 수 있다.
  
  - 예시로, 수많은 트랜잭션을 통해 입출금이 계속 이루어지는 가운데, 다른 트랜잭션이 **오늘 입금된 금액의 총합을 조회**하고 있다면?

READ_COMMITTED 격리 수준에서부터 발생 가능하다.

#### 레벨2: REPEATABLE_READ

MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용하는 격리 수준으로, READ_COMMITTED와 유사하게 **Undo 영역에 백업된 이전 데이터**를 사용하지만 백업된 레코드의 **버전**을 적극적으로 활용함으로써 **동일한 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록** 한다는 차이점을 가진다.

> ##### MVCC(Multi Version Concurrency Control)
> 
> **잠금을 사용하지 않고도 일관된 읽기를 제공**하는 기술.
> 
> DBMS에서 쓰기와 읽기 세션이 서로를 블로킹하지 않고, **서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다의 스냅샷 이미지를 보장해주는** 메커니즘이다.
> 
> RDBMS에서 **동시성**을 높이기 위해 등장한 기술이다.

InnoDB를 기준으로 할 때,

- 모든 트랜잭션은 auto_increment되는 트랜잭션 번호를 가진다.

- Undo 영역에 백업되는 모든 레코드에는, **변경을 발생시킨 트랜잭션의 번호가 함께** 포함된다.
  
  - 이 때 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제된다.

- 어떤 트랜잭션이 시작된다면, 해당 트랜잭션은 Undo 영역을 적극적으로 활용하여 항상 **자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 내역만** 조회하게 된다.
  
  - 2번 트랜잭션이 1번 트랜잭션으로 insert된 특정 레코드를 조회한다. 
  
  - 3번 트랜잭션이 해당 레코드를 업데이트하고 커밋하면, **해당 레코드의 트랜잭션 번호는 3번이 되고** **Undo 영역에 1번 레코드가 백업**된다.
  
  - 아직 끝나지 않은 2번 트랜잭션이 해당 레코드를 다시 조회했는데, 그 번호가 3번으로 **자신의 번호보다 높으면, Undo 영역을 확인**한다.
  
  - Undo 영역에 **자신의 번호보다 낮은 트랜잭션 레코드**가 있으면, 그걸 읽어온다.

- 이를 통해 InnoDB는 MVCC를 제공할 수 있다.
  
  - 한 트랜잭션의 실행시간이 길어질수록 (위 예시에서 2번) 해당 시간만큼 멀티 버전을 관리해야 한다는 단점이 있으나,
  
  - 실제 영향을 미칠만큼 오래 지속되는 트랜잭션은 드물기 때문에, READ_COMMITTED와의 성능 차이는 크지 않다.

#### 팬텀 리드(Phantom Read)

**한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하면서 결과가 다르게 나타나는 현상**이다.

- **DML 구문에서는 변경 대상 로우에 대해 잠금이 필요하지만** **Undo 영역의 레코드에 대해서는 쓰기 잠금을 걸 수 없어서** 발생하는 현상이라고 정리할 수 있다.

- 단순 SELECT가 아닌, **DML 구문**(INSERT, UPDATE, DELETE)에서 발생하는 이상 현상이다.

```sql
START TRANSACTION; -- transaction id : 1
SELECT * FROM Member WHERE name='junyoung';

    START TRANSACTION; -- transaction id : 2
    SELECT * FROM Member WHERE name = 'junyoung';
    UPDATE Member SET name = 'joont' WHERE name = 'junyoung';
    COMMIT;

UPDATE Member SET name = 'zion.t' WHERE name = 'junyoung'; -- 0 row(s) affected
COMMIT;
```

- 트랜잭션 1은 **트랜잭션 2의 존재로 인해 기본적으로 Undo 영역을 바라보고 있고**, UPDATE 구문은 **대상이 되는 레코드에 대해 쓰기 잠금을 시도**하려 한다.

- 하지만 **Undo 영역의 레코드는 쓰기 잠금이 불가**하기 때문에 **실제 레코드**를 참조하게 되고, 이 때부터 트랜잭션 2가 UPDATE해놨던 것의 영향을 받게 된다.
  
  - *junyoung*이라는 name을 값는 레코드는 더 이상 존재하지 않기 때문

- 결과적으로 하나의 트랜잭션의 처음과 끝에서 특정 레코드가 보였다가 안 보였다가 하는 모습이 된다.

- **DML 구문은 멀티버전을 관리하지 않는다**라고 말할 수 있다.

REPEATABLE_READ 격리 수준에서부터 발생 가능하다.

#### 레벨3: SERIALIZABLE

아예 **모든** 트랜잭션을 **작업 속성에 관계없이** **순차적으로 진행시키는 것**을 말한다.

- 트랜잭션이 순수 **읽기 작업**(SELECT)이더라도 잠금을 걸어놔서, 다른 트랜잭션에서 해당 레코드를 변경하지 못하게 된다.

즉 어떤 행에 대해 트랜잭션이 일어난다면 해당 행은 **완전히 격리**되고, 트랜잭션 완료 이후에나 다음 트랜잭션이 수행될 수 있다.

- 매우 엄격한 수준의 격리로, 그 어떤 오류도 이론상 발생하지 않게 된다.

- 하지만 **교착 상태**가 일어날 확률이 높고, **성능** 면에서는 최악이다.

### 지속성(durability)

**성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것**을 의미한다.

DB에 시스템 장애가 발생해도 원래 상태로 복구하는 **회복 기능**이 있어야 함을 뜻하며,

이를 위해 DB는 체크섬, 저널링, 롤백 등의 기능을 제공한다.

> #### 체크섬(checksum)
> 
> **중복 검사**의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
> 
> #### 저널링
> 
> 파일 시스템 또는 DB 시스템에 트랜잭션 등 변경 사항을 commit하기 전에 **로깅**하는 것.

---

## 무결성

데이터의 **정확성**, **일관성**, **유효성**을 유지하는 것을 말한다.

무결성이 유지되어야, 데이터베이스에 저장된 데이터 값과 현실 세계의 실제 값이 일치한다는 **신뢰**를 얻을 수 있다.

### 무결성의 종류

- **개체** 무결성: PK로 선택된 필드에는, **null값을 허용하지 않는다.**

- **참조** 무결성: 서로 **참조 관계**에 있는 두 테이블의 데이터는, 항상 일관된 값을 유지해야 한다.
  
  - Foreign Key 설정 시 발생하는 제약사항들과 연계됨.

- **고유** 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성 값은 모두 고유한 값을 가진다.

- **NULL** 무결성: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우, 그 속성 값은 NULL이 될 수 없다는 제약 조건.


