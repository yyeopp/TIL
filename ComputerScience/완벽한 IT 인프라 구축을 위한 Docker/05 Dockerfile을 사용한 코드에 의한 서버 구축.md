# Chapter 05: Dockerfile을 사용한 코드에 의한 서버 구축

---

Docker에서는 **인프라 구성 관리**를 **Dockerfile**로 기술한다.

Dockerfile은 베이스 이미지에 각종 **미들웨어**를 설치 및 설정하고, 개발한 어플리케이션의 실행 모듈을 전개하기 위한 모든 **구성 정보**를 기술한다.

---

## Dockerfile을 사용한 구성 관리

### Dockerfile이란?

Dockerfile은, Docker 상에서 작동시킬 **컨테이너의 구성 정보**를 기술하기 위한 파일이다.

- 베이스가 될 Docker 이미지

- Docker 컨테이너 안에서 수행할 조작

- 환경변수 등 설정

- Docker 컨테이너 안에서 작동시켜 둘 데몬 실행

`docker build` 명령을 내리면, Dockerfile에 기술된 구성 정보를 바탕으로 Docker 이미지를 작성하게 된다.

### Dockerfile의 기본 구문

확장자가 필요 없는 텍스트 형식의 파일이다.

기본 서식은, `명령 인수` 의 형태이다.

- 명령은 관례적으로 대문자로 통일한다.

- FROM, RUN, CMD, LABEL, EXPOSE, ENV, ADD, COPY, ENTRYPOINT, VOLUME, USER, WORKDIR, ARG, ONBUILD, STOPSIGNAL, HEALTHCHECK, SHELL

주석은 `#`으로 달 수 있다.

### Dockerfile 작성

해당 컨테이너를 어떤 Docker 이미지로부터 생성할지 정보를 반드시 기술해야 하는데, 이를 **베이스 이미지**라고 한다.

`FROM [이미지명]`이 기본이고, 뒤에 `:[태그명]` 또는 `@[다이제스트]`를 붙일 수 있다.

- 이 때 다이제스트는, Docker Hub에 업로드 시 자동으로 부여되는 식별자를 뜻한다.

> #### Visual Studio Code를 사용한 Dockerfile
> 
> Dockerfile은 기본적으로 텍스트 형식이기 때문에, 임의의 에디터로 작성 및 편집할 수 있다.
> 
> - vscode-docker라는 확장 기능을 설치해서, 스니펫 표시 및 docker-compose.yml 파일 지원, Docker 이미지나 컨테이너 가동 상황 확인이 가능하다.

---

## Dockerfile의 빌드와 이미지 레이어

Dockerfile을 빌드하면, 파일에 정의된 구성을 바탕으로 하는 Docker 이미지를 작성할 수 있다.

### Dockerfile로부터 Docker 이미지 만들기

`docker build -t [생성할 이미지명]:[태그명] [Dockerfile의 위치]`

- 저장 위치는 절대 경로나 상대 경로 모두 가능하다.

- 빌드 명령을 내리면, `FROM` 절에 명시된 베이스 이미지를 **로컬에서 가져오거나 리포지토리에서 다운로드**하는 것으로 시작한다.

Dockerfile에는 임의의 파일명을 붙일 수도 있는데, `-f` 옵션을 붙이면 된다.

**표준 입력을 경유**하여 Dockerfile을 지정할 수도 있는데, Dockerfile의 내용을 build 명령의 인수로 전달하면 된다.

`docker build - < Dockerfile`

- 이 경우 빌드에 필요한 파일을 `ADD` 명령으로 추가할 수 없기 때문에, Dockerfile과 빌드에 필요한 파일들은 tar로 모아두고 지정하는 것이 좋다.

> #### 중간 이미지의 재이용
> 
> Docker는 이미지를 빌드할 때 자동으로 **중간 이미지**를 생성한다.
> 
> 그리고 다른 이미지를 빌드할 때, 중간 이미지를 내부적으로 재이용하여 빌드 속도를 높이고 있다.
> 
> - 이미지 재이용 시, 빌드 로그에 `Using cache` 라고 표시된다.

### Docker 이미지의 레이어 구조

Dockerfile의 명령별로 이미지를 작성할 때, 이미지는 레이어 구조로 되어 있다.

- 정확히는 Dockerfile에 명시된 명령 한 줄마다 이미지가 작성되고, 레이어 구조로 쌓인다.

- 이렇게 작성된 이미지들은 다른 이미지와 공유가 되기 때문에, FROM절에 들어가는 **베이스 이미지**는 특히 대부분 공유된다.
  
  - 이와 같은 이미지의 **겹침**을 통해 디스크 용량을 효율적으로 관리할 수 있다.

> #### Docker Hub의 이미지 관리
> 
> 어플리케이션을 담고 있는 이미지들은 OS의 파일을 포함하고 있기 때문에 용량이 크다.
> 
> 모든 이미지를 Hub에 하나씩 올리자면, 디스크 용량 부담이 지나치다.
> 
> 그래서 Docker Hub에서도 이미지를 레이어로 겹쳐 작성함으로써, 공통 이미지는 공유하여 관리하고 있다.
> 
> - 서로 다른 3개의 이미지가 공식 CentOS 이미지를 베이스로 사용했다면,
> 
> - CentOS의 **이미지 ID**가 모두 동일함을 이용해 3개의 이미지에서 하나의 실체를 공유한다.

---

## 멀티스테이지 빌드를 사용한 어플리케이션 개발

개발 환경에서 사용했던 라이브러리나 개발 지원 툴이 제품 환경에서 반드시 사용되는 것은 아니고, 리소스 절약이나 보안 관점에서 볼 때 최소한으로 필요한 실행 모듈만 남기는 것이 바람직하다.

이를 위해 **멀티스테이지 빌드 기능**을 적용해볼 수 있다.

### Dockerfile 만들기

```dockerfile
FROM gola:1.8.4-jessie AS builder
WORKDIR /go/src/github.com/asashiho/greet
RUN go get -d -v github.com/urfave/cli
COPY main.go .
RUN GOOS=linux go build -a -o greet .
# ---------------
FROM busybox
WORKDIR /opt/greet/bin
COPY --from=builder /go/src/github.com/asashiho/greet/ .
ENTRYPOINT ["./greet"]
```

두 개의 Docker 이미지를 한꺼번에 생성할 수 있는 Dockerfile에 해당한다.

#### 1. 개발 환경용 Docker 이미지

Go를 베이스 이미지로 builder라는 별명을 붙여 작성하고,

로컬 환경에 있는 소스코드를 컨테이너 안으로 복사하여 greet 라는 이름의 바이너리 파일로 작성한다.

#### 2. 제품 환경용 Docker 이미지

베이스 이미지를 **busybox**로 가지는데, 이는 **기본적인 Linux 명령들을 하나의 파일로 모아놓은 것**으로 최소한으로 필요한 **Linux 쉘 환경**을 제공하고자 할 때 이용된다.

개발 환경에서 빌드한 greet라는 이름의 바이너리 파일을 복사해오고, 복사한 파일을 실행하는 명령어를 넣는다.

### Docker 이미지의 빌드

`docker build -t greet .`로 이미지를 빌드해보면,

- 개발 환경의 베이스 이미지인 golang을 다운로드하고

- 그것을 바탕으로 개발 환경용 이미지 builder가 생성되며

- 해당 builder 이미지로 소스코드를 빌드해 실행 가능한 바이너리 파일을 생성한 뒤

- 제품 환경용 이미지에 그러한 실행 가능 바이너리 파일을 복사한다.

결과적으로,

- greet라는 이미지가 개발 환경에서 개발될 시점에는 golang이라는 대규모 베이스 이미지를 깔고 들어감으로써 **개발에는 적합하나 용량이 과다한** 모습이 되는데,

- 제품 환경에서는 busybox라는 최소한의 모듈에 greet를 실행시키는 파일을 복사하는 식으로 구동시켜 용량을 크게 절약할 수 있다.

제품 환경에서는 부하에 따라 작동하는 컨테이너의 수가 바뀌므로, 각 이미지의 용량을 절약함으로써 **시스템 전체의 컴퓨팅 리소스**를 효율적으로 활용할 수 있다.

### Docker 컨테이너의 시작

제품 환경용으로 만든 저용량 이미지인 greet만으로도, 개발 환경에서와 동일한 결과물을 낼 수 있다.

---

## 명령 및 데몬 실행

Docker 이미지를 만들려면 필요한 **미들웨어**를 설치하고, 사용자 계정이나 디렉토리를 작성하는 등의 **명령**을 실행해야 한다.

또한 이미지로부터 컨테이너를 생성했을 때 서버 프로세스 등을 **데몬**으로서 작동시킬 필요가 있다.

### 명령 실행(RUN 명령)

FROM 명령으로 지정한 베이스 이미지에 대해, 다음과 같은 목적으로 사용하는 것이 `RUN` 명령이다.

- 어플리케이션이나 미들웨어를 설치 및 설정

- 환경 구축을 위한 명령을 실행

`RUN [실행하고 싶은 명령]`

기술 방법이 두 가지로 구분된다.

#### Shell 형식으로 기술하는 방법

명령의 지정을 **쉘에서 실행하는 형식으로** 기술하는 방법.

`RUN apt-get install -y nginx`

- apt 명령을 사용해 Nginx를 설치하는 명령

- 컨테이너 안에서 /bin/sh -c를 사용해 명령을 실행했을 때와 똑같이 작동시킬 수 있다.

#### Exec 형식으로 기술

Shell 형식으로 기술하면 /bin/sh 안에서 실행되지만, Exec 형식으로 기술하면 **쉘을 경유하지 않고 직접 실행**한다.

- 명령 인수에 $HOME 같은 환경변수를 지정할 수 없고,

- 실행하고 싶은 명령을 **JSON** 배열로 지정하게 된다.

- 다른 쉘을 이용하고 싶으면, 쉘의 경로를 지정한 뒤에 실행할 명령을 넣으면 된다.

`RUN ["/bin/bash", "-c", "apt-get install -y nginx"]`

- /bin/bash를 지정하여 apt 명령어로 Nginx를 설치하는 명령.

RUN 명령은 기술된 순서에 따라 순서대로 실행되고, **한 줄마다** 내부 이미지가 생성된다.

> #### 이미지의 레이어에 대해
> 
> Dockerfile을 빌드하면 기술된 *명령마다* **내부 이미지**가 하나씩 작성된다.
> 
> 그래서, Dockerfile의 명령을 **줄이는** 방법들이 고안되어 있다.
> 
> `RUN yum -y install httpd php php-mbstring php-pear`
> 
> - 이런 식으로, 한 줄에 쓸 수 있는 RUN 명령이라면 한 줄에 쓰는 게 다.
> 
> - 중간에 `\` 을 넣으면 줄 바꿈을 넣을 수 있다.

### 데몬 실행(CMD 명령)

RUN은 이미지를 **작성하기 위해** 실행하는 명령이라면, 이미지를 바탕으로 생성된 **컨테이너 안에서 명령을 실행**하려면 CMD 명령을 사용한다.

Dockerfile 내에서 하나의 CMD 명령만 기술할 수 있다.

`CMD [실행하고 싶은 명령]`

- CMD 명령으로 특정 데몬 (주로 웹서버)을 실행시키도록 한 뒤 이미지를 빌드하고,

- 컨테이너를 시작할 때 **포트 연결** 등의 조치를 취해주면 컨테이너에서 해당 데몬이 실행되는 상태가 된다.

#### 1. Exec 형식으로 기술

RUN 명령 구문과 같다.

기본적으로 쉘을 호출하지 않고, 인수들은 JSON 배열로 넣는다.

#### 2. Shell 형식으로 기술

RUN 명령 구문과 같다. 쉘을 통해 실행하고 싶을 때 사용한다.

#### 3. ENTRYPOINT 명령의 파라미터로 기술

ENTRYPOINT 명령의 인수로, CMD 명령을 사용할 수 있다.

> #### 패키지 관리 시스템
> 
> 어플리케이션 설치 시 발생하는 **의존 관계**를 모서 관리하는 시스템.
> 
> - 의존 관계는, 어떤 어플리케이션 작동을 위해 다른 어플리케이션이 필요해지는 관계
> 
> ##### YUM (Yellowdog Updater Modified)
> 
> Red Hat 계열에서 이용하는 패키지 관리 시스템.
> 
> yum 명령을 사용하여 리포지토리에서 패키지를 다운로드하고, 어플리케이션 설치, 설치 해제, 업데이트 등을 수행할 수 있다.
> 
> 이 때 패키지 의존 관계를 확인하여 관련된 패키지를 자동으로 설치해 준다.
> 
> ##### APT (Advanced Packaging Tool)
> 
> Ubuntu 같은 Debian 계열에서 이용하는 패키지 관리 시스템.
> 
> apt 명령을 이용해 YUM과 같은 기능을 제공하고 있다.

### 데몬 실행 (ENTRYPOINT 명령)

ENTRYPOINT로 지정한 명령은 `docker container run` 때 실행된다.

`ENTRYPOINT [실행하고 싶은 명령]`

- 마찬가지로, **Exec 형식**과 **Shell 형식** 양쪽으로 기술할 수 있다.

CMD 명령과의 차이는, **run 명령 실행 시의 동작**에 있다.

- CMD의 경우, run 명령 실행 시 인수로 새로운 명령을 지정한 경우 **그것을 우선 실행**하기 때문에 묻힐 가능성이 있다.

- ENTRYPOINT 명령의 경우 **반드시** 컨테이너에서 실행한다.

- 즉, 둘을 조합하여 사용하는 경우가 많다.
  
  - ENTRYPOINT에는 **실행하고 싶은 명령 자체**를 지정하고
  
  - CMD에는 해당 명령의 **인수**를 지정하여 컨테이너 실행 시의 기본 작동을 결정한다.

```dockerfile
FROM ubuntu:latest
ENTRYPOINT ["top"]
CMD ["-d", "10"]
```

- 컨테이너가 run할 때 top 명령은 반드시 실행되고, CMD로 지정된 옵션이 함께 붙을 수 있다.

- CMD 명령은 run 명령 실행 시 **덮어 쓸 수 있기** 때문에 상황에 따라 run에다가 **직접 옵션을 붙일 수도** 있다.

### 빌드 완료 후에 실행되는 명령 (ONBUILD 명령)

자신의 Dockerfile로부터 생성한 이미지를 **베이스 이미지로 하여** 다른 Dockerfile을 빌드할 때 **실행하고 싶은 명령**을 미리 기술한다.

`ONBUILD [실행하고 싶은 명령]`

주로 **웹 어플리케이션의 실행 환경을 구축**할 때 사용된다.

- 웹 시스템의 베이스 이미지를 커스텀해서 작성하고 활용할 때, 

- ONBUILD 명령으로 해당 이미지 안에다가, 이후 이를 **바탕으로 개발될 프로그램을 전개**하는 명령 (ADD나 COPY 등)을 지정해두는 것.
  
  - 웹 어플리케이션을 모두 개발해서 `website.tar`로 묶어놓기로 약속을 미리 해놨다면,
  
  - `ONBUILD ADD site.tar /var/www/html/` 이라고 달아놓는다.

- 그럼 어플리케이션 개발자는 이미 작성이 끝난 베이스 이미지를 바탕으로 **새로운 이미지를 빌드**하고, 그것으로 컨테이너를 run 하면 된다.

결과적으로, **인프라 구축에 관련된 이미지 작성**과 **어플리케이션 전개에 관련된 이미지 작성**이 분리될 수 있다.

> #### ONBUILD 명령을 사용한 팀 개발의 예
> 
> 팀 멤버 각각이 Dockerfile을 작성하고, 이미지를 작성한다면 Docker 도입에도 불구하고 어플리케이션 실행 환경이 제각각이 될 우려가 있다.
> 
> 그래서 **실행 환경 Dockerfile**에 대해서는 작성 담당자를 분리하고, OS/미들웨어 설치나 설정, 라이브러리 검증이나 도입 등 베이스 이미지 용 Dockerfile을 만들도록한다.
> 
> - 이러한 작업에는 시니어가 필요할 것.
> 
> 웹 콘텐츠 개발자는 그 위에서 개발 및 테스트를 함으로써, 실행 환경 통일이 가능하다.

### 시스템 콜 시그널의 설정 (STOPSIGNAL 명령)

컨테이너를 종료할 때 송신하는 시그널을 설정한다.

`STOPSIGNAL [시그널]`

- 시그널 번호, 시그널 명 등으로 지정할 수 있다.

### 컨테이너의 헬스 체크 명령 (HEALTHCHECK 명령)

컨테이너 안의 프로세스가 정상 작동하는 지 체크하는 명령이다.

`HEALTHCHECK [옵션] CMD 실행할 명령`

- 옵션으로 체크 간격, 타임아웃, 타임아웃 회수를 설정할 수 있다.

---

## 환경 및 네트워크 설정

### 환경변수 설정 (ENV 명령)

환경변수를 설정할 수 있다.

`ENV [key] [value]` 또는 `ENV [key]=[value]` 의 형식을 사용한다.

#### 1. key value 형으로 지정하는 경우

ENV 명령 **한 줄마다 환경변수를 한 개씩만** 선언할 수 있다.

- 3개의 환경변수를 지정한다면 ENV 3개가 필요하고, Docker 이미지도 3개가 겹쳐질 것.

#### 2. key=value로 지정하는 경우

ENV 명령 한 번에 **여러 개의 환경변수 값을 설정**할 때 사용한다.

- `\`를 사용하여 가독성 확보 및 이스케이프 처리가 가능하다.

- 3개의 환경변수를 ENV 한 번에 처리함으로써 이미지를 하나만 만들 수 있다.

### 작업 디렉토리 지정 (WORKDIR 명령)

Dockerfile에서 정의한 명령을 실행하기 위한 작업용 디렉토리를 지정한다.

`WORKDIR [작업 디렉토리 경로]`

- RUN, CMD, ENTRYPOINT, COPY, ADD 명령 모두 WORKDIR로 지정된 경로 내에서 이루어진다.

- 만일 지정한 디렉토리가 없다면 새로 만들어낸다.

- ENV 명령에서 지정한 환경변수를 사용할 수 있다. (`$`를 달아서)

### 사용자 지정 (USER 명령)

이미지 실행이나 Dockerfile의 RUN, CMD, ENTRYPOINT 명령을 **실행하는 주체가 될 사용자를 지정**할 때 사용한다.

`USER [사용자명/UID]`

- 이 때 지정되는 사용자가 커스텀된 것이라면, RUN 명령을 통해 **미리 작성**해 둘 필요가 있다

- `RUN ["adduser", "asa"]` 라고 USER 명령 앞 줄에 써두어야 asa 유저를 지정할 수 있다는 것.

### 라벨 지정 (LABEL 명령)

이미지에 버전 정보, 작성자 정보, 코멘트 등 정보를 제공한다.

`LABEL <키 명>=<값>`

- `docker inspect` 명령을 통해 확인할 수 있다.

### 포트 설정 (EXPOSE 명령)

컨테이너의 **공개 포트 번호**를 지정할 때 사용한다.

`EXPOSE <포트 번호>`

Docker에게, 실행 중인 컨테이너가 listen하고 있는 네트워크를 알려주는 효과가 있다.

이후 run 명령의 `-p` 옵션을 사용할 때, EXPOSE 시킨 컨테이너의 포트를 호스트의 몇 번 포트에 연결시킬 지 지정하게 된다.

### Dockerfile 내 변수 설정 (ARG 명령)

Dockerfile **안에서만 사용할 변수**를 정의할 때 사용한다.

해당 변수의 값에 따라, 생성되는 이미지의 내용을 바꿀 수 있다.

`ARG <이름>[=기본값]`

이후 Dockerfile을 빌드하는 시점에서, `--build-arg` 옵션을 통해 ARG 명령에서 지정했던 변수의 value를 다시 지정할 수 있다.

- 따로 지정하지 않았다면 기본값으로 빌드가 이루어진다.

### 기본 쉘 설정 (SHELL 명령)

쉘 형식으로 명령들을 지정할 때, 기본 쉘을 설정한다.

기본값은 Linux에서 `["/bin/sh", "-c"]`이다.

`SHELL ["쉘의 경로", "파라미터"]`

- 이후 Dockerfile 안에서 Shell 형식으로 서술한 RUN, CMD, ENTRYPOINT 명령에 대해 유효하다.

---

## 파일 설정

### 파일 및 디렉토리 추가 (ADD 명령)

이미지에 **호스트 상의** 파일이나 디렉토리를 추가할 때 사용한다.

`ADD <호스트의 파일 경로> <Docker 이미지의 파일 경로>`

- 이 때 호스트 파일 경로에, **와일드카드** 사용이 가능하다.

- WORKDIR 명령으로 미리 경로를 지정해두고 상대 경로로 표시하는 것도 바람직하다.

추가하려는 파일이 원격 파일에 대한 **URL**인 경우, 추가된 파일은 퍼미션이 **600**으로 설정된다.

- **인증** 관련 기능을 지원하지 않으므로, 원격 파일 다운로드에 인증이 필요하다면 RUN을 사용한다.

> #### 빌드에 불필요한 파일 제외
> 
> Docker 빌드 시 빌드를 실행한 디렉토리 아래에 있는 **모든 파일이 Docker 데몬으로 전송**된다.
> 
> 빌드에서 제외하고 싶은 파일이 있다면, `.dockerignore` 파일 안에 적어두면 된다.
> 
> - 여러 파일 지정 시 줄 바꿈을 하여 파일명을 나열한다.
> 
> 불필요한 파일을 전송하지 않음으로써 처리 속도를 빠르게 할 수 있다.

### 파일 복사 (COPY 명령)

이미지에 **호스트 상의** 파일이나 디렉토리를 복사할 때 사용한다.

`COPY <호스트의 파일 경로> <Docker 이미지의 파일 경로>`

ADD 명령과 달리 원격 파일에 대한 다운로드, 아카이브 압축 해제 같은 기능은 없고 단순 **호스트 파일 복사 처리**만 가능하다.

> #### Dockerfile의 저장 위치
> 
> 이미지를 만들 때 docker build 명령은, Dockerfile을 포함하는 디렉토리를 **전부** Docker 데몬으로 전송한다.
> 
> 그래서, Dockerfile의 저장 위치는 기본적으로 **빈 디렉토리**에서 시작하는 것을 권장하게 된다.

### 볼륨 마운트 (VOLUME 명령)

이미지에 볼륨을 할당한다.

`VOLUME ["/마운트 포인트"]`

지정한 이름의 마운트 포인트를 작성하고, 호스트나 그 외 다른 컨테이너로부터 **볼륨의 외부 마운트**를 수행한다.

기본적으로 컨테이너는 **영구 데이터를 저장하는 데 적합하지 않기** 때문에, 영구 저장이 필요한 데이터는 컨테이너 밖 호스트 스토리지에 저장하는 것이 좋다.

- 그래서 영구 데이터는 Docker 호스트 머신상의 볼륨의 마운트하거나, 공유 스토리지를 볼륨으로 마운트한다.
