# Chapter 05: Dockerfile을 사용한 코드에 의한 서버 구축

---

Docker에서는 **인프라 구성 관리**를 **Dockerfile**로 기술한다.

Dockerfile은 베이스 이미지에 각종 **미들웨어**를 설치 및 설정하고, 개발한 어플리케이션의 실행 모듈을 전개하기 위한 모든 **구성 정보**를 기술한다.

---

## Dockerfile을 사용한 구성 관리

### Dockerfile이란?

Dockerfile은, Docker 상에서 작동시킬 **컨테이너의 구성 정보**를 기술하기 위한 파일이다.

- 베이스가 될 Docker 이미지

- Docker 컨테이너 안에서 수행할 조작

- 환경변수 등 설정

- Docker 컨테이너 안에서 작동시켜 둘 데몬 실행

`docker build` 명령을 내리면, Dockerfile에 기술된 구성 정보를 바탕으로 Docker 이미지를 작성하게 된다.

### Dockerfile의 기본 구문

확장자가 필요 없는 텍스트 형식의 파일이다.

기본 서식은, `명령 인수` 의 형태이다.

- 명령은 관례적으로 대문자로 통일한다.

- FROM, RUN, CMD, LABEL, EXPOSE, ENV, ADD, COPY, ENTRYPOINT, VOLUME, USER, WORKDIR, ARG, ONBUILD, STOPSIGNAL, HEALTHCHECK, SHELL

주석은 `#`으로 달 수 있다.

### Dockerfile 작성

해당 컨테이너를 어떤 Docker 이미지로부터 생성할지 정보를 반드시 기술해야 하는데, 이를 **베이스 이미지**라고 한다.

`FROM [이미지명]`이 기본이고, 뒤에 `:[태그명]` 또는 `@[다이제스트]`를 붙일 수 있다.

- 이 때 다이제스트는, Docker Hub에 업로드 시 자동으로 부여되는 식별자를 뜻한다.

> #### Visual Studio Code를 사용한 Dockerfile
> 
> Dockerfile은 기본적으로 텍스트 형식이기 때문에, 임의의 에디터로 작성 및 편집할 수 있다.
> 
> - vscode-docker라는 확장 기능을 설치해서, 스니펫 표시 및 docker-compose.yml 파일 지원, Docker 이미지나 컨테이너 가동 상황 확인이 가능하다.

---

## Dockerfile의 빌드와 이미지 레이어

Dockerfile을 빌드하면, 파일에 정의된 구성을 바탕으로 하는 Docker 이미지를 작성할 수 있다.

### Dockerfile로부터 Docker 이미지 만들기

`docker build -t [생성할 이미지명]:[태그명] [Dockerfile의 위치]`

- 저장 위치는 절대 경로나 상대 경로 모두 가능하다.

- 빌드 명령을 내리면, `FROM` 절에 명시된 베이스 이미지를 **로컬에서 가져오거나 리포지토리에서 다운로드**하는 것으로 시작한다.

Dockerfile에는 임의의 파일명을 붙일 수도 있는데, `-f` 옵션을 붙이면 된다.

**표준 입력을 경유**하여 Dockerfile을 지정할 수도 있는데, Dockerfile의 내용을 build 명령의 인수로 전달하면 된다.

`docker build - < Dockerfile`

- 이 경우 빌드에 필요한 파일을 `ADD` 명령으로 추가할 수 없기 때문에, Dockerfile과 빌드에 필요한 파일들은 tar로 모아두고 지정하는 것이 좋다.

> #### 중간 이미지의 재이용
> 
> Docker는 이미지를 빌드할 때 자동으로 **중간 이미지**를 생성한다.
> 
> 그리고 다른 이미지를 빌드할 때, 중간 이미지를 내부적으로 재이용하여 빌드 속도를 높이고 있다.
> 
> - 이미지 재이용 시, 빌드 로그에 `Using cache` 라고 표시된다.

### Docker 이미지의 레이어 구조

Dockerfile의 명령별로 이미지를 작성할 때, 이미지는 레이어 구조로 되어 있다.

- 정확히는 Dockerfile에 명시된 명령 한 줄마다 이미지가 작성되고, 레이어 구조로 쌓인다.

- 이렇게 작성된 이미지들은 다른 이미지와 공유가 되기 때문에, FROM절에 들어가는 **베이스 이미지**는 특히 대부분 공유된다.
  
  - 이와 같은 이미지의 **겹침**을 통해 디스크 용량을 효율적으로 관리할 수 있다.

> #### Docker Hub의 이미지 관리
> 
> 어플리케이션을 담고 있는 이미지들은 OS의 파일을 포함하고 있기 때문에 용량이 크다.
> 
> 모든 이미지를 Hub에 하나씩 올리자면, 디스크 용량 부담이 지나치다.
> 
> 그래서 Docker Hub에서도 이미지를 레이어로 겹쳐 작성함으로써, 공통 이미지는 공유하여 관리하고 있다.
> 
> - 서로 다른 3개의 이미지가 공식 CentOS 이미지를 베이스로 사용했다면,
> 
> - CentOS의 **이미지 ID**가 모두 동일함을 이용해 3개의 이미지에서 하나의 실체를 공유한다.

---

## 멀티스테이지 빌드를 사용한 어플리케이션 개발

개발 환경에서 사용했던 라이브러리나 개발 지원 툴이 제품 환경에서 반드시 사용되는 것은 아니고, 리소스 절약이나 보안 관점에서 볼 때 최소한으로 필요한 실행 모듈만 남기는 것이 바람직하다.

이를 위해 **멀티스테이지 빌드 기능**을 적용해볼 수 있다.

### Dockerfile 만들기

```dockerfile
FROM gola:1.8.4-jessie AS builder
WORKDIR /go/src/github.com/asashiho/greet
RUN go get -d -v github.com/urfave/cli
COPY main.go .
RUN GOOS=linux go build -a -o greet .
# ---------------
FROM busybox
WORKDIR /opt/greet/bin
COPY --from=builder /go/src/github.com/asashiho/greet/ .
ENTRYPOINT ["./greet"]
```

두 개의 Docker 이미지를 한꺼번에 생성할 수 있는 Dockerfile에 해당한다.

#### 1. 개발 환경용 Docker 이미지

Go를 베이스 이미지로 builder라는 별명을 붙여 작성하고,

로컬 환경에 있는 소스코드를 컨테이너 안으로 복사하여 greet 라는 이름의 바이너리 파일로 작성한다.

#### 2. 제품 환경용 Docker 이미지

베이스 이미지를 **busybox**로 가지는데, 이는 **기본적인 Linux 명령들을 하나의 파일로 모아놓은 것**으로 최소한으로 필요한 **Linux 쉘 환경**을 제공하고자 할 때 이용된다.

개발 환경에서 빌드한 greet라는 이름의 바이너리 파일을 복사해오고, 복사한 파일을 실행하는 명령어를 넣는다.

### Docker 이미지의 빌드

`docker build -t greet .`로 이미지를 빌드해보면,

- 개발 환경의 베이스 이미지인 golang을 다운로드하고

- 그것을 바탕으로 개발 환경용 이미지 builder가 생성되며

- 해당 builder 이미지로 소스코드를 빌드해 실행 가능한 바이너리 파일을 생성한 뒤

- 제품 환경용 이미지에 그러한 실행 가능 바이너리 파일을 복사한다.

결과적으로,

- greet라는 이미지가 개발 환경에서 개발될 시점에는 golang이라는 대규모 베이스 이미지를 깔고 들어감으로써 **개발에는 적합하나 용량이 과다한** 모습이 되는데,

- 제품 환경에서는 busybox라는 최소한의 모듈에 greet를 실행시키는 파일을 복사하는 식으로 구동시켜 용량을 크게 절약할 수 있다.

제품 환경에서는 부하에 따라 작동하는 컨테이너의 수가 바뀌므로, 각 이미지의 용량을 절약함으로써 **시스템 전체의 컴퓨팅 리소스**를 효율적으로 활용할 수 있다.

### Docker 컨테이너의 시작

제품 환경용으로 만든 저용량 이미지인 greet만으로도, 개발 환경에서와 동일한 결과물을 낼 수 있다.

---

## 명령 및 데몬 실행

Docker 이미지를 만들려면 필요한 **미들웨어**를 설치하고, 사용자 계정이나 디렉토리를 작성하는 등의 **명령**을 실행해야 한다.

또한 이미지로부터 컨테이너를 생성했을 때 서버 프로세스 등을 **데몬**으로서 작동시킬 필요가 있다.

### 명령 실행(RUN 명령)

FROM 명령으로 지정한 베이스 이미지에 대해, 다음과 같은 목적으로 사용하는 것이 `RUN` 명령이다.

- 어플리케이션이나 미들웨어를 설치 및 설정

- 환경 구축을 위한 명령을 실행

`RUN [실행하고 싶은 명령]`

기술 방법이 두 가지로 구분된다.

#### Shell 형식으로 기술하는 방법

명령의 지정을 **쉘에서 실행하는 형식으로** 기술하는 방법.

`RUN apt-get install -y nginx`

- apt 명령을 사용해 Nginx를 설치하는 명령

- 컨테이너 안에서 /bin/sh -c를 사용해 명령을 실행했을 때와 똑같이 작동시킬 수 있다.

#### Exec 형식으로 기술

Shell 형식으로 기술하면 /bin/sh 안에서 실행되지만, Exec 형식으로 기술하면 **쉘을 경유하지 않고 직접 실행**한다.

- 명령 인수에 $HOME 같은 환경변수를 지정할 수 없고,

- 실행하고 싶은 명령을 **JSON** 배열로 지정하게 된다.

- 다른 쉘을 이용하고 싶으면, 쉘의 경로를 지정한 뒤에 실행할 명령을 넣으면 된다.

`RUN ["/bin/bash", "-c", "apt-get install -y nginx"]`

- /bin/bash를 지정하여 apt 명령어로 Nginx를 설치하는 명령.
