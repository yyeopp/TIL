# Chatper 04: Docker 명령

---

Docker 이미지를 레지스트리에서 다운로드/업로드, Docker 컨테이너 시작/정지하는 등의 조작은 모두 명령어로 작동한다.

---

## Docker 이미지 조작

Docker의 공식 레지스트리 서비스인 Docker Hub에서 공개 이미지를 취득하는 방법

### Docker Hub

Github 같은 소스코드 관리 툴과 연계해 코드를 빌드하는 기능과, 실행 가능한 어플리케이션의 이미지를 관리하는 기능을 갖춘 Docker 공식 리포지토리 서비스.

도커 허브를 사용해 물리 서버, 가상 머신, 클라우드 어디든 Docker 이미지 배포가 가능하다.

- Debian 같은 공식 이미지는 Official 표시가 붙어 있다.

이미지 버전 관리는 **태그**로 이루어지는데, 이미지명 옆에 `:태그명`을 붙이는 식이다.

- `latest`를 붙이면 공개된 버전 중 가장 최신 이미지를 가르킨다.

> #### Docker store
> 
> Docker사가 제공하는 소프트웨어 마켓 플레이스.
> 
> 멀웨어 테스트 등을 모두 통과하고 서명된 것을 배포한다.
> 
> 요금 부과, 라이선스 관리 장치도 가지고 있어서 많은 상용 소프트웨어가 참여 중이다.

### 이미지 다운로드

`docker image pull [옵션] 이미지명:[태그명]`

- `-a` 옵션을 넣으면 **모든 태그**의 이미지를 취득할 수 있다.

- 이미지명에 이미지를 취득할 수 있는 **URL**을 넣을 수도 있다.

### 이미지 목록 표시

`docker image ls [옵션] [리포지토리명]`

Docker 이미지는 작성 시 고유 ID가 부여되고, ls 명령 시 표시된다.

Docker 레지스트리에 업로드한 이미지는 고유 식별값으로서 **다이제스트**가 부여되는데, `--digests`를 옵션으로 넣으면 확인 가능하다.

> #### 이미지의 위장이나 변조를 막으려면
> 
> Docker에는 **인프라 구성**이 포함되기 때문에, 제3자의 악의적인 변조로부터 보호할 필요가 있다.
> 
> 이 때 **Docker Content Trust**(DCT) 기능을 사용해 이미지의 정당성을 확인할 수 있다.
> 
> ##### 서명
> 
> 이미지 작성자가 Docker 레지스트리에 이미지를 push하기 전에, **로컬 환경**에서 이미지 작성자의 **비밀키**를 사용해 이미지에 서명한다.
> 
> - 이 비밀키를 **Offline Key**라고 하는데, 보안상 매우 중요한 키이므로 엄중하게 관리해야 한다.
> 
> ##### 검증
> 
> 서명된 이미지를 pull할 때, 이미지 작성자의 **공개키**를 사용해 이미지가 진짜인지 확인한다.
> 
> 만약 변조된 경우 해당 이미지는 **무효화**된다.
> 
> - 이 공개키를 **Tagging Key**라고 한다.
> 
> ##### 기능 사용
> 
> `export DOCKER_CONTENT_TRUST=1`로 DCT 기능을 유효화할 수 있다.
> 
> 유효화 이후부터는, pull할 때 이미지 검증 절차가 추가되는 것을 볼 수 있다.

### 이미지 상세 정보 확인

`docker image inspect`

이미지 ID, 작성일, Docker 버전, CPU 아키텍처 등이 표시된다.

### 이미지 태그 설정

태그는 이미지의 표식이 된다. 보통 식별하기 쉬운 **버전명**을 붙인다.

Docker Hub에 업로드할 때는,

`<Docker Hub 사용자명>/이미지명:[태그명]`의 규칙으로 업로드가 이루어진다.

### 이미지 검색

`docker search [옵션] <검색 키워드>`

Docker Hub에 공개되어 있는 이미지를 검색할 수 있다.

- 검색 결과에서 Official 여부, Stars(즐겨찾기 수)를 확인할 수 있다.

### 이미지 삭제

`docker image rm [옵션] 이미지명 [이미지명]`

실행 시, 중간 이미지도 함께 삭제된다.

사용하지 않는 Docker 이미지를 삭제할 때에는

`docker image prune [옵션]`을 사용한다.

- 사용하지 않는 이미지는 디스크 용량을 쓸데없이 잡아먹기 때문에, 정기적으로 삭제하는 것이 좋다.

### Docker Hub에 로그인

`docker login [옵션] [서버]`

Docker 리포지토리에 업로드하기 위해 필요하다.

서버명을 별도로 지정하지 않으면 Docker Hub에 엑세스하는 식이다.

### 이미지 업로드

`docker image push 이미지명[:태그명]`

등록된 이미지는

`<Docker Hub 사용자명>/이미지명:[태그명]` 으로 표시된다.

### Docker Hub에서 로그아웃

`docker logout [서버명]`

---

## Docker 컨테이너 생성 / 시작 / 정지

### Docker 컨테이너의 라이프 사이클

#### 컨테이너 생성

`docker container create`

이미지에서 컨테이너를 생성한다.

이미지의 실체는, **Docker에서 서버 기능을 작동시키기 위해 필요한 디렉토리 및 파일들**이다.

- Linux 작동에 필요한 /etc나 /bin 등이 포함되어 있다.

create 명령 실행 시 이미지에 포함될 Linux 디렉토리와 파일들의 **스냅샷**을 취하게 된다.

- 스냅샷은, 스토리지 안에 존재하는 파일과 디렉토리를 **특정 타이밍에 추출한 것**을 말한다.

#### 컨테이너 생성 및 시작

`docker container run`

이미지로부터 컨테이너를 생성하고(create), 그 위에서 프로세스를 시작한다.

포트 번호 같은 네트워크 설정을 포함시켜, 외부에서 컨테이너에 프로세스에 엑세스할 수 있도록 할 수도 있다.

#### 컨테이너 시작

`docker container start`

**정지 중인** 컨테이너를 시작할 때 사용한다.

#### 컨테이너 정지

`docker container stop`

실행 중인 컨테이너를 정지시킬 때 사용한다.

컨테이너 삭제를 위해서는 stop 명령이 선행되어야 한다.

컨테이너 재시작에는 `restart` 명령을 사용하면 된다.

#### 컨테이너 삭제

`docker container rm`

정지 중인 컨테이너 프로세스를 삭제해, **스냅샷을 소멸**시킨다.

#### 그 외

컨테이너 상태를 확인하는 `docker container ps`

컨테이너를 일시정지하는 `docker container pause` 등이 있다.

### 컨테이너 생성 및 시작

`docker container run [옵션] 이미지명[:태그명] [인수]`

옵션 값을 어떻게 지정하는 지가 중요하다.

- `-it` 를 주면 컨테이너의 표준 출력을 찍어낼 수 있다.

- `--name`으로 컨테이너 이름을 지정할 수 있다.

> #### 프롬프트
> 
> **명령을 입력할 수 있는 표시**를 말한다.
> 
> `docker@default:~$` 이런 식으로 뜨는데,
> 
> - docker는 사용자명
> 
> - default는 호스트명
> 
> - ~는 작업 디렉토리
>   
>   - Linux의 경로가 표시된다. ~는 사용자의 홈 디렉토리.
> 
> - $는 사용자의 권한
>   
>   - 일반 사용자는 $이고, 관리자는 #로 표시된다.
> 
> `sudo su`로 관리자 계정으로 접속하면 프롬프트 표시가 바뀐다.

### 컨테이너의 백그라운드 실행

run 시 `-d` 옵션을 넣어주면 백그라운드 실행이 가능하다.

실행 중인 컨테이너의 로그는 `docker container logs`로 확인 가능하다.

백그라운드 실행 시 restart나 rm 같은 명령을 부가할 수도 있다.

### 컨테이너의 네트워크 설정

run 시 **네트워크 관련 옵션**을 넣어줄 수 있다.

`-p`는 컨테이너의 포트 번호와 호스트 OS의 포트 번호를 매핑할 때 사용된다.

- 지정된 범위 내에서 포트 번호를 할당하고 싶으면 `--expose`를,

- 호스트 OS에 **임의의 포트를 할당**하고 싶으면 `-P`를 사용한다.

**DNS 서버를 설정**할 때는 `--dns`에 IP주소를 지정한다.

**MAC 주소를 설정**할 때는 `--mac-address`를 지정한다.

컨테이너 안에서 직접 호스트명과 IP 주소를 정의하려면, `--add-host`를 사용한다.

Docker는 기본적으로 호스트 OS에 **브리지 연결**을 하는데, `--net` 옵션을 사용해 그 외의 설정이 가능하다.

- `--net=[NETWORK]`는 **사용자 정의 네트워크**를 사용하겠다는 뜻.

- `docker network create`를 이용해 사용자 정의 네트워크를 만들 수 있는데, Docker 네트워크 드라이버 또는 외부 네트워크 드라이버 플러그인을 사용해 만든다.
  
  - 똑같은 네트워크에 여러 컨테이너가 연결 가능하므로,
  
  - 사용자 정의 네트워크에 연결된 여러 컨테이너들은 서로 통신이 가능하다.

- 오버레이 네트워크나 커스텀 플러그인을 사용하면 **멀티호스트** 연결도 가능하다.
  
  - 컨테이너들이 동일한 멀티호스트 네트워크에 연결되어 있으면, 해당 네트워크를 통해 서로 통신할 수 있다.

### 자원을 지정하여 컨테이너 생성 및 실행

run 시 옵션을 넣어, CPU나 메모리 등 자원을 지정해 컨테이너를 생성 및 실행할 수 있다.

- `-c`로 CPU 사용 배분을 정하는데, 기본이 1024이므로 그에 맞춰 조정 가능하다.

- `-m`으로 메모리 제한을 걸 수 있다.

호스트 OS와 컨테이너 안의 디렉토리를 **공유**할 때는 `-v`를 지정한다.

### 컨테이너를 생성 및 시작하는 환경을 지정

run 시 컨테이너의 환경변수와 컨테이너 안 작업 디렉토리를 지정할 수 있다.

- `-e`에 환경변수들을 직접 정의할 수 있고,

- `--env-file=[파일명]`으로 파일로부터 환경변수 설정이 가능하다.

- `-w=[패스]`로 컨테이너의 작업 디렉토리를 설정한다.

### 가동 컨테이너 목록 표시

`docker container ls [옵션]`

- 컨테이너 ID를 비롯한 정보 확인이 가능하다.

- `-a` 옵션을 주면 정지 중인 컨테이너도 표시된다.

### 컨테이너 가동 확인

`docker container stats [컨테이너 식별자]`

이 위에서 실행 중인 프로세스를 확인할 때는, `docker container top [컨테이너명]`을 쓴다.

### 컨테이너 시작

`docker container start [옵션] <컨테이너 식별자> [컨테이너 식별자]`

### 컨테이너 정지

`docker container stop [옵션] <컨테이너 식별자> [컨테이너 식별자]`

- `-t` 옵션을 줘서 정지 시간을 설정할 수 있다.

- `kill` 명령은 강제 정지다.

### 컨테이너 재시작

`docker container restart [옵션] <컨테이너 식별자> [컨테이너 식별자]`

정지 시간 설정 가능하다.

> #### Linux 명령을 모르면 안 되는가?
> 
> Linux 또한 GUI가 가능하지만, 서버용으로 사용한다면 대부분 CLI를 사용한다.
> 
> 그 이유는,
> 
> - **네트워크를 통해 조작**할 수 있다.
> 
> - 정형 작업을 프로그래밍으로 **자동화**할 수 있다.
> 
> 특히 클라우드 서비스는 서버가 데이터센터에 있고, 원격으로 조작하므로 터미널 단말기 선에서 네트워크를 통해 조작할 수 있는 CLI가 편리하다.
> 
> 시스템 운용을 자동화하는 측면에서도 CLI가 유리하다.

### 컨테이너 삭제

`docker container rm [옵션] <컨테이너 식별자> [컨테이너 식별자]`

정지 중인 모든 컨테이너를 삭제하려면 `docker container prune`을 쓴다.

### 컨테이너 중단 / 재개

`docker container pause <컨테이너 식별자>`

`docker container unpause <컨테이너 식별자>`

---

## Docker 컨테이너 네트워크

`docker network ls [옵션]`

네트워크의 구성 정보를 확인할 수 있는데, 기본값으로 bridge, host, none 3개가 만들어져 있다.

run 시 네트워크를 명시적으로 지정하지 않고 컨테이너를 시작하면, 기본값인 **bridge** 네트워크로 컨테이너를 시작하게 된다.

> #### 오버레이 네트워크
> 
> 물리 네트워크 상에서 **소프트웨어적으로 에뮬레이트한 네트워크**를 말한다.
> 
> 물리 네트워크를 덮는 느낌으로 구성된다는 점에서 **가상 네트워크**라고도 부른다.
> 
> 물리 네트워크 구조가 은폐되어, 그 아래에  있는 물리 계층의 형태나 제어 방식 등을 **의식하지 않고** 이용할 수 있는 특징이 있다.
> 
> - 주로 여러 개의 호스트에 걸친 네트워크를 구성할 때 사용한다.

### 네트워크 작성

`docker network create [옵션] 네트워크`

옵션으로 `--driver`를 설정할 수 있는데, 네트워크 브리지 또는 오버레이 값을 뜻한다.

- 기본값은 이미 만들어져 있는 bridge로 지정되어 있고, overlay도 설정 가능하다.
  
  - 오버레이 네트워크는, **여러 호스트에 걸쳐 있는** 네트워크를 말한다.

- **커스텀** 네트워크 드라이버도 만들어서 사용할 수 있다.

### 네트워크 연결

`docker network connet [옵션] 네트워크 컨테이너`

위 명령을 실행한면, 특정 컨테이너를 특정 네트워크에 연결시킬 수 있다.

- 연결은 옵션을 이용해, IP 주소나 컨테이너명, 컨테이너 ID 등으로 가능하다.

연결 이후에는, 동일 네트워크 상에 있는 다른 컨테이너와 통신이 가능하다.

컨테이너 run 단계에서도 `--net` 옵션으로 네트워크를 만들며 연결할 수 있다.

`docker network disconnet [옵션] 네트워크 컨테이너` 로 연결이 해제된다.

### 네트워크 상세 정보 확인

`docker network insepct`

### 네트워크 삭제

`docker network rm [옵션] 네트워크`

---

## 가동 중인 Docker 컨테이너 조작

### 기동 컨테이너 연결

`docker container attach 컨테이너`

백그라운드에 작동 중인 컨테이너와 연결된다.

### 가동 컨테이너에서 프로세스 실행

`docker container exec [옵션] <컨테이너 식별자> <실행할 명령> [인수]`

### 가동 컨테이너의 프로세스 확인

`docker container top 컨테이너`

### 가동 컨테이너의 포트 전송 확인

`docker container port 컨테이너`

> #### 잘 알려진 포트(well-known port)에 대해
> 
> TCP/IP를 이용한 데이터 통신에서, **특정 프로토콜에서 사용하는 것으로 예약되어 있는** 포트 번호를 well-known port라고 한다.
> 
> 포트 번호는 0부터 65535까지 있는데, 그 중 well-known port는 1부터 1023까지 분포하고 있다.
> 
> - 사용자 어플리케이션이라면 1024 이후의 포트 번호를 사용하는 것이 관례이다.
> 
> 이러한 well-known port의 할당은 인터넷 관련 번호를 통합 관리하는 조직인 IANA에서 하고 있다.

### 컨테이너 이름 변경

`docker container rename old new`

### 컨테이너 안의 파일을 복사

`docker container cp <컨테이너 식별자>:<컨테이너 안의 파일 경로> <호스트의 디렉토리 경로>`

`docker container cp <호스트의 파일> <컨테이너 식별자>:<컨테이너 안의 파일 경로>`

### 컨테이너 조작의 차분 확인

`docker container diff <컨테이너 식별자>`

컨테이너 안에서 어떤 조작을 하여, 컨테이너가 이미지로부터 **생성된 시점 기준 달라진 점**을 확인할 때 사용한다.

- A는 파일 추가, D는 파일 삭제, C는 파일 수정을 뜻한다.

---

## Docker 이미지 생성

Docker 컨테이너를 바탕으로 이미지를 작성하는 것도 가능하다.

### 컨테이너로부터 이미지 작성

`docker container commit [옵션] <컨테이너 식별자> [이미지명[:태그명]]`

독자적으로 작성한 이미지를 공개한다면, `-a`나 `-m` 옵션으로 작성자, 커밋 메시지를 붙여두는 게 좋다.

### 컨테이너를 tar 파일로 출력

`docker container export <컨테이너 식별자>`

가동 중인 컨테이너의 디렉토리와 파일들을 모아서 tar 파일로 만들고, 이를 바탕으로 다른 서버에서 컨테이너를 가동시킬 수 있다.

### tar 파일로부터 이미지 작성

`docker image import <파일 또는 URL> | - [이미지명[:태그명]]`

Linux OS 이미지의 디렉토리, 파일로부터 Docker 이미지를 만들 수 있다.

파일 하나만을 지정할 수 있으므로, tar 같이 파일을 묶어둘 필요가 있다.

### 이미지 저장

`docker image save [옵션] <저장 파일명> [이미지명]`

Docker 이미지를 tar 파일로 저장할 수 있다.

### 이미지 읽어 들이기

`docker image load [옵션]`

tar 이미지로부터 읽어들인다.

> #### export/import와 save/load의 차이
> 
> - export의 경우 컨테이너를 작동시키는 데 **필요한 파일을** 모두 압축 파일로 모은다.
>   
>   - 해당 tar 파일을 풀면, **컨테이너의 루트 파일 시스템**이 그대로 출력된다.
> 
> - 반면 save의 경우 **이미지의 레이어 구조**를 포함한 형태로 압축 파일이 생성된다.
>   
>   - tar 파일을 풀어도 파일 시스템이 아닌 이미지 레이어 구조만 확인 가능하다.
> 
> 즉, 바탕 이미지가 똑같은 상태로 export와 save를 하면 그 결과물의 **내부 디렉토리와 파일 구조가 다르다**.

### 불필요한 이미지/컨테이너를 일괄 삭제

`docker system prune [옵션]`

사용하지 않는 이미지, 컨테이너, 볼륨, 네트워크를 전부 일괄 삭제할 수 있다.

> #### 머신러닝에서의 Docker 이용
> 
> Docker는 주로 웹 시스템에서 컨테이너 오케스트레이션 툴인 Kubernetes와 함께 운용된다.
> 
> 하지만 Docker가 가지는 높은 이식성을 살려 머신러닝에서도 자주 이용되고 있다.
> 
> - 특히 딥러닝에서는 프레임워크나 다양한 라이브러리를 이용하는 경우가 일반적인데, Docker를 사용해 환경에 의한 변수를 최소화할 수 있다.
> 
> - 대표적인 머신러닝 개발 툴인 Jupyter Notebook이나 딥러닝 프레임워크 TensorFlow도 공식 Docker 이미지를 제공하고 있다.
> 
> - Kubernetes에서도 TensorFlow에 최적화된 환경을 구축하기 위해 Kuberflow라는 오픈소스 소프트웨어를 개발하고 있다.
> 
> 즉, Docker는 웹 엔지니어뿐 아니라 넓은 분야의 엔지니어에게 편리한 툴로 이용되고 있다.


