# 제 3부 실행 환경 구축편

---

# Chapter 07: 여러 컨테이너의 운용 관리

---

Docker를 제품 환경에서 운용할 때는 보통 어플리케이션 서버, 로그 서버, 프록시 서버 등 **여러 개의 컨테이너들을 연계하여** 작동시킨다.

---

## 여러 컨테이너 관리의 개요

### 웹 3계층 시스템 아키텍처

어플리케이션 가동을 위해, 여러 서버에 기능과 역할을 분할하여 인프라 전체를 구성하는 것을 **인프라 아키텍처**라고 한다.

**웹 3계층 아키텍처**는 웹 어플리케이션의 대표적인 인프라 아키텍처로, 웹 시스템의 서버들을 역할별로 3개로 나누는 설계 사상이다.

#### 프론트 서버

클라이언트의 웹 브라우저가 보낸 HTTP 요청을 받아, HTTP 응답을 반환하는 서버 기능을 가진다.

- 웹 프론트 서버, 웹 서버라고 말한다.

미들웨어로 구축하는 경우도 있고, 오픈소스로는 **Nginx**, MS의 IIS 등이 있다.

**요청 처리**가 메인 업무이므로, **부하분산**을 적절히 대비하여야 한다.

- 스케일러블하게 처리 대수를 산정하고, 

- **로드밸런서** 같은 기기를 사용하게 된다.

#### 어플리케이션 서버

**업무 처리**를 실행하는 서버이다.

결제나 수주 처리 등, 어플리케이션의 처리를 실행하는 **프로그램의 실행 환경**이 된다.

프론트 서버와 마찬가지로 미들웨어로 구축하는 경우가 있다.

#### 데이터베이스 서버

**영구 데이터를 관리**하기 위한 서버다.

어플리케이션 처리 실행에서 발생하는 **영구 데이터**는, **RDBMS** 기능을 가진 미들웨어에서 관리되는 편이다.

- 오픈소스인 MySQL이나 PostgreSQL, Oracle의 Oracle DB 등이 있다.

**NoSQL**의 경우, RDMBS와는 다른 새로운 방식을 총칭한다.

- **병렬분산처리**나 **유연한 스키마 설정** 등이 특징이고,

- 주요 방식으로는 **KVS**나 **도큐먼트 지향 데이터베이스** 등이 있다.

- **대량의 데이터 축적**이나 **병렬처리**를 특기로 하기 때문에, **많은 사용자의 엑세스를 처리**하는 온라인 시스템에서 널리 이용된다.

- 오픈소스인 Redis나 MongoDB 등이 있다.

영구 데이터에 대해서는 높은 가용성이 요구되어, **클러스터링** 같은 기술로 **다중화**하는 경우가 많다.

만일의 장애에 대비해, **데이터 백업**이나 **원격지 보관** 등의 대책을 강구해 둘 필요도 있다.

DB 조작은 부하가 상당하기 때문에, 운용 상황에 따라 OS나 미들웨어의  설정 변경 등 **퍼포먼스 튜닝**이 요구된다.

### 영구 데이터의 관리

시스템 운용 중 생성되고 축적되는 데이터 중 프로그램 종료 후에도 스토리지에 저장되는 것을 영구 데이터라고 한다.

- 영구 데이터는 기본적으로 **시스템 가동 시간**에 따라 증감 및 변화하는 특징이 있다.

스토리지 저장 영역에도 한계가 있고, 스토리지 자체가 고장날 위험도 있기 때문에 영구 데이터에 대한 적절한 관리가 필요하다.

#### 데이터의 백업 및 복원

서버 장애에 대비한다.

내부에는 기밀 정보도 포함되기 때문에, 보안 대책이나 적절한 운용 규칙이 필요하다.

테이프 디바이스 같은 물리 매체나, 클라우드 상 스토리지 서비스나, 원격지에 보관하게 된다.

#### 로그 수집

여러 서버로 된 분산 환경이라면 로그 수집 전용 서버를 마련하는 것이 일반적이다.

특히 사용자 인증 액세스 로그 등은 감사 대상이기 때문에 장기 저장이 의무화되는 경우도 있다.

- Unix 계열은 syslogd라는 데몬을 사용해 커널과 어플리케이션의 로그를 관리할 수 있다.

Docker는, 컨테이너를 사용해 서버 기능을 제공하면서 필요에 따라 생성하거나 파기하는 식으로 운용한다.

- 따라서, 시스템 가동 후 생성되는 영구 데이터는 별도의 인프라 아키텍처를 검토하는 게 바람직하다.

> ##### 컨테이너에서 영구 데이터를 다룰 때 주의점
> 
> **미션 크리티컬 시스템**들은 대부분 **다중 구성** 등을 통해 만일의 장애나 사고에 대비하고 있다.
> 
> 인프라 구축, 운용에서 가장 어려운 점이 바로 영구 데이터 관리라고 해도 과언이 아님.
> 
> 반면 Docker 컨테이너는 **웹 프론트 서버** 같이 트래픽 증감 등에 맞춰 필요할 때 실행했다가 파기하는 **일회성 운용**에 적합한 편이다.
> 
> 즉, 컨테이너 안은 중요한 영구 데이터를 저장하는 데 **적합하지 않다**. 시스템에 특성을 잘 살펴서, 컨테이너에서 운용하는 게 바람직한지 검토할 필요가 있는 것.
> 
> Docker의 기능을 쓴다고 할 때,
> 
> - 데이터 전용 컨테이너에서 데이터를 관리하는 방법
> 
> - 로컬 호스트를 마운트하여 영구 데이터를 저장하는 방법 등이 있다.
> 
> Docker의 경우 트래픽 변동이 큰 **대규모 웹 시스템**이나 여러 디바이스로부터 데이터를 처리하는 IoT, 단시간의 대량의 리소스를 처리하는 과학기술계산 분야에 위력적이다. 
> 
> 기존 시스템 이전보다는 새로운 시스템을 도입하는 용도에 보다 적합하다.
> 
> 그리고 어플리케이션 환경과 인프라 환경을 모아서 관리할 수 있는 Dockerfile, 이미지, 레지스트리를 사용해 어플리케이션 **이식성**이 올라가는 장점을 가지기 때문에, 그러한 이식성이 요구되는 환경인지부터 검토가 필요하다.

### Docker Compose

Docker Compose는 여러 컨테이너를 모아서 관리하기 위한 툴이다.

`docker-compose.yml` 이라는 파일에 **컨테이너의 구성 정보**를 정의함으로써, **동일 호스트상의 여러 컨테이너를 일괄적으로 관리**할 수 있다.

- 웹 어플리케이션의 의존관계(DB, 큐, 캐시, 어플리케이션 등)를 모아서 설정할 수 있다.

- YAML 형식의 파일이므로, CI/CD 프로세스에서 자동 테스트를 할 때 환경 구축에도 그대로 이용 가능하다.

---

## Docker Compose를 사용한 여러 컨테이너의 구성 관리

여러 컨테이너를 실행시킬 때, 제각각 구성, 시작, 정지를 관리하기가 번잡하다.

여러 컨테이너를 일괄 관리하는 툴로 Docker Compose가 있다.

### docker-compose.yml의 개요

Compose 정의 파일로, 시스템 안에서 가동하는 여러 서버들의 구성을 모아서 정의한다.

YAML 형식을 따른다.

> #### YAML
> 
> 구조화된 데이터를 표현하기 위한 데이터 포맷으로, **들여쓰기**를 통해 데이터 계층 구조를 나타낸다.
> 
> 누가 써도 읽기가 쉬워서 설정 파일 등에 많이 이용된다.

Compose 정의 파일에는, 관리할 컨테이너의 **서비스, 네트워크, 볼륨**을 정의하게 된다.

버전에 따라 기술하는 항목이 달라지기 때문에 버전 명시가 중요하다.

```yaml
version: "3"

services:
    webserver:
        image: ubuntu
        ports:
            - "80:80"
        networks:
            - webnet
    redis:
        image: redis
        networks:
            - webnet
networks:
    webnet:

volumes:
    data-volume:
```

- webserver라는 서비스와 redis를 함께 돌리는 docker-compose.yml의 예시이다.

### 이미지 지정 (image)

컨테이너의 **베이스 이미지**를 지정하려면 image를 사용한다.

- 위 예시에서 webserver의 베이스 이미지는 ubuntu가 된다.

- Docker Hub에 공개된 이미지는 모두 지정할 수 있다.

### 이미지 빌드 (build)

Dockerfile을 바탕으로 **이미지를 직접 빌드해서 사용**하는 경우라면, build를 사용한다.

build 옵션의 내용은 **Dockerfile의 경로**이다.

- 추가 옵션으로 context, dockerfile을 지정할 수 있다.

- 빌드 시 인수를 args에서 설정할 수 있다. 이 때 변수 값은 Docker Compose를 실행하는 머신 위에서만 유효하다.

### 컨테이너 안에서 작동하는 명령 지정 (command/entrypoint)

컨테이너에서 작동하는 명령을 지정한다.

베이스 이미지에 지정되어 있는 CMD와 ENTRYPOINT를 덮어쓴다.

### 컨테이너 간 연결 (links)

다른 컨테이너에 대해 링크 기능을 사용하여 연결한다.

**서비스 간 의존관계**는, depends_on을 사용해 지정할 수 있다.

### 컨테이너 간 통신 (ports/expose)

컨테이너가 공개하는 포트는 **ports**로 지정한다.

- 호스트 머신 포트 번호:컨테이너 포트 번호로 매칭하는데, 컨테이너의 포트 번호만 지정하면 호스트 머신 포트는 랜덤하게 지정된다.

호스트 머신에 대해 포트를 공개하지 않고, **링크 기능**을 사용해 연결하는 컨테이너에게만 포트를 공개한다면 **expose**를 지정한다.

- 로그 서버 같이, **호스트 머신에서 직접 엑세스하지 않고** 웹 어플리케이션을 경유해서만 액세스하고자 하는 경우에 사용한다.

### 서비스의 의존관계 정의 (depends_on)

여러 서비스의 의존관계를 정의할 때 사용한다.

특정 컨테이너가 다른 컨테이너에 의존한다고 명시되면, 시작할 때 의존하고 있는 컨테이너가 먼저 실행된다.

- 단, **시작 순서**까지만 제어해줄 뿐, 컨테이너 상의 어플리케이션이 **이용 가능할 때까지** 기다려주는 것은 아니다.
  
  - 의존하고 있는 컨테이너 속 어플리케이션이 아직 부팅 중일 수 있다는 것.

- 의존성을 가지는 어플리케이션 측은 이에 대해 대책을 세울 필요가 있다.

### 컨테이너 환경변수 지정 (environment/env_file)

컨테이너 안의 환경변수를 지정할 때 사용한다.

YAML 배열 형식이나 해시 형식으로 지정할 수 있다.

환경변수 수가 많으면, 다른 파일에 정의하고 그 파일을 읽어들일 수도 있다.

- 어플리케이션 안에서 사용하는 비밀정보의 관리는, **컨테이너 오케스트레이션 툴**의 기능을 사용하는 편이 좋다.

### 컨테이너 정보 설정 (container_name/labels)

Docker Compose에 의해 생성되는 컨테이너에 이름을 붙일 때 사용한다.

단, 컨테이너명은 고유해야하기 때문에 커스텀명 지정 시 **여러 컨테이너로 스케일할 수 없다**.

라벨을 붙일 때는 **labels**를 지정한다.

### 컨테이너 데이터 관리 (volumes/volumes_from)

컨테이너에 볼륨을 마운트할 때 사용한다.

- 뒤에 `:ro`를 지정하면, 볼륨을 읽기 전용으로 마운트할 수 있다.

다른 컨테이너로부터 **모든 볼륨을 마운트**할 때는 volumes_from에 **컨테이너명을 지정**한다.

---

## Docker Compose를 사용한 여러 컨테이너의 운용

### Docker Compose의 버전 확인

`docker-compose --version`

### Docker Compose의 기본 명령

up, ps, logs, run, start, stop, restart, pause, unpause, port,.config, kill, rm, down 등이 있다.

기본적으로 docker-compose.yml을 저장한 디렉토리에서 실행이 가능한 명령들이다.

명령어 뒤에서 **컨테이너명을 지정**하면, 해당 컨테이너만을 조작할 수 있다.

### 여러 컨테이너 생성 (up)

`docker-compose up [옵션] [서비스명 .]`

docker-compose.yml을 바탕으로 여러 개의 컨테이너를 생성하여 시작한다.

- `-d` 옵션으로 백그라운드 실행이 가능하다.

- `--build` 옵션으로, 컨테이너 시작 시에 Dockerfile을 빌드할 수 있다.

- `--scale [서비스명=수]` 옵션으로, 컨테이너를 생성할 개수를 지정할 수 있다.
  
  - 동일한 이미지에서 컨테이너를 다수 생성할 수 있다.

### 여러 컨테이너 확인 (ps/logs)

`docker-compose ps`

Docker Compose를 통해 여러 개의 컨테이너가 연결되어 작동할 때, 이들의 목록을 표시한다.

Compose를 사용했다고 해도 Docker 컨테이너인 것은 마찬가지이므로, 보통의 Docker 명령 사용도 가능하다.

`docker-compose logs`

로그 확인할 수 있다.

### 컨테이너에서 명령 실행 (run)

컨테이너에서 임의의 명령을 실행하고 싶을 때 사용한다.

### 여러 컨테이너 시작/정지/재시작 (start/stop/restart)

여러 서비스를 일괄적으로 제어할 수 있다.

특정 컨테이너만을 조작하고 싶으면, 명령 인수에서 컨테이너명을 지정한다.

### 여러 컨테이너 일시정지/재개 (pause/unpause)

여러 서비스를 일괄적으로 일시정지하고 재개한다.

### 서비스의 구성 확인 (port/config)

`docker-compose port [옵션] <서비스명> <프라이빗 포트 번호>`

해당 서비스의 **공개용 포트**를 확인할 수 있다.

config 명령으로 Compose 구성 파일의 내용을 확인할 수 있다.

### 여러 컨테이너 강제 정지/삭제 (kill/rm)

실행 중인 컨테이너를 강제 정지시킬 때 kill 명령을 사용한다.

해당 명령은 컨테이너에게 **시그널**을 송신하는 방식으로 이루어진다.

- **시그널**은, **프로세스 간 연락을 주고받기 위한 장치**로 Linux 커널에 내장되어 있다.

rm 명령으로 컨테이너들을 삭제한다.

> #### Linux의 시그널
> 
> Linux에서 프로그램이 실행될 때, 프로그램의 파일을 읽어 메모리상에 배치되고 **프로세스**화 된다.
> 
> 해당 프로세스에 대해 명령을 송신할 수 있는데, 이 명령을 시그널이라고 한다.
> 
> 주요 Linux 시그널로는,
> 
> - SIGHUP: 프로그램 재시작
> 
> - SIGINT: 키보드로 인터럽트. Ctrl+C로 보낼 수 있다.
> 
> - SIGQUIT: 키보드에 의한 중지.
> 
> - SIGTERM: 프로세스 정상 종료
> 
> - SIGKILL: 프로세스 강제 종료
> 
> - SIGSTOP: 프로세스 일시 정지

### 여러 리소스의 일괄 삭제 (down)

`docker-compose down [옵션]`

up으로 생성한 컨테이너나 Docker 이미지를 모아서 삭제할 때 사용한다.

실행 중인 컨테이너를 정지시키고, 이미지, 네트워크, 데이터 볼륨을 일괄 삭제한다.
