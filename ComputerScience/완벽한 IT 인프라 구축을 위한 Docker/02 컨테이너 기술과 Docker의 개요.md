# Chapter 02: 컨테이너 기술과 Docker의 개요

---

Docker는 기본적으로 **컨테이너** 기술을 사용해 어플리케이션의 **실행 환경**을 구축 및 운용하는 플랫폼이다.

어플리케이션의 실행에 필요한 것을 모아 **이미지**로 관리함으로써 어플리케이션의 **이식성**을 높일 수 있다.

---

## 컨테이너 기술의 개요

### 컨테이너

컨테이너는, 호스트 OS 상에 **논리적인 구획**(컨테이너)을 만들고, 어플리케이션 작동을 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아 **마치 별도의 서버인 것처럼 사용할 수 있게** 만든 것이다.

호스트 OS의 **리소스**를 **논리적으로 분리**시키고 여러 개의 컨테이너가 공유하여 사용한다.

- 하드웨어와 OS 위에 **컨테이너 관리용 소프트웨어**를 두고,

- 그 위에 존재하는 컨테이너들은 **미들웨어**와 **어플리케이션**을 담고 있는 구조.

- 기본적으로 **가상머신**에 비해 오버헤드가 적기 때문에 가볍고 고속으로 작동한다는 특징이 있다.

일반적인 물리 서버 상 호스트 OS에 설치된 여러 어플리케이션들은, 동일한 시스템 리소스를 사용한다.

- 데이터를 저장하는 디렉토리, 동일한 서버 IP, 등

- 그런데 각 어플리케이션이 사용하는 미들웨어나 라이브러리의 버전은 다를 수 있고, 이것이 다른 어플리케이션에게 영향을 주지 않도록 주의를 기울일 필요가 있다.

이에 반해 컨테이너 기술이 적용되면 OS, 디렉토리, IP 주소 가튼 **시스템 자원**을 **마치 각 어플리케이션이 점유하고 있는 것처럼** 보이게 할 수 있다.

어플리케이션 실행에 필요한 모듈을 컨테이너로 모을 수 있기 때문에, 아예 여러 개의 **컨테이너를 조합**하여 하나의 어플리케이션으로 구축하는 **마이크로서비스형 어플리케이션**과 친화성이 높다.

> ### 서버 가상화 기술의 이모저모
> 
> 클라이언트 PC에서 사용되는 서버 가상화 기술은 크게 두 가지로 나뉜다.
> 
> #### 호스트형 서버 가상화
> 
> 하드웨어 상에 베이스가 되는 **호스트 OS**를 설치하고, 그 위에 **가상화 소프트웨어**를 설치한 뒤, 그 위에 **게스트 OS**를 작동시키는 기술이다.
> 
> 가상화 소프트웨어 설치만으로 비교적 간단한 가상 환경 구축이 가능하기 때문에, 개발 환경 구축에 주로 사용된다.
> 
> 컨테이너와 달리 호스트 OS 상에서 다른 OS를 또 움직여야 하므로, **오버헤드**가 크다.
> 
> #### 하이퍼바이저형 서버 가상화
> 
> 하드웨어 상에 **가상화를 전문으로  수행하는 소프트웨어**인 **하이퍼바이저**를 배치하고 그 위에 가상 환경(**게스트 OS**와 미들웨어, 어플리케이션)들을 두는 방식.
> 
> 호스트 OS 없이 하드웨어를 직접 제어하기 때문에 자원이 효율적으로 사용된다.
> 
> - 주로 클라우드의 가상 머신에서 사용되는 방법이다.
> 
> 대신 **가상 환경마다 별도의 OS**가 작동하기 때문에 가상 환경 **시작** 시 걸리는 오버헤드가 크다.
> 
> 하이퍼바이저형은 펌웨어로 구축하는 경우가 많다.
> 
> #### 컨테이너 기술과 가상화 기술
> 
> 서로 매우 비슷한데, 목적이 다르다.
> 
> - 컨테이너 기술은, 어플리케이션의 **실행 환경**을 모음으로써 **이식성**을 높이고 **확장성이 좋은 환경**에서 작동하는 것을 지향한다.
> 
> - 가상화 기술은, 대부분 **서로 다른 환경**을 어떻게 **효율적으로 에뮬레이트**할 지를 지향하고 있다.

### 컨테이너 역사

#### FreeBSD Jail

오픈소스 Unix인 FreeBSD의 기술이다.

FreeBSD 시스템을 Jail이라 부르는 **독립된 작은 구획**에 가둬넣어 **시스템을 분할**하는 기술이다.

##### 프로세스의 구획화

프로세스는 똑같은 Jail 내에서 작동하는 프로세스에만 액세스가 가능하도록, 프로세스를 분리한다.

##### 네트워크의 구획화

Jail은 각각 IP 주소가 할당되어 있고, 여러 개의 주소를 할당받을 수도 있다.

Jail 외부에는 네트워크를 경유해야만 엑세스가 가능하다.

- VIMAGE라는, **네트워크 스택을 가상화**하는 기술을 사용해 구현하고 있다.

##### 파일 시스템의 구획화

Jail마다 파일 시스템을 구획화하여 조작할 수 있는 명령이나 파일 등을 제한한다.

Jail 내에서 관리자 권한을 받더라도, 그 권한이 Jail 안으로 제한되기 때문에 **시스템 종료** 같이 시스템 전체를 조작하는 권한은 가질 수 없다.

- 일반 사용자이면서도 관리자 권한이 부여될 수 있다는 점에서 장점이 있다.

#### Solaris Containers

Oracle의 상용 Unix인 Solaris에서 사용하는 컨테이너 기술.

다음 두 가지 기능으로 구성되어 있다.

##### Solaris Zone 기능

하나의 OS 공간을 **가상적으로 분할**하여 **여러 OS가 작동하고 있는 것처럼 보여주는** **소프트웨어 파티셔닝** 기능.

Solaris 환경을 독립된 여러 개의 존으로 구획하고, 이렇게 구획된 **가상 존**을 **비 글로벌 존**(**non-global zone**)이라고 한다.

- 비 글로벌 존에서 미들웨어와 함께 업무 어플리케이션을 작동시킬 수 있고,

- 존끼리는 완전히 격리되어 있어, 다른 존에 있는 프로세스에 액세스할 수 없다.

- 이러한 구조는 Docker와 아주 비슷하다.

한 대의 물리 서버 안에 최대 8192개의 가상 Solaris 환경 구축이 가능하다.

##### Solaris 리소스 매니저 기능

비 글로벌 존에서 CPU나 메모리 같은 **하드웨어 리소스를 배분**하는 관리 기능.

중요도가 높은 업무 시스템에 우선적으로 리소스를 할당할 수 있다.

#### Linux Containers (LXC)

Linux 상에서 사용하는 컨테이너 환경을 LXC라고 한다.

LXC는 Linux 커널의 컨테이너 기능을 이용하기 위한 툴과 API를 제공한다.

- 컨테이너는 namespace와 cgroups라는 **리소스 관리 장치**를 사용해 분리된 환경으로 만들어지고,

- 데이터 영역에서는 특정 디렉토리를 **루트 디렉토리로 변경**하는 chroot를 사용해 분리 환경을 만든다.

Docker 과거 버전은 내부적으로 LXC를 사용했었다.

---

## Docker의 개요

Docker는, 어플리케이션 실행에 **필요한 환경**을 **하나의 이미지로 모아**두고, 그 이미지를 사용해 **다양한 환경**에서 어플리케이션 **실행 환경을 구축 및 운용**하기 위한 오픈소스 플랫폼이다.

내부적으로 **컨테이너 기술**을 사용하는 것이 중요하다.

### 프로그래머에게 Docker란?

어플리케이션을 가동시키기 위해서는, 아래 요소들이 존재해야 한다.

- 어플리케이션 실행 모듈 (프로그램 본체)

- 미들웨어, 라이브러리

- OS/네트워크 등 인프라 환경 설정

폭포형 개발은 개발 - 테스트 - 스테이징 - 제품 환경을 순차적으로 따라가며 진행되는데, 이러한 환경 변화 시 제품이 정상적으로 작동하지 않는 경우가 매우 잦다.

심지어 어플리케이션이 아닌 그 뒤 환경이 원인이기 때문에, 대응도 힘들다. 

Docker에서는 이러한 **인프라 환경을 컨테이너로 관리**한다.

- 어플리케이션 실행에 필요한 모든 파일과 디렉토리들을 컨테이너로서 모아버리는 것.

- 그 컨테이너의 바탕이 되는 Docker image를 Docker Hub 같은 리포지토리에 공유한다.

즉, Docker를 이용함으로써,

- 프로그래머는 Docker를 사용해 어플리케이션 실행에 필요한 **모든 것**이 포함된 Docker image를 작성하고 Git repository에 Dockerfile과 함께 올린다.

- Dockerfile에 근거해 **빌드**가 일어나고(CI), Docker Hub 같은 레지스트리에 이미지가 업로드된다.

- 개발, 테스트, 스테이징, 제품 환경 모두에서 Linux 위에 Docker를 설치한 뒤, 다운로드 된 이미지를 바탕으로 컨테이너를 가동시킨다.
  
  - 결과적으로 어플리케이션의 인프라 환경을 통일시킬 수 있다.

이는 어플리케이션 개발부터 테스트 및 배포까지의 전개가 모두 어플리케이션 엔지니어 수준으로 내려온 효과를 내기도 해서, **지속적 딜리버리**가 가능하고 변화에 강한 시스템을 구축할 수 있다.

> #### 어플리케이션의 이식성(portability)
> 
> 한 번 만들면 어디에서든 움직이는 소프트웨어의 특성을 이식성이라 한다.
> 
> Docker 컨테이너의 바탕이 되는 이미지만 있으면, 어플리케이션을 어디에서든 동일한 환경에서 가동시킬 수 있고, 이 때문에 클라우드 시스템과 친화력도 좋다.
> 
> - 클라우드의 IaaS 서비스는 사용량에 따라 요금이 책정되는 편이고 업체 간 경쟁도 치열한데, 예산에 따라 클라우드를 바꾸더라도 어플리케이션 수정이 최소화되는 것.
> 
> - 시스템 개발에서 어플리케이션 실행 환경에 제약이 많으면, 특정 업체 의존이 강해지고 개발 속도가 떨어져 최종적으로 고사할 가능성이 높다.

---

## Docker의 기능

### Docker 이미지를 만드는 기능 (Build)

Docker 이미지는 어플리케이션 실행에 필요한 프로그램 본체, 라이브러리, 미들웨어, OS, 네트워커 설정이 하나로 모여있는 것으로 컨테이너의 바탕이 된다.

기본적으로 이미지 하나에 하나의 어플리케이션을 넣고, 여러 컨테이너를 조합해 서비스를 구축하게 된다.

- Docker 이미지는 결국 파일들이 저장된 디렉토리이고, 명령어를 사용하면 tar 파일 출력도 가능하다.

- 이미지는 명령어를 사용해 수동으로 만들 수도 있고 Dockerfile이라는 설정 파일을 통해 자동으로 만들 수도 있는데,
  
  - **코드에 의한 인프라 구성 관리**라는 **CII/CD** 관점에서 생각하면 후자가 바람직하다.

- 이미지는 겹쳐서 사용할 수 있다. 구성에 변경이 있는 부분은 이미지 **레이어**로 관리하게 된다.
  
  - 이미지를 무작정 크게 만드는 것보다, 가능한 한 효율이 좋게 만들 필요도 있는 것.

### Docker 이미지를 공유하는 기능 (Ship)

이미지는 Docker 레지스트리에서 공유할 수 있다.

Docker의 공식 레지스트리인 Docker Hub에서는 Ubuntu 같은 Linux 배포판의 기본 기능을 제공하는 베이스 이미지를 배포 중인데, 여기에 미들웨어, 라이브러리, 어플리케이션 등을 **겹쳐서** 독자적인 Docker 이미지를 만들 수 있다.

- CentOS, MongoDB, Node.jks, MySQL, Nginx 등 웬만한 기본 기능은 다 제공 중이다.

- 개인 작성 이미지도 public하게 공개가 가능하다.

명령어 사용을 통해, Hub에 로그인하여 레지스트리에 있는 이미지를 검색 및 업로드, 다운로드 할 수 있다.

**Automated Build**라 하여 Github 상에서 Dockerfile을 관리하고, Docker 이미지를 자동으로 생성해 Docker Hub에 업로드하는 것도 가능하다.

> #### Docker 이미지의 변조 방지 및 취약성 검사 기능
> 
> Docker Container Trust는 이미지의 제공자를 검증하는 기능이다.
> 
> - 이미지 제공자는 레지스트리에 이미지를 송신하기 전 로컬에서 비밀키를 사용해 이미지에 서명을 하고,
> 
> - 이후 이미지를 이용할 때 제공자의 공개키를 사용, 실행하려는 이미지가 제공자가 작성한 것이 맞는지 확인한다.
> 
> - 만약 변조된 이미지인 경우 미지리르 무효로 하게된다.
> 
> Docker Security Scanning은 Docker 이미지를 검사하여 이미 알려진 보안상 취약점이 없는지 확인하는 기능이다.

### Docker 컨테이너를 작동시키는 기능 (Run)

Docker 이미지만 있으면, Docker가 설치된 그 어떤 환경에서도 컨테이너를 빌드하여 어플리케이션을 작동시킬 수 있다.

- 하나의 이미지로 여러 개의 컨테이너를 기동시킬 수 있고, 컨테이너 기동, 정지, 파기 모두 Docker의 명령어를 사용해 조작할 수 있다.

- OS부터 실행시켜야 하는 다른 가상화 기술과 달리 Docker는 이미 움직이고 있는 OS 상에서 프로세스를 실행시키는 수준의 속도로 빠르게 서버 기능 실행이 가능하다.

Docker는 **하나의 Linux 커널**을 여러 컨테이너에서 공유하고 있고, 각 컨테이너 안에서 작동하는 프로세스를 **그룹**으로 관리한다.

- 그룹마다 각각 파일 시스템, 호스트명, 네트워크를 할당하고, 컨테이너 간에는 완전한 격리가 이루어진다.

- 이를 위해 Linux 커널 기능인 namespace, cgroups 등이 동원되고 있다.

제품 환경에서는 시스템 트래픽 증감이나 가용성, 신뢰도를 위해 여러 호스트 머신으로 구성된 **분산 환경**을 구축하는 것이 일반적이다.

- 이 때 컨테이너 관리는 **오케스트레이션 툴**을 이용하는 것이 일반적이다.

> #### 시스템 운용 설계의 어려움
> 
> 시스템 운용은 해당 시스템의 요건, 기술 요소뿐만 아니라 사회적 책무, 유지보수 비용,운용 멤버의 체제, 기업 풍토 등에 많은 영향을 받는다.
> 
> - 단순 기술적 요소로만 판단하면 사용자나 시스템 관리자, 어플리케이션 개발자가 혼란스러워지고 시스템 장애, 보안 사고 유발의 가능성이 생긴다.
> 
> - 그래서 수작업을 최소화하고 가능한 한 자동화하는 것이 운용의 트렌드.

### Docker 에디션

#### Docker Community Edition (CE)

무료 에디션으로, 로컬 환경이나 상용화가 불필요한 환경에서 어플리케이션을 구축하기에 적합하다.

Docker 컨테이너에서 작동하는 어플리케이션 구축, 테스트, 실행 툴과 멀티호스트 환경 대응 툴들이 제공된다.

#### Docker Enterprise Edition (EE)

상용 이용에 적합한 에디션으로, Basic, Standard, Advanced 3 종류가 있다.

- Based는 Docker 자체적으로 인증이 완료된 컨테이너와 플러그인을 제공하고,

- Standard는 LDAP나 Active Directory와 통합 가능한 Docker Datacenter를 이용할 수 있고,

- Advanced는 보안 기능을 제공한다.

#### 지원 플랫폼

기본적으로 Docker CE는 제품 환경에서 사용하는 서버 OS용, 퍼블릭 클라우드나 개발 환경에서 사용하는 클라이언트 OS용이 있다.

IoT 디바이스 같은 ARM 아키텍쳐에서 작동하는 디바이스는 Docker Community Edition (ARM) 이용이 가능하다.

> #### Moby Project
> 
> 컨테이너 기술을 베이스로 한 **컴포넌트**를 조합해 시스템 구축이 가능하다는 것을 지향하는 오픈소스 프로젝트.
> 
> 다양한 컴포넌트를 제공하며, 컨테이너 런타임, 오케스트레이션, 네트워킹 보안, 빌드 툴, 프레임워크 등을 조합해 다양한 플랫폼 위에서 실행 가능한 컨테이너 환경을 구축할 수 있다.
> 
> 주요 컴포넌트로는,
> 
> - containerd: 컨테이너 런타임
> 
> - LinuxKit: containerd를 작동시키기 위한 Linux 환경
> 
> - InfraKit: 인프라르 추상화하여 자동화하는 컴포넌트.
> 
> Docker 또한 Moby Project에서 개발 중인 툴이다.

### Docker 컴포넌트

Docker 또한 몇 개의 컴포넌트로 구성되는데, 핵심이 되는 Docker Engine을 중심으로 컴포넌트를 조합해 어플리케이션 실행 환경을 구축한다.

#### Docker Engine (핵심 기능)

이미지 생성, 컨테이너 기동을 위한 Docker의 핵심 기능이다.

명령어 실행, Dockerfile 해석 등도 담당한다.

#### Docker Registry (이미지 공개 및 공유)

이미지를 공개 및 공유하기 위한 레지스트리 기능이다.

공식 레지스트리 서비스인 Docker Hub도 Docker Registry를 사용 중이다.

#### Docker Compose (컨테이너 일원 관리)

여러 컨테이너 구성 정보를 **코드로 정의**하고, 명령을 실행함으로써, 어플리케이션 실행 환경을 구성하는 컨테이너들을 일원 관리하기 위한 툴

#### Docker Machine (Docker 실행 환경 구축)

로컬 호스트용인 VirtualBox를 비롯해 AWS EC2나 MS Azure 등 클라우드 환경에서 Docker 실행 환경을 자동 생성하기 위한 툴

#### Docker Swarm (클러스터 관리)

여러 Docker 호스트를 **클러스터화**하기 위한 툴.

클러스터 관리 및 API 제공 역할은 Manager가, 컨테이너 실행 역할은 Node가 담당하고, Kubernetes도 이용할 수 있다.

> #### Docker를 둘러싼 업체 / OSS의 동향
> 
> Docker는 AWS 같은 클라우드 업체를 비롯해 IBM, MS 같은 대형 업체, 널리 이용 중인 오픈소스 등에서 지원하고 있다.
> 
> - 다양한 조직이나 시스템과 연계하여 사용 가능한, 상호운용성을 가진 소프트웨어이기 때문
> 
> 주요 퍼블릭 클라우드 업체는 컨테이너 실행 환경의 **풀 매니지드 서비스**를 제공한다.
> 
> - AWS는 AWS EC2 Container Service로 Docker 실행 환경 매니지드 서비스를,
> 
> - MS에서는 Azure Container Service로 오케스트레이션 툴 선택 기능을,
> 
> - 구글은 Kubernetes를 수비게 이용할 수 있는 Google Kubernetes Engine을 제공한다.
> 
> Dockersms 대부분의 오픈소스와 연계도 간단한데, 
> 
> - CI 툴인 Jenkins와 연계해 테스트를 자동화할 수 있고, 
> 
> - Github와 연계해 Dockerfile은 Hub와 연계하여 자동 빌드 및 CD 가 가능하다.

---

## Docker의 작동 구조

Docker는 Linux 커널 기술을 베이스로 하고 있고, 커널은 하드웨어나 네트워크 같은 하위 레이어 기술과 밀접한 관련이 있다.

### 컨테이너를 구획화하는 장치 (namespace)

Docker에서 독립된 환경을 만들기 위해 **컨테이너**를 구획화하는 기술은 Linux 커널의 **namespace**라는 기능을 사용한다.

namespace는 한 덩어리의 데이터에 **이름을 붙여 분할**함으로써 충돌 가능성을 줄이고, 쉽게 참조할 수 있게 하는 개념.

- 이름에 연결된 실체는 그 이름이 어떤 namespace에 속해 있는지 **고유하게** 정해진다.

- 커널의 namespace 기능으로, Linux의 오브젝트에 이름을 붙임으로써 다음 **6개의 독립된 환경**을 구축할 수 있다.

Docker는 namespace 장치들을 이용해 호스트 상에서 컨테이너를 가상적으로 격리시키게 된다.

#### PID namespace

**PID**는 Linux에서 각 프로세스에 할당된 고유 ID이다.

PID namespace는 PID와 프로세스를 격리시켜, namespace가 다른 프로세스끼리는 서로 엑세스할 수 없다.

#### Network namespace

네트워크 디바이스, IP 주소, 포트 번호, 라우팅 테이블, 필터링 테이블 같은 **네트워크 리소스**를 격리된 namespace마다 독립적으로 가질 수 있다.

- 호스트 OS 상에서 사용 중인 포트가 있어도 컨테이너 안에서 동일한 포트를 사용 가능해진다.

#### UID namespace

namespace 별로 UID(사용자 ID)와 GID(그룹 ID)를 독립적으로 가질 수 있다.

더 나아가 namespace 안과 호스트 OS 상의 UID/GID를 서로 연결시킬 수도 있다.

- namespace 안에서는 UID/GID가 0인 root 사용자를 호스트 OS에서는 일반 사용자로 취급하는 식.

namespace 안의 관리자 계정이여도 호스트 OS에서는 관리 권한이 **전혀** 존재하지 않는다는 것을 의미하여, **보안**에 뛰어난 환경을 구축할 수 있다.

#### MOUNT namespace

Linux에서 파일 시스템 사용을 위해서는 **마운트**가 필요하다.

- 마운트는, 컴퓨터에 연결된 기기나 기억장치를 OS에 인식시켜 이용 가능한 상태로 만드는 것.

MOUNT namespace는 namespace 안에서 마운트 조작을 하면 격리된 파일 시스템 트리를 만들어, 호스트 OS나 다른 namespace에서 해당 파일 시스템에 엑세스할 수 없게 되는 것.

#### UTS namespace

namespace 별로 호스트명이나 도메인명을 독자적으로 가질 수 있다.

#### IPC namespace

**프로세스 간 통신**(**IPC**) 오브젝트를 namespace 별로 독립적으로 가질 수 있다.

IPC는, System V 프로세스 간 통신 오브젝트라 하는 **공유 메모리**나 **세마포어/메시지 큐**를 말한다.

- 세마포어는 프로세스가 요구하는 자원 관리에 이용되는 배타제어 장치이고

- 메시지 큐는 여러 프로세스 간 **비동기 통신**을 할 때 사용되는 큐잉 장치이다.

### 릴리스 관리 장치 (cgroups)

Docker는 물리 머신 상 자원을 여러 컨테이너가 공유하여 작동하는데, 이 때 커널 기능인 **cgroups** 기능을 사용해 **자원의 할당** 등을 관리한다.

Linux는 프로그램을 프로세스로 실행하고, 프로세스는 **스레드**의 모음으로 움직인다.

cgroups는 프로세스와 스레드를 **그룹화**하여 관리하기 위한 기능이다.

- 호스트 OS의 CPU나 메모리에 대해 그룹별 **제한**을 두는 식.

cgroups로 컨테이너 안 프로세스에 대해 자원을 제한하여, 어떤 컨테이너가 호스트의 자원을 모두 사용해버려 **다른 컨테이너에 영향을 주는** 일을 방지할 수 있다.

> #### cgroups의 주요 서브 시스템
> 
> cgroups로 관리할 수 있는 주요한 일들.
> 
> ##### cpu
> 
> CPU 사용량 제한
> 
> ##### cpuacct
> 
> CPU 사용량 통계 정보를 제공
> 
> ##### cpuset
> 
> CPU나 메모리 배치를 제어
> 
> ##### memory
> 
> 메모리나 스왑 사용량을 제한
> 
> ##### devices
> 
> 디바이스에 대한 엑세스 허가 및 거부
> 
> ##### freezer
> 
> 그룹에 속한 프로세스 정지 및 재개
> 
> ##### jent_cls
> 
> 네트워크 제어 태그를 부가
> 
> ##### blkio
> 
> 블록 디바이스 입출력량 제어

cgroups는 **계층 구조**를 사용해, 프로세스를 그룹화하여 관리할 수 있다.

- 부모자식 관계가 존재하고, 자식은 부모의 제한을 물려받는다.
  
  - 사용자 앱에는 애초부터 CPU를 10%만 걸어놔서, 그 하부 프로그램이 어떻게 작동되든 서버 같은 데몬 프로세스가 지장받지 못하게 하는 식.

### 네트워크 구성 (가상 브리지 / 가상 NIC)

Linux에 Docker 설치 시, 호스트 서버의 물리 NIC와 컨테이너는 `docker0`이라는 **가상 브리지 네트워크**로 연결된다.

- Docker 컨테이너가 실행되면, 컨테이너에 `172.17.0.0/16`이라는 서브넷 마스크를 가진 **프라이빗** IP 주소가 `eth0`으로 자동 할당된다.

- 이러한 가상 NIC는, OSI 레이어 2인 **가상 네트워크 인터페이스**로, 페어를 이루는 NIC와 브리지를 통한 **터널링 통신**을 한다.

Docker 컨테이너가 외부 네트워크와 통신을 할 때는, **가상 브리지 docker0**과 호스트 OS의 **물리 NIC**에서 패킷을 전송하는 장치가 필요하고, Docker는 **NAPT** 기능을 사용하게 된다.

- NAPT(Network Address Port Translation)는, 하나의 IP 주소를 여러 컴퓨터가 공유하는 기술로 IP주소와 포트 번호를 변환하는 기능이다. **IP 마스커레이드**라고도 한다.
  
  - 프라이빗 IP와 글로벌 IP 주소를 투과적으로 상호 변환하는 기술로, TCP/IP의 포트 번호까지 동적으로 변환시켜 여러 머신을 동시에 연결하는 게 가능하다.
  
  - Docker에서는 NAPT를 위해 Linux의 iptables를 사용한다.

호스트 OS가 포트 8080을 사용하고, 그 내부에서 포트 80을 사용하는 컨테이너가 있을 때 외부에서 해당 컨테이너에 접근하는 경우를 떠올려 보면

- 외부에서 호스트 OS의 8080 포트에 엑세스하면 **물리 NIC인 eth0**에 엑세스

- IP 마스커레이드(NAPT)에 의해 컨테이너의 포트인 80으로 변환

- 가상 브리지인 docker0을 통해 컨테이너의 가상 NIC로 연결
  
  - 컨테이너 기준에서 가상 NIC는 호스트의 NIC인 eth0으로 **보임**

- 가상 NIC를 통해 컨테이너의 eht0에 엑세스.

> #### NAT와 IP 마스커레이드의 차이
> 
> **프라이빗 IP 주소와 글로벌 IP 주소를 변환**하여, 프라이빗 IP 주소가 할당된 컴퓨터에 대해 인터넷 엑세스를 가능하게 하는 기술로 NAT와 NAPT가 있다.
> 
> ##### NAT (Network Address Translation)
> 
> 프라이빗 IP 주소가 할당된 클라이언트가 인터넷 서버에 엑세스할 때, NAT 라우터는 프라이빗 주소를 NAT가 가진 글로벌 IP 주소로 변환하여 요청을 송신한다.
> 
> 응답 또한 NAT 라우터가 송신처를 클라이언트의 프라이빗 IP 주소로 변환하여 송신한다.
> 
> - 이 때 글로벌 IP 주소와 프라이빗 IP 주소 간 변환은 1:1 관계를 가지기 때문에, **동시에 여러 클라이언트가 엑세스할 수 없다**.
> 
> ##### NAPT (Network Address Port Translation)
> 
> 프라이빗 IP 주소와 함께 **포트 번호까지** 같이 변환하는 기술.
> 
> 글로벌 IP 주소로 변환하는 시점에서 프라이빗 IP 주소별로 **서로 다른 포트** 번호로 변환한다.
> 
> - 하나의 글로벌 IP 주소와 **여러 개의 프라이빗 IP 주소를 변환**할 수 있다.
> 
> NAPT는 이러한 기술의 이름이고, Linux에서 NAPT를 구축하는 것을 **IP 마스커레이드**라고 부른다.
> 
> - 많은 가면을 쓴 IP 패킷이 **포트 번호의 가면을 붙여** 변환되는 모습을 나타낸 것.

### Docker 이미지의 데이터 관리 장치

**데이터 복사** 시 빈 영역을 확보하고 거기에 복사를 하는데, 복사된 데이터에 변경이 없다면 굳이 새로 용량을 할당하는 것은 다소 쓸데없다.

- 그래서 복사를 요구할 시 바로 복사하는 것이 아니라 **원래의 데이터를 그대로 참조**시켜, 

- 어느 한 쪽에 수정이 **가해진 시점에 비로소 새로운 빈 영역을 확보하고 데이터를 복사**하는 방식이 있는데, 이를 **Copy on Write**라고 한다.

Docker에서는 이 방식으로 **컨테이너의 이미지를 관리**한다.

Docker 이미지를 관리하는 스토리지 디바이스로는 다음의 것들이 있다.

#### AUFS

다른 파일 시스템의 파일이나 디렉토리를 **투과적으로 겹쳐서** 하나의 파일 트리를 구성할 수 있는 파일 시스템.

현재 표준 Linux 커널의 일부는 아니다.

#### Btrfs

Linux용 Copy on Write 파일 시스템으로, Oracle에서 만들었다.

과거로 돌아갈 수 있는 롤백 기능, 어떤 시점의 상태를 저장하는 스냅샷 기능이 있다.

#### Device Mapper

Linux의 블록 디바이스 드라이버와 그를 지원하는 라이브러리들이다.

파일 시스템의 블록 I/O와 디바이스 간 매핑 관계를 관리한다.

thin-provisioning 기능과 snapshot 기능을 가지고 있다.

- RedHat 계열 OS나 Ubuntu에서 Docker를 이용할 때 사용된다.

#### OverlayFS

파일 시슽메에 다른 파일 시스템을 **투과적으로 머징**하는 장치이다.

읽기 전용 파일 시스템에 읽어들이기 가능한 파일 시스템을 **겹침**으로써, 읽기 전용 파일 시스템에 대해 변경을 가할 수 있다.

#### ZFS

볼륨 관리, 스냅샷, 체크섬 처리, 리플리케이션 등을 지원한다.


