# MSA 개론

---

## MSA 정의

### MSA란

각 핵심 기능 또는 서비스가 **독립적 빌드, 독립적 배포**되는 애플리케이션을 빌드하는 **아키텍처**

### MSA 특징

- **작고, 독립적, 느슨한 결합**을 원칙으로, 소규모 개발팀이 작성하고 유지관리 가능한 코드베이스

- 서비스의 **독립적 배포** : 팀 전체 빌드 없이 단위 서비스만 업데이트 가능해야 함

- 서비스가 **데이터의 상태 또는 외부 상태**를 가져야 함.
  
  - 기존 Monolithic 에서는 데이터 레이어가 **데이터 지속성**을 핸들링했다.
  
  - MSA에서는 단위 서비스가 데이터 지속성을 관리해야 함.
  
  - 2개 이상의 단위 서비스가 참여하는 경우 단일 트랜잭션으로 관리될 수 없기 때문에, **SAGA** 패턴을 활용

- 서비스 간에는 잘 정의된 API를 통해 통신
  
  - REST API 형태로 많이 사용

- 다양한 프로그래밍을 지원

### MSA 등장배경

Monolithic 아키텍처의 한계를 극복하고자 등장함

- 부분 장애가 전체 서비스 장애로 확대

- 전체 시스템 구조 파악 어려움

- 서비스 수정 시의 영향도 파악 어려움

- 테스트, 배포가 어렵고 빌드 시간이 과다

- 특정 서비스만 스케일 아웃 처리하는 것이 어려움

---

## 아키텍처 : MSA

### 모놀리식 아키텍처 대비 장점

- 신규 서비스 추가 시 상대적으로 적은 시간 소요
  
  - 기존 애플리케이션과 독립적으로 구성

- 마이크로서비스 단위 **장애 격리**

- Scale out을 통한 시스템 폭주 대응

- 빠른 프로그램 배포

- 신기술 적용에 유연

---

## MSA 심화

### SAGA 패턴

MSA는 작고 독립적인 서비스 형태로 동작하도록 구현한다.

그러나 여러 서비스가 연동하지만 마치 **하나의 트랜잭션처럼** 관리하고자 하는 경우, 기존 모놀리식 아키텍처처럼 간단할 수가 없다.

별도의 **보상거래 호출**을 통해, 트랜잭션을 관리하는 패턴을 적용해야 함.

### SAGA 패턴 : Choreography

#### 상세

- 각각의 MSA 서비스는 **로컬트랜잭션**으로 끝나고, 순차적으로 다음 서비스를 호출한다.

- 호출된 서비스에서 오류가 발생할 경우, 해당 서비스의 로컬트랜잭션은 **롤백**한다.

- 그리고 이전 서비스로 이벤트/메시지를 보내서, **보상트랜잭션**을 연속적으로 수행시킨다.

#### 장단점

- 구현 자체는 간단한데,

- 트랜잭션을 추적관리하는 주체가 없어서, 트랜잭션이 중간에 유실될 우려가 있다.

### SAGA 패턴 : Orchestration

#### 상세

각각의 서비스에서 보상트랜잭션을 각개 대응하는 부분을 개선하기 위해, 

복합 서비스를 묶어서 호출하는 별도의 **관리 서비스**를 만들어, 서비스 호출 및 보상거래 호출을 구현하는 방안.

#### 장단점

- 관리형 서비스를 통해 실제 MSA에 대한 트랜잭션 집합 관리하기 때문에, 웬만해서는 단위 트랜잭션이 유실되지 않는다.

- 대신 오케스트레이션 서비스를 별도로 운영해야 하는 단점




