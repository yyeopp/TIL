# Chapter 02: 운영체제 개요

---

## 운영체제의 정의

운영체제(**operating system**)란, 컴퓨터 하드웨어 바로 윗단에 설치되는 **소프트웨어**를 말한다.

사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 **소프트웨어 계층**이다.

- 하드웨어는 운영체제와 한 몸이 되어야만 사용자에게 쓰일 수 있는 진정한 컴퓨터 시스템이 된다.

- 부팅 시에 운영체제가 자동으로 실행된다.

소프트웨어가 실행되기 위해서는 **메모리에** 해당 프로그램이 올라가 있어야 하는데, 운영체제 또한 하나의 프로그램이므로 메모리에 올라가야 한다.

하지만 운영체제는 규모가 커서 모두 메모리에 올라간다면 메모리 공간 활용에 악재로 작용한다.

- 따라서 운영체제 중 항상 필요한 부분만을, 부팅 시 메모리에 올려놓고 그렇지 않은 부분은 사용할 때 메모리에 올리게 된다.

- 이 중 메모리에 상주하는 운영체제 부분을 **커널**이라고 부른다. 좁은 의미의 운영체제가 되기 도한다.

- 즉, **커널**은 운영체제 종 핵심적인 부분이다.

넓은 의미의 운영체제로는 시스템을 위한 유틸리티 프로그램을 광범위하게 포함한다.

- 파일을 복사하는 것 또한 프로그램이고 운영체제와 별도로 존재한다.

- 시스템을 위한 유틸리티로써 운영체제와 함께 설치되기 때문에, 넓은 의미로는 포함시킬 수 있는 것이다.

---

## 운영체제의 기능

사용자 쪽에서는, 사용자에게 편리한 인터페이스를 제공하는 역할을 한다.

즉, 운영체제는 **추상화된 컴퓨터**를 사용자에게 제공한다고도 말할 수 있다.

- 사용자는 파일이 디스크에 어떻게 저장되는 지 전혀 알지 못하지만, 운영체제가 제공하는 인터페이스를 통해 편리하게 파일을 저장하고 읽을 수 있다.

하드웨어 쪽에서는, 사용자가 직접 다루기 힘든 각종 하드웨어를 대신 관리하여 컴퓨터 시스템 내 자원을 효율적으로 관리하는 역할을 한다.

- 이 점에서 운영체제를 **자원관리자**라고 부르기도 한다.

- 전체 성능 향상을 목적으로 CPU, 메모리, 하드디스크, 소프트웨어 자원 등을 여러 프로그램에 배분한다. 이 때 효율성과 형평성을 동시에 고려해야 하는 책임을 진다.

이 밖에도 사용자와 운영체제 자신을 **보호**하는 역할을 담당하게 된다. (보안)

---

## 운영체제의 분류

### 동시 작업 지원 여부

**동시 작업 지원 여부**에 따라 단일작업용, 다중작업용 운영체제로 나눌 수 있다.

단일작업용 운영체제는 한 번에 하나의 프로그램만 실행시킬 수 있다. 

- DOS 같이 초창기 운영체제의 대부분을 차지한다.
  
  - 하나의 명령어가 실행되는 동안 다른 명령어는 입력 자체가 불가능했다.

최근 대부분의 운영체제는 다중작업을 지원한다. **시분할 시스템**이 적용된 결과다.

- 여러 프로그램이 CPU와 메모리를 공유할 때, 하나의 CPU는 매 순간 하나의 프로그램만 실행하지만 매우 짧은 시간을 쪼개서 여러 프로그램을 번갈아 실행하고 있다.

- 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것으로 느낄 수 있다.

- 하나의 컴퓨터에 CPU가 여러 개 설치된 경우인 **다중처리기 시스템**과는 구분해야 한다.
  
  - 서로 다른 CPU에서 여러 프로그램이 동시에 실행될 수 있어 처리가 빨라지고, 운영체제 입장에서는 여러 CPU를 관리하기 위한 더욱 복잡한 메커니즘이 필요하다.

메모리의 경우, 여러 프로그램이 동시에 올라가 있는 것이 가능하다.

- 여러 프로그램을 동시에 메모리에 올려놓고 처리하는 시스템을 **다중 프로그래밍 시스템**이라고 한다.

각 사용자의 관점에서, 다중작업용 운영체제는 프로그램에 대한 키보드 입력 결과를 곧바로 화면에 보여주기 때문에 **대화형 시스템**이라고 불리기도 한다.

즉, 우리가 널리 사용하는 PC는 **다중작업, 시분할, 다중 프로그래밍, 대화형 시스템**이라는 조건들을 모두 충족하는 경우에 해당한다.

### 그 외의 분류

#### 다중 사용자에 대한 동시 지원 여부

여러 사용자가 동시에 접속해 사용할 수 있게 하는 운영체제를 **다중 사용자용 운영체제**라고 한다. 반대는 **단일 사용자용 운영체제**이다.

- 이메일 서버, 웹 서버 등 흔히 **서버**라고 부르는 컴퓨터가 대표적으로 다중 사용자용 운영체제가 적용된 경우다.

#### 작업 처리 방식

**일괄처리 방식**은 요청된 작업을 일정량씩 모아서 한꺼번에 처리하는 방식이다.

- 작업이 충분히 쌓이면 비로소 처리되어 모든 작업이 완전히 종료된 뒤에야 결과가 돌아오므로, **응답시간이 길다**는 단점이 있다.

- 초창기 컴퓨터에 사용된 **펀치 카드** 처리 시스템이 예시이다.

**시분할 방식**은 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식이다. 현대 대부분의 범용 컴퓨터가 사용한다.

- 사용자들은 비교적 짧은 응답시간을 경험할 수 있다.

- 사용자의 요청에 대한 결과가 거의 곧바로 나온다는 점에서 **대화형 시스템**이라 표현되기도 한다.

**실시간 운영체제**는, 정해진 시간 안에 어떠한 일이 **반드시** 처리됨을 **보장**해야 하는 시스템에서 사용된다.

- 원자로, 공장 제어 시스템, 미사일 제어 시스템 등이 있다.

- 시간 제약의 중요성에 따라 경성과 연성 실시간 시스템으로 나뉜다.

---

## 운영체제의 예

### MS 윈도우

마이크로소프트가 기존에 발표한 MS-DOS는 CLI를 적용하여 사용하기에 어려운 측면이 있었다.

초기 윈도우는 **그래픽 인터페이스와 마우스 기능**을 지원한다는 점에서 편리해졌지만, 그 자체로 독립적인 운영체제가 아니라 MS-DOS 위에서 수행된다는 점에서 한계가 컸다.

- DOS를 직접 다루지 않고서는 컴퓨터 시스템을 완전히 제어할 수 없었고, 불안정했다.

윈도우 95부터는, 그 자체가 하나의 온전한 운영체제가 되었다는 점에서 의미가 크다.

MS 윈도우의 또 다른 중요한 특징은, 시스템에 새로운 하드웨어를 장착할 시 운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정된다는 점이다.

- **플러그 앤 플레이**라고 하여, 윈도우 사용자들 간 파일 공유, 프린터 등의 하드웨어 공유가 가능했다.

MS 윈도우에서 안정성이 높고 다중 사용자용 운영체제로 제공되는 윈도우 NT도 있다.

### 유닉스

유닉스 운영체제는 프로그램 개발 환경을 위해 설계된 운영체제로 이식성이 좋고, 커널의 크기가 작으며, 소스 코드가 공개되어 있다.

덕분에 많은 연구가 진행되어 가장 널리 사용되는 운영체제 중 하나가 되었다.

유닉스의 **이식성**은 깔끔한 **모듈 단위**로 작성된 운영체제였기에 가능했다.

- 그 외에도 커널의 크기가 매우 작고, 여러 유틸리티를 지원하여 개발이 편했고, 대부분의 코드가 어셈블리어가 아닌 C 언어로 작성되어 소스 코드 이해도 편했다.

- 결과적으로 다른 기종으로 이식하기가 쉬웠다.

유닉스는 현재까지도 사실상 표준 운영체제로 사용된다. 다양한 종류로 개발되었는데, **리눅스**의 등장은 유닉스가 대형 서버 뿐만 아니라 개인용 컴퓨터에서도 사용 가능하게 된 계기가 되었다.

### 정리

MS 윈도우가 개인용 컴퓨터를 위한 운영체제로서 누구든지 쉽게 사용 가능한 인터페이스와 기능 제공을 강점으로 한다면,

유닉스는 오랜 전통을 지닌 운영체제로서 대형 컴퓨터나 전문적 목적의 컴퓨터에 사용되는 데 강점이 있다.

- 물론 유닉스에서도 GUI를 지원하는 프로그램이 개발되고, 리눅스가 급성장하면서 개인용 컴퓨터에 사용되는 빈도가 늘고 있다.

---

## 운영체제의 자원 관리 기능

운영체제의 핵심 기능은 자원을 효율적으로 관리하는 것.

자원은 하드웨어와 소프트웨어 자원으로 나뉜다.

- 통상적으로 하드웨어 자원은 **CPU, 메모리, 주변장치, 입출력 장치**(주변장치)를 지칭한다.

- CPU가 하나만 달린 싱글코어를 가정할 때, 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리가 필요하다.

- 메모리 역시 한정된 용량이므로 다수의 프로세스들이 나누어 쓸 수 있어야 한다.

- CPU와 메모리는 전원이 꺼지면 처리 중이던 정보를 모두 지워버리기 때문에, 전원이 나가도 기억해야 하는 부분은 입출력 장치의 하나인 보조기억장치가 저장해야 한다. 
  
  - 그러려면 파일 저장 방식, 접근 권한 등에 대한 운영체제의 관리가 필요하다.

- 당연히 키보드, 모니터 같은 입출력 장치도 운영체제의 관리를 요한다.

### CPU 관리방법

CPU 하나에서 한 시점에 프로세스 여러 개를 동시에 수행할 수는 없다.

즉 매 시점마다 어떤 프로세스에 CPU를 할당할 것인지 정해야 하고 이를 **CPU 스케줄링**이라고 한다.

- CPU를 효율적으로 사용하면서도, 프로세스 간의 형평성을 유지하는 것이 스케줄링의 목표다.

#### 선입선출 기법

도착한 프로세스들 중 먼저 온 것을 먼저 처리해주는 방식이다.

CPU 입장에서는 효율적이지만, 전체 시스템 입장에서는 비효율적일 가능성이 크다.

- 단시간의 CPU time으로 충분한 프로세스가 장시간이 소요되는 선행 프로세스에 의해 막혀 있을 수 있기 때문.

#### 라운드 로빈 기법

선입선출 기법의 단점을 보완하고자 고안되었다.

CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 **고정된 시간으로 제한**한다.

프로세스 러닝이 끝나지 않았더라도 할당된 시간을 채웠으면 Queue의 맨 뒤로 가야한다.

- 병목현상을 쉽게 해결 가능하다.

- 일반적으로 할당시간은 밀리초 수준으로, 사용자에게 짧은 응답시간을 제공할 수 있다. 

#### 우선순위 스케줄링

CPU 사용을 위해 대기 중인 프로세스들에 우선순위를 부여하고, 우선순위가 높은 순서대로 CPU를 할당한다.

우선순위 설정 알고리즘이 중요하다.

- 기다린 시간이 늘어날수록 우선순위를 높여준다든지 하는 예시가 있을 것.

### 메모리 관리방법

기본적으로 메모리는 **CPU가 직접 접근할 수 있는** 컴퓨터 내부의 **기억장치**이다.

프로그램이 CPU에서 실행되려면, 해당 부분이 메모리에 올라가 있어야 한다.

운영체제는 프로그램에 메모리가 필요할 때 할당하고, 필요하지 않을 때 회수하는 역할을 맡는다.

- 메모리를 관리하려면 메모리의 어느 부분이 어느 프로그램에서 사용되고 있는지 파악하고 이를 유지해야 하는데, 이러한 정보를 **주소**를 통해 관리한다.

- 정확히 **실질적인 필요**에 근거해 메모리를 할당함으로써 전체 메모리 공간이 효율적으로 사용될 수 있게 해야 한다.

- **다수의 사용자** 프로그램이 동시에 메모리에 올라간 경우, 서로 다른 프로세스의 영역을 침범하지 않도록 **보안**을 유지하는 것도 운영체제의 역할이다.

#### 고정분할 방식(fixed partition)

물리적 메모리를 몇 개의 분할로 **미리 나누어** 관리하는 방식이다.

각 분할에는 **하나의 프로그램만** 적재될 수 있다.

융통성이 매우 부족한 방법이다.

- 메모리에 동시 적재되는 프로그램의 최대 수 = 미리 나눠놓은 분할 개수

- 분할의 크기보다 큰 프로그램은 적재 불가능

- 분할의 크기보다 작은 프로그램 적재 시 해당 분할 내에 남는 공간이 발생
  
  - 이를 **내부조각**(internal fragmentation)이라 한다.
  
  - 해당 분할에 올라온 프로그램, 다른 프로그램 모두 사용 불가한 공간이다.

#### 가변분할 방식(variable partition)

**매 시점** 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다.

물리적 메모리 전체보다 큰 프로그램 실행은 불가능하지만, 내부조각이 더 이상 발생하지 않는다.

분할의 크기와 개수가 동적으로 변하므로, 기술적인 관리기법들이 중요하다.

**외부조각**(external fragmentation)이 발생할 수 있다.

- 외부조각은, 프로그램이 할당되지는 않았지만 그 크기가 너무 작아 프로그램을 올릴 수 없는 메모리 영역이다.

- 결과적으로 낭비되는 메모리 자원이다.

#### 가상메모리 기법(virtual memory)

현대 범용 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다.

가상메모리 기법을 통해, 물리적 메모리보다도 **더 큰 프로그램**을 실행할 수 있다.

- 물론 가상메모리 크기보다 큰 프로그램은 실행할 수 없다.

구체적으로,

- 모든 프로그램은 물리적 메모리와는 **독립적으로** 자신만의 **가상메모리 주소**를 가진다.

- 운영체제는 가상메모리의 주소를 물리적 메모리의 주소로 **매핑**하는 기술을 가지고 있다.

- 운영체제가 프로그램의 가상메모리 주소를 물리적 메모리 주소로 변환시킨 후, 프로그램을 물리적 메모리에 올려 실행된다.

이게 가능한 이유는, 프로그램의 전체 크기가 2GB라고 해도 그 **전체가 항상** 사용되는 것은 아니기 때문이다.

현재 사용하고 있는 부분만 메모리에 올리고, 나머지는 하드디스크 같은 **보조 기억장치**에 저장해뒀다가 필요할 때 적재하게 된다.

- 이렇게 사용되는 보조기억장치의 영역을 **스왑 영역**(swap area)이라 부른다.

결과적으로, 전체 프로그램을 구성하는 가상메모리 주소 공간은 **페이지**(page)라는 동일한 크기의 작은 단위들로 나뉘어, **물리적 메모리**와 **스왑 영역**에 일부분씩 저장된다.

이러한 방법을 **페이징**(paging) 기법이라고 한다.

### 입출력 장치 관리 방법

**인터럽트**(interrupt)라는 메커니즘을 통해 관리가 이루어진다.

주변장치들은 CPU의 서비스가 필요한 경우 신호를 발생시켜 서비스를 요청하는데, 이 때의 신호를 인터럽트라고 한다.

CPU는 자체 스케줄링에 따라 작업을 수행하다가, **인터럽트가 발생하면** 하던 일을 잠시 멈추고 인터럽트에 의한 서비스를 수행하게 된다.

- 사용자가 키보드로 글자를 입력하면, CPU에 인터럽트가 발생하고 CPU는 하던 일을 멈춘 채 키보드가 발생시킨 이벤트를 수행했다가 원래 작업으로 돌아오게 된다.

- 즉, 운영체제는 인터럽트 처리 직전에 수행 중이던 작업 상태를 **저장**해둘 필요가 있다.

인터럽트는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있어서, 운영체제는 그에 맞는 서로 다른 **인터럽트 처리 루틴**을 가지고 있어야 한다.

- 인터럽트 처리 루틴은, 인터럽트 발생 시 해주어야 할 작업을 정의한 프로그램 코드다.

- 이는 운영체제 **커널 내**에 존재하는 코드로 CPU 스케줄링, 메모리 관리 루틴과 마찬가지로 커널 코드의 일부분이다.

- 인터럽트 발생 시 운영체제는 **그에 해당하는 인터럽트 처리 루틴을 찾아서** 정의된 코드에 따라 일을 수행한다.

주변장치들은 각 장치에서 일어나는 업무를 관리하기 위해 일종의 작은 CPU를 들고 있는데, 이를 **컨트롤러**(controller)라고 부른다.

- 컨트롤러는 해당 장치에 대한 업무를 처리해, 메인 CPU에 **인터럽트를 발생시켜 보고**하는 역할을 한다.
