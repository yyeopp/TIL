# Chapter 08: 가상메모리

---

운영체제는 프로세스의 빠른 수행을 위해, 보통 몇몇 프로그램에게 집중적으로 메모리를 할당했다가 회수하는 방식을 채택한다.

프로그램이 실행되기 위해서는 프로세스 주소 공간 **전체가** 메모리에 올라와야 하는 것은 아니므로, 운영체제는 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 **디스크 스왑 영역**에 내려놨다가 필요할 때 가져와서 사용한다.

즉, 프로그램 입장에서는 **물리 메모리의 크기**에 대해 생각할 필요가 없다. 각기 **0번지**부터 시작하는 자신만의 메모리 주소 공간을 가정하고 실행되는데, 이러한 공간을 **가상메모리**라고 부른다.

---

## 요구 페이징

요구 페이징은 프로그램 실행 시, 프로세스를 구성하는 모든 **페이지**를 한꺼번에 메모리에 올리는 것이 아니라 **당장 사용될 페이지만**을 올리는 방식이다.

- 특정 페이지에 대해 **CPU 요청**이 들어온 후에야 메모리에 적재하게 된다.

당연히 **메모리 사용량이 감소**하고, 메모리에 대한 **입출력 오버헤드도 감소**한다.

결과적으로 **응답시간이 감소**하고, **더 많은 프로세스가 수용**될 수 있다.

- 프로그램을 구성하는 페이지 중 일부만을 메모리에 적재하기 때문에 물리 메모리의 용량 제약을 벗어날 수 있는 것.

메모리에 올라오지 않는 페이지는 **디스크 스왑 영역**에 존재한다.

운영체제는 요구 페이징 기법 사용 시, **유효-무효 비트**를 두어 **어떤 페이지가 메모리에 존재하는지**를 표시하게 된다.

- 해당 비트는 **페이지 테이블**의 **각 항목별**로 저장된다.

- 메모리에 적재될 때 유효값으로, 스왑 영역으로 쫓겨날 때 무효값으로 변경된다.

CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 비트값이 무효로 세팅되어 있는 경우에 대해, **페이지 부재**가 일어났다고 한다.

### 요구 페이징의 페이지 부재 처리

CPU가 무효 페이지에 접근하면, 주소 변환 담당 하드웨어인 **MMU**가 **페이지 부재 트랩**을 발생시킨다.

운영체제는 커널모드에 돌입하여 **페이지 부재 처리루틴**을 호출한다.

- 
