# Chapter 06: CPU 스케줄링

---

CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내 중앙처리장치다.

- 프로그램이 메모리에 올라가면, **프로그램 카운터**라는 레지스터가 당장 수행해야 할 코드의 메모리 주소값을 가진다.

- CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행한다.

- 하나의 CPU를 여러 프로그램이 사용하기 위해서는 **시분할** 환경에서 효율적인 관리가 필요하다.

프로그램 실행과 관련된 **기계어 명령**은 CPU에서 수행되는 명령, 메모리 접근을 필요로 하는 명령, 입출력을 동반하는 명령으로 나눌 수 있다.

- **CPU** 내에서 수행되는 명령의 예시가 **Add 명령**이다.
  
  - 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령으로, CPU 내에서 수행되는 매우 빠른 명령이다.

- **메모리 접근**을 수행하는 명령은 **Load 명령**과 **Store 명령**이 있다.
  
  - Load는 메모리에 있는 데이터를 CPU로 읽어들이는 명령이고
  
  - Store는 CPU에서 계산된 결과값을 메모리에 저장하는 명령이다.
  
  - 비교적 짧은 시간에 수행이 가능하고, *여기까지는* 사용자 프로그램이 직접 실행 가능한 **일반명령**에 해당한다.

- **입출력 작업**을 동반하는 명령 또한 자주 발생한다.
  
  - 키보드, 마우스, 디스크 등 입출력 장치와 연관된 작업들이다.
  
  - 일반적으로 다른 둘에 비해 아주 오랜 시간이 소요되고, **모든** 입출력 명령은 **특권명령**에 해당한다.

결과적으로 사용자 프로그램이 수행되는 과정은 **CPU 작업**과 **I/O 작업**의 반복이다.

- 사용자 프로그램이 CPU를 직접 다루는 빠른 전자의 과정을 **CPU 버스트**라 하고,

- CPU 제어권이 운영체제로 넘어가고 그 자체도 매우 느린 후자의 과정을 **I/O 버스트**라고 부른다.

- CPU 버스트는 I/O 작업 사이, I/O 버스트는 CPU 작업 사이라고 보면 된다.

프로그램마다 CPU 버스트와 I/O 버스트 간의 비율은 천차만별이다.

- **I/O 바운드 프로세스**는 I/O 버스트의 비중이 상대적으로 높은 프로세스,

- **CPU 바운드 프로세스**는 CPU 버스트의 비중이 상대적으로 높은 프로세스를 말한다.

- 주로 I/O 바운드 프로세스는 사용자로부터의 **인터랙션**이 지속되는 **대화형 프로그램**들이고, CPU 바운드 프로세스는 **계산 위주의 프로그램**들이다.

**CPU 스케줄링**이란, 이와 같이 **CPU 사용 패턴**이 상이한 여러 프로그램을 시스템 내부에서 효율적으로 실행하기 위해 필요하다.

실제 프로세스들을 분석해보면, **다수의 짧은 CPU 버스트**와 **소수의 긴 CPU 버스트**로 구성됨을 확인할 수 있다.

- 즉, 대부분의 프로세스는 CPU를 잠깐만 사용하고 I/O 작업을 수행 중이라는 것.
  
  - 이러한 경우 거의 **대화형 프로그램**이기 때문에, 사용자에게 최대한 빠른 응답을 돌려줄 필요가 있다.
  
  - 어차피 CPU 작업이 길지도 않으니 최대한 빨리 할당해서 처리해줄 필요가 있다는 뜻.

- 다시 말해, CPU 스케줄링 시 I/O 바운드 프로세스는 **우선순위가 높다**.
  
  - **대화형 프로세스**에서 빠른 응답성 제공이 가능하고,
  
  - CPU는 잠깐 사용하고 곧바로 I/O 작업에 돌입할 수 있다는 점에서 **I/O 장치의 효율성을 높이는** 효과도 있다.

---

## CPU 스케줄러

CPU 스케줄러는 **준비** 상태의 프로세스 중 어디에 CPU를 할당할지 결정하는 운영체제의 코드다.

**타이머 인터럽트** 발생 시 CPU 스케줄러가 호출되어, **준비 큐**에서 기다리고 있는 프로세스 중 하나에게 CPU를 할당하게 된다.

그 외에도 CPU 스케줄링이 필요한 경우는

- 실행 상태의 프로세스가 I/O 요청 등으로 인해 **봉쇄** 상태로 바뀌거나

- 실행 상태의 프로세스가 **타이머 인터럽트** 발생으로 인해 준비 상태로 바뀌거나

- I/O 요청이 완료되어 봉쇄 상태의 프로세스가 준비 상태로 바뀌거나
  
  - (I/O 요청이 완료된 프로세스는 인터럽트 당한 프로세스보다 우선순위가 높고, **문맥교환**을 통해 CPU를 할당받게 된다)

- 실행 상태의 프로세스가 스스로 종료되는 경우가 있다.

구체적인 방식에는 **비선점형** 방식과 **선점형** 방식이 있다.

- 비선점형 방식은, CPU를 획득한 프로세스가 **스스로 반납하기 전까지는** CPU를 빼앗기지 않는다.

- 선점형 방식은, 프로세스로부터 CPU를 **강제로** 빼앗을 수 있다.
  
  - 빼앗는 방식으로 대표적인 것이 **타이머 인터럽트**.
  
  - 위의 4가지도 1,4는 비선점형, 2,3은 선점형으로 구분할 수 있다.

---

## 디스패처

선택된 프로세스에게 **실제로 CPU를 이양하는 작업**이 필요한데, 이를 수행하는 운영체제의 코드를 **디스패처**라고 부른다.

디스패처는 수행 중이던 프로세스의 문맥을 **해당 프로세스의 PCB에 저장**하고, 선택된 프로세스의 **문맥을 PCB로터 복원**한 뒤 시스템 상태를 **사용자모드로 전환**하여 **CPU를 넘기**는 과정을 수행한다.

사용자 프로그램은 복원된 문맥 중 **프로그램 카운터**로부터 당장 수행해야 할 코드의 주소를 찾을 수 있다.

디스패처가 *하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간*을 **디스패치 지연시간**이라고 하는데, 그 대부분은 **문맥교환**에 따른 오버헤드다.

---

## 스케줄링의 성능 평가

스케줄링 기법의 성능 평가를 위한 여러 지표들은, **시스템 관점**의 지표와 **사용자 관점**의 지표로 나눌 수 있다.

- 시스템 관점 지표는 CPU 이용률과 처리량이 있고

- 사용자 관점 지표는 소요시간, 대기시간, 응답시간 등 시간 관련 지표가 있다.

**CPU 이용률**은, 전체 시간 중 **CPU가 일을 한 시간의 비율**을 뜻한다.

- CPU는 고비용 자원이므로, 이용률이 높을수록 시스템 전체의 성능이 높다.

- CPU의 휴면 시간을 최대한으로 단축하는 것은 스케줄링의 중요한 목표다.

**처리량**은 주어진 시간 동안 **준비 큐**에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타낸다. **CPU 버스트를 완료한 프로세스의 개수**라고 볼 수 있다.

- CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당함으로써 달성 가능하다.

**소요시간**은 프로세스가 CPU를 요청한 시점부터 **CPU 버스트가 끝날 때까지** 걸린 시간이다.

- 준비 큐에서 기다린 시간과 CPU를 실제로 사용한 시간의 합이다.

**대기시간**은 CPU 버스트 **기간 중** 프로세스가 준비 큐에서 기다린 시간의 합이다.

- **시분할** 시스템에서는 한 번의 CPU 버스트 중에도, **타이머 인터럽트**로 인해 준비 큐로 돌아가 기다리는 상황이 여러 번 발생할 수 있다.

- 그러한 대기시간의 총합이다.

**응답시간**은 프로세스가 준비 큐에 들어온 후, 처음 CPU를 획득하기까지 기다린 시간이다.

- **타이머 인터럽트**가 빈번할 수록 *처음* CPU를 획득하기는 쉽다.

- 즉, **대화형 시스템**에 적합한 성능 척도고, 사용자 입장에서 중요한 척도다.

---

## 스케줄링 알고리즘

### 선입선출 스케줄링


