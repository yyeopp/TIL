# Chapter 07: 메모리 관리

---

메모리는 주소를 통해 접근하는 저장장치이다.

컴퓨터에서는 byte 단위로 메모리 주소를 부여하므로, 32비트 주소 체계를 사용할 시 2^32바이트만큼의 메모리 공간에 서로 다른 주소가 할당될 수 있다.

효율적인 운영을 위해 컴퓨터상의 주소도 **계층적으로 나누어 관리**되는데, 4KB 단위로 묶어서 **페이지**라는 하나의 행정구역을 만들고 있다.

- 총 32비트의 메모리 주소 중 하위 12비트는 **페이지 내의 주소**를 나타내게 된다.

---

## 주소 바인딩

프로그램은 **물리적 메모리**에 올라가 있고, CPU가 기계어 명령을 수행하기 위해서는 **프로세스의 논리적 주소**를 통해 메모리 참조를 한다.

즉, 해당 논리적 주소와 물리적 메모리 주소를 매핑하는 작업이 필요한데, 이를 **주소 바인딩**(address binding)이라고 한다.

그 방식을, 프로그램이 적재되는 **물리적 메모리의 주소가 결정되는 시기**에 따라 구분할 수 있다.

- **컴파일 타임 바인딩**은, 물리적 주소가 프로그램 컴파일 시 결정되는 방식이다.
  
  - 프로그램이 **절대주소**로 적재된다는 점에서, **절대코드**를 생성하는 바인딩 방식이라고 말할 수 있다.
  
  - 프로그램의 물리적 주소를 변경하고 싶으면 컴파일을 다시 해야 하는 단점이 있어, 현대 시분할 환경에서 잘 사용하지 않는다.

- **로드 타임 바인딩**은, 프로그램 실행이 시작될 때 물리적 주소가 결정되는 방식이다.
  
  - 사용자 프로그램을 메모리에 적재시키는, **로더**의 책임 하에 물리적 주소가 부여되고 프로그램 종료 시까지 주소가 고정된다.
  
  - 컴파일러가 **재배치 가능 코드**를 생성한 경우에 가능하다.

- **실행시간 바인딩**은, 프로그램 실행 이후에도 물리적 주소가 변경될 수 있는 방식이다.
  
  - CPU가 논리적 주소를 참조할 때마다, **주소 매핑 테이블**을 이용해 물리적 메모리의 위치를 점검하게 된다.
  
  - 가능하기 위해서는 기준 레지스터와 한계 레지스터, MMU라는 **하드웨어적 지원**이 필요하다.
    
    - MMU는, 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치다.

#### MMU 기법

가장 기본적인 방식의 주소 변환으로, CPU가 특정 프로세스의 논리적 주소를 참조하려할 때 그 주소값에 **기준 레지스터의 값을 더해** 물리적 주소값을 얻어낸다.

- 기준 레지스터(재배치 레지스터)는 해당 프로세스의 **물리적 메모리 시작 주소**를 가지고 있다.

- 특정 프로세스의 주소 공간이 물리적 메모리에 **연속적으로** 저장되는 걸 전제로, 그 시작 주소만 알고 있다면 단순 합 연산으로 모든 물리적 주소를 파악할 수 있는 것.

- 기준 레지스터에 더하는 값인 **논리적 주소**는, 결국 물리적 주소의 **시작 위치**로부터 얼마나 떨어져 있는지 나타내는 **오프셋**의 개념으로 바라볼 수 있다.

당연하지만 모든 프로세스에 대해 **기준 레지스터** 값은 달라야 한다.

- **문맥교환** 시, 기준 레지스터값도 해당 프로세스에 맞는 값으로 설정함으로써 여러 프로세스를 동시에 지원할 수 있다.

여러 프로세스가 올라와 있는 상황에서 주소 변환을 한 결과, **해당 프로세스의 주소 공간을 벗어나버리는** 경우가 발생할 수 있다.

- 이는 **메모리 보안** 측면에서 치명적인 결과를 초래할 수 있다.

- 이를 방지하기 위한 장치가 **한계 레지스터**이다.

한계 레지스터는, 프로세스가 자신의 주소 공간을 넘어서는 메모리를 참조하려 하는지 체크하는 용도로 사용되어, **현재 프로세스의 논리적 주소 최댓값**을 담고 있다.

- CPU가 메모리 참조 요청을 했을 때 그 주소가 한계 레지스터값보다 큰지를 먼저 체크하여 메모리 보안을 유지할 수 있다.

- 다른 프로세스의 주소 영역을 접근하려는 시도가 발생하면, **트랩**을 발생시켜 해당 프로세스로부터 CPU를 강탈한다.

### 메모리 관리와 관련된 용어

#### 동적로딩


