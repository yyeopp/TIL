# Chapter 05: 프로세스 관리

---

## 프로세스의 개념

프로세스는 **실행 중인 프로그램**을 뜻한다.

프로세스의 **문맥**이란, 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미한다.

- 문맥은, 시분할 시스템이나 시스템 콜에 의해 CPU를 빼앗겼던 프로세스에 CPU가 복귀할 떄 **직전 수행 시점**을 정확히 재현하기 위한 정보다.

- 프로세스의 주소 공간(코드, 데이터, 스택 상태)과 **레지스터** 값, 시스템 콜 등으로 커널에서 수행한 일의 상태, 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함한다.

문맥을 크게 세 가지로 분류할 수 있다.

- **하드웨어 문맥**은, CPU의 수행 상태를 나타낸다. 프로그램 카운터값, 각종 레지스터 저장 값을 의미한다.

- **프로세스의 주소 공간**은, 코드, 데이터, 스택으로 구성된 독자적인 주소 공간을 의미한다.

- **커널상의 문맥**은, 운영체제가 프로세스를 관리하기 위한 자료구조로 PCB와 커널스택이 이에 해당한다.

---

## 프로세스의 상태

크게 **실행, 준비, 봉쇄**로 구분할 수 있다.

**실행**(running) 상태는 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태를 뜻한다.

**준비**(ready) 상태는 프로세스가 CPU를 할당받지 못한 상태로 메모리에 올라가 대기하고 있는 것을 뜻한다.

**봉쇄**(blocked) 상태는 CPU를 할당받더라도 당장 명령 실행이 불가한 프로세스의 상태를 말한다.

- 해당 프로세스가 요청한 **입출력 작업**이 진행 중인 경우가 대표적이다.

그 밖에, 프로세스가 생성 중이거나 종료 중인 일시적 상태를 **시작** 및 **완료** 상태로 부르기도 한다.

- 시작 상태는 프로세스가 시작되어 이를 위한 각종 자료구조는 생성되었지만 **아직 메모리 획득은 승인받지 못한** 상태이고,

- 완료 상태는 프로세스가 종료되었으나 운영체제가 그와 관련된 자료구조를 완전히 정리하지 못한 상태다.

운영체제가 여러 요인에 의해 실행시킬 프로세스를 변경하기 위해, 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 **문맥교환**(**context switch**)라고 한다.

그리고 준비 상태에 있던 프로세스 중 하나가 선택되어 실제로 CPU의 제어권을 넘겨받는 과정을 **CPU 디스패치**(dispatch)라고 한다.

디스크 입출력을 예시로 생각할 때, 

- 프로세스 A가 디스크 입출력을 요청한 뒤 봉쇄되고 프로세스 B가 CPU를 점유하던 중,

- A에 대한 디스크 입출력이 완료되면 컨트롤러의 인터럽트에 의해 CPU가 루틴을 수행한다.
  
  - 이 때, 인터럽트 처리루틴은 직전에 CPU가 수행 중이던 B와 무관한 업무지만 **편의상** 직전 프로세스인 B의 **문맥**에서 실행된 것으로 간주된다.
  
  - 즉, 인터럽트 발생 원인에 관계없이, **인터럽트를 당한 프로세스는 사용자모드에서 커널모드로 진입**하는 것으로 간주된다.

- 처리가 끝나면 CPU는 다시 이전에 수행하던 B로 돌아가 직전 수행 시점의 코드를 수행한다.
  
  - 경우에 따라, 입출력이 완료된 A 프로세스에게 **문맥교환**을 통해 CPU 제어권을 이양할  수 있는데 이는 CPU 스케줄링 기법에 따라 달라진다.
  
  - 일반적인 경우는 아니다.

---

## 프로세스 제어블록(Process Control Block, PCB)

운영체제가 시스템 내 프로세스들을 관리하기 위해 **프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조**이다.

- 프로세스 상태, 프로그램 카운터 값, CPU 레지스터 값, CPU 스케줄링 정보, 메모리 관리 정보, 자원 사용 정보, 입출력 상태 정보를 담는다.

- 프로세스 상태는 **CPU를 할당해도 되는지 여부**

- 프로그램 카운터값은 **다음 수행할 명령의 위치**

- CPU 레지스터값은 **CPU 연산을 위해** 현 시점 레지스터가 어떤 값을 저장하고 있는지

---

## 문맥교환(Context switch)

하나의 사용자 프로세스로부터 다른 사용자 프로세스로, **CPU의 제어권이 이양되는 과정**을 뜻한다.

- 대표적으로 **타이머 인터럽트**가 발생하면 문맥교환이 이루어진다.

- **입출력 요청 시스템 콜**에 의해 **봉쇄 상태**에 들어가는 경우도 마찬가지.

문맥교환이 발생하면 원래 CPU를 보유하던 프로세스는 그 문맥을 자신의 **PCB**에 저장하고, 새로 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 하드웨어로 복원하는 과정을 거친다.

프로세스 실행 중 스스로 **시스템 콜**이나 인터럽트를 발생시킬 때도 커널의 코드가 실행되기 위해 프로세스 문맥 중 일부를 **PCB에 저장**하게 되지만, 이걸 문맥교환이라고 하지는 않는다.

- 이건 하나의 프로세스의 **실행모드**가 사용자모드에서 커널모드로 바뀌는 것일 뿐 프로세스 자체가 변경되는 것이 아니기 때문.

- 이러한 **모드변경**은 문맥교환보다 훨씬 적은 오버헤드를 유발한다.

문맥교환에 소요되는 시간은 시스템 입장에서 상당한 오버헤드다.

- 타이머에 CPU 할당시간을 너무 작게 세팅하면, 문맥교환이 빈번해져 이에 따른 오버헤드가 상당히 커진다.

- 그렇다고 CPU 할당시간을 너무 크게 두면 시분할 시스템의 의미가 퇴색된다.

---

## 프로세스를 스케줄링하기 위한 큐

운영체제는 **준비** 상태에 있는 프로세스들을 **준비 큐**(ready queue)에 두고 순서대로 CPU를 할당한다.

- 줄 세우는 방법은, **CPU 스케줄링 방법**에 따라 달라진다.

CPU에 대한 준비 큐 외에도 특정 자원을 기다리는 프로세스들을 줄 세우기 위해, 자원별로 **장치 큐**(device queue)를 둔다.

- 디스크 입출력 서비스라고 하면, 프로세스들이 **디스크 입출력 큐**에 줄을 서는 것.

하드웨어 자원이 아닌 **소프트웨어 자원**을 기다리는 경우에도 큐는 필요하다.

특히 **공유 데이터**에 대한 접근 시, 데이터 **일관성** 훼손을 막기 위해서는 매 시점 하나의 프로세스만 접근할 수 있도록 해야 한다.

- 이 때 접근은, 공유 데이터에 접근 중이던 프로세스가 준비나 **봉쇄** 상태에 들어간 경우에도 적용되어야 한다.

- 완전히 반납한 경우 비로소 새로운 프로세스가 접근이 가능하고, 이를 구현하기 위해 큐를 활용한다.

이와 같은 프로세스의 상태 관리는, 커널의 **데이터 영역**에 다양한 **큐**를 두어 수행한다.

운영체제는 준비 큐, 장치 큐 외에도 **작업 큐**(job queue)를 두고 있는데, 이는 시스템 내의 **모든 프로세스를 관리**하기 위한 큐로 프로세스 상태와 무관하게 현재 시스템 내 모든 프로세스가 이에 속한다.

- 즉, 메모리를 가지고 있지 않을 수도 있다.

- 준비 큐와 장치 큐의 모든 프로세스들은 작업 큐에 속한다.

운영체제가 다양한 큐를 자료구조로 구현하는 방식으로, **큐헤더**(queue header)는 큐의 가장 앞 부분에 해당한다.

- 큐는 각 프로세스의 **PCB**들을 **연결 리스트** 형태로 관리하며, **포인터**를 사용해 순서를 결정한다.

---

## 스케줄러


