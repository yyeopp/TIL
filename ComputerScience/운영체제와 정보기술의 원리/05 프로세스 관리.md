# Chapter 05: 프로세스 관리

---

## 프로세스의 개념

프로세스는 **실행 중인 프로그램**을 뜻한다.

프로세스의 **문맥**이란, 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미한다.

- 문맥은, 시분할 시스템이나 시스템 콜에 의해 CPU를 빼앗겼던 프로세스에 CPU가 복귀할 떄 **직전 수행 시점**을 정확히 재현하기 위한 정보다.

- 프로세스의 주소 공간(코드, 데이터, 스택 상태)과 **레지스터** 값, 시스템 콜 등으로 커널에서 수행한 일의 상태, 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함한다.

문맥을 크게 세 가지로 분류할 수 있다.

- **하드웨어 문맥**은, CPU의 수행 상태를 나타낸다. 프로그램 카운터값, 각종 레지스터 저장 값을 의미한다.

- **프로세스의 주소 공간**은, 코드, 데이터, 스택으로 구성된 독자적인 주소 공간을 의미한다.

- **커널상의 문맥**은, 운영체제가 프로세스를 관리하기 위한 자료구조로 PCB와 커널스택이 이에 해당한다.

---

## 프로세스의 상태

크게 **실행, 준비, 봉쇄**로 구분할 수 있다.

**실행**(running) 상태는 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태를 뜻한다.

**준비**(ready) 상태는 프로세스가 CPU를 할당받지 못한 상태로 메모리에 올라가 대기하고 있는 것을 뜻한다.

**봉쇄**(blocked) 상태는 CPU를 할당받더라도 당장 명령 실행이 불가한 프로세스의 상태를 말한다.

- 해당 프로세스가 요청한 **입출력 작업**이 진행 중인 경우가 대표적이다.

그 밖에, 프로세스가 생성 중이거나 종료 중인 일시적 상태를 **시작** 및 **완료** 상태로 부르기도 한다.

- 시작 상태는 프로세스가 시작되어 이를 위한 각종 자료구조는 생성되었지만 **아직 메모리 획득은 승인받지 못한** 상태이고,

- 완료 상태는 프로세스가 종료되었으나 운영체제가 그와 관련된 자료구조를 완전히 정리하지 못한 상태다.

운영체제가 여러 요인에 의해 실행시킬 프로세스를 변경하기 위해, 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 **문맥교환**(**context switch**)라고 한다.

그리고 준비 상태에 있던 프로세스 중 하나가 선택되어 실제로 CPU의 제어권을 넘겨받는 과정을 **CPU 디스패치**(dispatch)라고 한다.

디스크 입출력을 예시로 생각할 때, 

- 프로세스 A가 디스크 입출력을 요청한 뒤 봉쇄되고 프로세스 B가 CPU를 점유하던 중,

- A에 대한 디스크 입출력이 완료되면 컨트롤러의 인터럽트에 의해 CPU가 루틴을 수행한다.
  
  - 이 때, 인터럽트 처리루틴은 직전에 CPU가 수행 중이던 B와 무관한 업무지만 **편의상** 직전 프로세스인 B의 **문맥**에서 실행된 것으로 간주된다.
  
  - 즉, 인터럽트 발생 원인에 관계없이, **인터럽트를 당한 프로세스는 사용자모드에서 커널모드로 진입**하는 것으로 간주된다.

- 처리가 끝나면 CPU는 다시 이전에 수행하던 B로 돌아가 직전 수행 시점의 코드를 수행한다.
  
  - 경우에 따라, 입출력이 완료된 A 프로세스에게 **문맥교환**을 통해 CPU 제어권을 이양할  수 있는데 이는 CPU 스케줄링 기법에 따라 달라진다.
  
  - 일반적인 경우는 아니다.

---

## 프로세스 제어블록(Process Control Block, PCB)

운영체제가 시스템 내 프로세스들을 관리하기 위해 **프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조**이다.

- 프로세스 상태, 프로그램 카운터 값, CPU 레지스터 값, CPU 스케줄링 정보, 메모리 관리 정보, 자원 사용 정보, 입출력 상태 정보를 담는다.

- 프로세스 상태는 **CPU를 할당해도 되는지 여부**

- 프로그램 카운터값은 **다음 수행할 명령의 위치**

- CPU 레지스터값은 **CPU 연산을 위해** 현 시점 레지스터가 어떤 값을 저장하고 있는지

---

## 문맥교환(Context switch)

하나의 사용자 프로세스로부터 다른 사용자 프로세스로, **CPU의 제어권이 이양되는 과정**을 뜻한다.

- 대표적으로 **타이머 인터럽트**가 발생하면 문맥교환이 이루어진다.

- **입출력 요청 시스템 콜**에 의해 **봉쇄 상태**에 들어가는 경우도 마찬가지.

문맥교환이 발생하면 원래 CPU를 보유하던 프로세스는 그 문맥을 자신의 **PCB**에 저장하고, 새로 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 하드웨어로 복원하는 과정을 거친다.

프로세스 실행 중 스스로 **시스템 콜**이나 인터럽트를 발생시킬 때도 커널의 코드가 실행되기 위해 프로세스 문맥 중 일부를 **PCB에 저장**하게 되지만, 이걸 문맥교환이라고 하지는 않는다.

- 이건 하나의 프로세스의 **실행모드**가 사용자모드에서 커널모드로 바뀌는 것일 뿐 프로세스 자체가 변경되는 것이 아니기 때문.

- 이러한 **모드변경**은 문맥교환보다 훨씬 적은 오버헤드를 유발한다.

문맥교환에 소요되는 시간은 시스템 입장에서 상당한 오버헤드다.

- 타이머에 CPU 할당시간을 너무 작게 세팅하면, 문맥교환이 빈번해져 이에 따른 오버헤드가 상당히 커진다.

- 그렇다고 CPU 할당시간을 너무 크게 두면 시분할 시스템의 의미가 퇴색된다.

---

## 프로세스를 스케줄링하기 위한 큐

운영체제는 **준비** 상태에 있는 프로세스들을 **준비 큐**(ready queue)에 두고 순서대로 CPU를 할당한다.

- 줄 세우는 방법은, **CPU 스케줄링 방법**에 따라 달라진다.

CPU에 대한 준비 큐 외에도 특정 자원을 기다리는 프로세스들을 줄 세우기 위해, 자원별로 **장치 큐**(device queue)를 둔다.

- 디스크 입출력 서비스라고 하면, 프로세스들이 **디스크 입출력 큐**에 줄을 서는 것.

하드웨어 자원이 아닌 **소프트웨어 자원**을 기다리는 경우에도 큐는 필요하다.

특히 **공유 데이터**에 대한 접근 시, 데이터 **일관성** 훼손을 막기 위해서는 매 시점 하나의 프로세스만 접근할 수 있도록 해야 한다.

- 이 때 접근은, 공유 데이터에 접근 중이던 프로세스가 준비나 **봉쇄** 상태에 들어간 경우에도 적용되어야 한다.

- 완전히 반납한 경우 비로소 새로운 프로세스가 접근이 가능하고, 이를 구현하기 위해 큐를 활용한다.

이와 같은 프로세스의 상태 관리는, 커널의 **데이터 영역**에 다양한 **큐**를 두어 수행한다.

운영체제는 준비 큐, 장치 큐 외에도 **작업 큐**(job queue)를 두고 있는데, 이는 시스템 내의 **모든 프로세스를 관리**하기 위한 큐로 프로세스 상태와 무관하게 현재 시스템 내 모든 프로세스가 이에 속한다.

- 즉, 메모리를 가지고 있지 않을 수도 있다.

- 준비 큐와 장치 큐의 모든 프로세스들은 작업 큐에 속한다.

운영체제가 다양한 큐를 자료구조로 구현하는 방식으로, **큐헤더**(queue header)는 큐의 가장 앞 부분에 해당한다.

- 큐는 각 프로세스의 **PCB**들을 **연결 리스트** 형태로 관리하며, **포인터**를 사용해 순서를 결정한다.

---

## 스케줄러

스케줄러는, **어떤 프로세스에게 자원을 할당할 지 결정하는 운영체제 커널의 코드**를 지칭한다.

장기 스케줄러와 단기 스케줄러가 있다.

- **장기 스케줄러**는 **작업 스케줄러**라고도 부른다. 어떤 프로세스를 **준비 큐에 진입시킬지** 결정하는 역할을 한다.
  
  - 이 때 준비 큐는 **메모리가 할당되어 있어서** CPU만 받으면 당장 실행 가능한, **준비 상태** 프로세스의 집합.
  
  - 준비 상태 이전의 **시작 상태**의 프로세스들 중, 어떠한 프로세스에 **메모리를 할당하여** 준비 큐에 삽입할 것인지를 장기 스케줄러가 결정한다.
  
  - 수십 초 단위로 가끔씩만 호출되므로, 수행 속도가 느린 것이 허용된다.
  
  - **메모리에 동시에 올라가 있는 프로세스의 수**를 조절하는 역할을 한다고도 볼 수 있다.

- **단기 스케줄러**는 **CPU 스케줄러**라고도 부른다. 준비 상태 프로세스 중 어떤 프로세스를 **다음 순서 실행 상태로 만들 것인지** 결정한다.
  
  - 즉, 준비 큐에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할 것인지.
  
  - 예시로 **시분할 시스템**에서 **타이머 인터럽트**가 발생하면 단기 스케줄러가 호출된다.
  
  - 밀리초 수준으로 매우 빈번하게 호출되므로, **수행 속도**가 충분히 빨라야 한다.

단, 현대의 시분할 시스템에서는 일반적으로 장기 스케줄러를 따로 두고 있지 않다.

- 컴퓨터 자원 (특히 메모리) 이 충분히 커졌기 때문.

- 지금은 그냥 프로세스가 시작 상태가 될 때 **메모리를 할당**해서 준비 큐에 바로 넣어준다.

대신, **중기 스케줄러**를 두는 경우는 많다.

중기 스케줄러는, 너무 많은 프로세스에게 메모리를 할당해 시스템 성능이 저하되는 경우 **프로세스 수를 동적으로 조절**하기 위해 추가된 스케줄러다.

- 너무 많은 프로세스가 메모리에 적재되면 **프로세스 당 보유 메모리 양**이 극도로 적어지고, 이는 잦은 디스크 입출력을 유발해 시스템 성능 저하로 이어질 수 있기 때문.

- 중기 스케줄러는, 메모리에 있는 프로세스 중 일부의 메모리를 **통째로 빼앗아** 그 내용을 **디스크 스왑 영역**에 저장한다.
  
  - 이를 **스왑 아웃**이라고 부른다.

- **스왑 아웃**의 0순위 프로세스는 **봉쇄 상태**에 있는 프로세스들이다. 당장 CPU를 획득할 가능성이 없기 때문.

- 그 다음 순위는 보통 **타이머 인터럽트**가 발생해 준비 큐로 이동하는 프로세스들이다.

- 결과적으로, 장기 스케줄러와 마찬가지로 메모리에 올라와 있는 프로세스 수 조절이 가능하다.

중기 스케줄러의 등장으로 인해 프로세스의 상태에는 **중지**(suspended, stopped) 상태가 추가됐다.

- **외부적인 이유**로 프로세스 수행이 정지된 상태를 나타낸다. 외부에서 재개시키지 않는 이상 다시 활성화되지 않으므로, **메모리 자원이 당장 필요치 않다**.

- 중지 상태의 프로세스는 메모리를 빼앗기고 디스크로 스왑 아웃된다. 그리고 여기에 중기 스케줄러가 관여하는 것

- 세분화하자면 **중지준비** 상태와 **중지봉쇄** 상태로 세분화가 가능하다.
  
  - **준비 상태**에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃되면 중지준비 상태이고,
  
  - **봉쇄 상태**에 있던 프로세스가 스왑 아웃되면 중지봉쇄 상태이다.
    
    - 중지봉쇄 상태의 프로세스가 **봉쇄가 풀릴 조건을 만족하면**, 중지준비 상태로 전환된다.

---

## 프로세스의 생성

시스템 부팅 시의 최초 프로세스는 **운영체제가 직접 생성**하는 게 맞지만, 그 이후부터는 **이미 존재하는 프로세스가 다른 프로세스를 복제 생성**한다.

- 이들은 **부모 프로세스**와 **자식 프로세스** 관계를 형성하여, 프로세스 간 **족보** 같은 계층이 구성된다.

- 부모 프로세스는, 자신의 하위에 달린 자식 프로세스가 **모두 종료되어야** 비로소 종료될 수 있다.

생성된 프로세스가 작업을 수행하기 위한 자원을 획득하는 방법은 운영체제 및 자원의 종류마다 상이하다.

- 운영체제로부터 직접 할당받거나, 부모 프로세스의 자원을 공유하거나.

프로세스가 수행되는 모델도 다양하다.

- 부모 자식이 공존하며 수행되거나, 자식이 종료(terminate)될 때까지 부모가 기다리거나(wait)

- 부모 자식이 공존하며 수행되는 모델에서는, 부모와 자식이 CPU 획득을 위해 **경쟁하는 관계**가 된다.

- 부모가 자식의 종료를 기다리는 모델에서는 자식 프로세스의 종료까지 부모 프로세스는 **봉쇄** 상태에 머무른다.
  
  - 자식 프로세스가 종료되어야 비로소 **준비** 상태로 전환된다.
  
  - 쉘에서 명령어를 수행시키면 해당 명령이 수행될 때까지 쉘이 대기하는 걸 생각하면 된다.

프로세스가 생성되면 자신만의 독자적인 **주소 공간**이 생성된다.

- 자식 프로세스는 부모 프로세스와 별도의 주소 공간을 가지지만, 처음 공간을 생성할 때는 부모 프로세스 주소 공간의 내용을 **그대로 복사해서** 생성한다.

- 자식 프로세스가 다른 프로그램을 수행하려면, 그 위에 새로운 프로그램의 주소 공간을 **덮어씌워** 실행한다.

**유닉스**에서 프로세스가 생성되고 종료되는 절차는 다음과 같다.

- 유닉스는 `fork()` 라는 **시스템 콜**로 새로운 프로세스를 생성한다.
  
  - fork()는 부모 프로세스의 내용을 그대로 복제해 자식 프로세스를 생성한다.
  
  - 프로세스 ID를 제외한 모든 정보가 그대로 복사된댜.

- 자식 프로세스는 `exec()` 시스템 콜을 통해, 새로운 프로그램으로 주소 공간의 내용을 덮어쓰게 된다.

- 부모 프로세스가 종료되기 위해서는 모든 자식 프로세스들이 먼저 종료되어야 한다.
  
  - **자발적 종료**는 프로세스가 운영체제에게 역할 종료를 스스로 통보할 때 이루어진다.
    
    - 정확히는, 코드 상에서 `exit()` 라는 시스템 콜을 넣어서 운영체제를 호출할 수 있는 것.
    
    - `exit()`는 개발자가 명시적으로 코드를 넣지 않아도 **컴파일러**가 자동으로 삽입해 프로세스 종료 직전에 항상 호출이 일어난다.
    
    - 종료를 통보받은 운영체제는 프로세스로부터 자원을 회수한다.
  
  - **비자발적 종료**는 부모 프로세스가 자식 프로세스 수행을 강제로 종료시킬 때 이루어진다.
    
    - `abort()` 라는 함수를 통해 이루어지는데,
    
    - 자식 프로세스가 할당 자원의 한계치를 넘는 자원을 요구하거나, 자식 프로세스에게 할당된 작업이 필요하지 않게 됐거나, **부모 프로세스가 종료되는 경우** 강제종료가 발생한다.
    
    - 부모 프로세스가 종료됐지만 **자식 프로세스가 계속 실행되어야 하는 경우**가 흔하다. 그러한 경우, 종료되지 않을 다른 프로세스의 **양자**로 자식 프로세스를 이양시키는 메커니즘도 존재한다.

자식 프로세스가 생성되는 `fork()` 시스템 콜에 대해 보다 자세히 알아보면,

- 프로세스가 fork()를 보내면 우선 **시스템 콜**이므로 당연히 CPU 제어권이 커널로 넘어간다.

- 커널은 fork()를 호출한 프로세스를 복제해서 자식 프로세스를 생성한다.
  
  - 자식 프로세스는 부모 프로세스의 모든 **문맥**을 공유한다. 
    
    - 주소 공간, 프로그램 카운터, PCB, 커널스택까지 전부.
    
    - 즉 자식 프로세스는 **부모 프로세스가 현재까지 수행한 시점**부터 출발한다. (**프로그램 카운터 지점**)
  
  - 자식 프로세스는 엄밀히 말해 *자식*이라기보다는 *복제*에 가까운 존재다.
    
    - `fork()`를 통해 자식 프로세스를 만들었다는 문맥까지 가지고 있고, 심지어 자기 자신이 복제본을 탄생시킨 **원본**이라고까지 인식한다.
    
    - 딱 하나 다른 점은 `fork()` 함수 결과값이 원본에게 양수, 복제본에게 0이라는 점.

자식 프로세스가 부모와는 다른 독자적인 메커니즘을 수행하려면 그 주소 공간에 **새로운 프로그램을 덮어씌우는** 게 필수적이다. 이를 위해 `exec()` 시스템 콜이 지원된다.

- `exec()` 시스템 콜을 통해 프로세스의 문맥은 완전히 날라가고, 새로운 프로그램의 첫 부분이 실행될 수 있다.

이러한 `fork()`와 `exec()` 등은, 사용자 프로세스가 직접 수행할 수 없는 **특권명령**이다.

즉, 부모 프로세스가 `fork()` 시스템 콜을 보내면, 커널은 `wait()`를 호출해서 **자식 프로세스가 종료될 때까지** 부모 프로세스를 **봉쇄** 상태로 만든다.

- 이러한 방식으로 커널은 부모 프로세스와 자식 프로세스를 **동기화**시키고 있다.

- 자식 프로세스가 종료되면 비로소 **준비 큐**에 재진입하여 CPU 권한을 획득할 수 있게 된다.

---

## 프로세스 간의 협력

프로세스는 각자 독립적인 주소 공간을 가지고, **다른 프로세스의 주소 공간 참조는 허용되지 않는다**. 즉 서로 영향을 미치거나 정보를 주고받을 방법이 없다.

하지만 경우에 따라서는 독립적인 프로세스 간 협력이 효율성 증대에 도움이 될 수 있어, 운영체제는 **프로세스 간 협력 메커니즘**을 제공한다. 이를 통해 프로세스 간에 영향을 미칠 가능성이 생긴다.

대표적인 메커니즘으로 **IPC**(Inter-Process Communication)이 있다.

- IPC는, 하나의 컴퓨터 안에서 실행 중인 **서로 다른 프로세스 간 발생하는 통신**을 말한다.

- 의사소통 기능도 중요하지만, **동기화**의 보장이 매우 중요하다.
  
  - **공유 데이터**를 둘 이상의 프로세스가 접근하면 **데이터 불일치 문제**가 발생할 수 있기 때문.
  
  - 하나의 프로세스가 공유 데이터에 접근하는 동안, 다른 프로세스는 접근하지 못하도록 할 필요가 있다.

- 즉, **프로세스 간 통신**과 **동기화**의 요구를 충족시키는 게 IPC. 대표적인 방법으로 다시 **메시지 전달**과 **공유메모리** 방식이 나뉜다.
  
  - 양자는 **프로세스 사이 공유 데이터 사용 여부**에 따라 나뉜다.

**메시지 전달 방식**은 프로세스 간 공유 데이터를 **일체 사용하지 않고** 메시지를 주고받으며 통신한다.

- 메시지 전달은 **커널**이 해준다.
  
  - 제3의 프로세스에 미칠 악영향을 방지하기 위해 메시지 전달을 **특권명령**으로 규정해둔 것.

- 두 프로세스는 커널로부터 `send(msg)`와 `receive(msg)` 연산을 제공받아, 전달할 메시지를 **시스템 콜** 방식으로 전달할 수 있다.

- 통신을 하고자 하는 두 프로세스는 **커뮤니케이션 링크**를 생성한 후 send, receive를 이용해 메시지를 주고받는다.

- 커뮤니케이션 링크 구현 방법은 물리적인 방법, 논리적인 방법으로 나뉜다.

메시지 전달을 통해 통신하는 방식은, 메시지 전송 대상이 **다른 프로세스**인지, **메일박스**라는 저장공간인지에 따라 **직접통신**과 **간접통신**으로 나뉜다.

- 단, 양자의 차이는 **인터페이스** 정도에 불과하고 내부 구현은 거의 동일하다.

- **직접통신**에서는 통신 대상 프로세스의 이름을 명시적으로 표시한다.
  
  - 이 때 커뮤니케이션 링크는 자동적으로 생성되고, 하나의 링크는 **한 쌍의 프로세스**에게 할당된다.
  
  - 링크는 대부분 **양방향성**이지만 단방향성일 수도 있다.

- **간접통신**에서는 메시지를 메일박스나 포트로부터 전달받는다.
  
  - 각 메일박스는 고유의 ID가 있어서, 메일박스를 공유하는 프로세스 간에만 통신이 가능하다.
  
  - 커뮤니케이션 링크도 메일박스를 공유하는 경우에만 생성된다.
    
    - 하나의 링크가 **여러 쌍에 할당**될 수 있고, 단방향성, 양방향성 모두 가능하다.
  
  - send, receive 연산 외에도 **새로운 메일박스를 생성**하는 연산과 **메일박스를 삭제**하는 연산이 사용될 수 있다.

**공유메모리** 방식은, 프로세스들이 **주소 공간의 일부를 공유**한다.

- 기본적으로 독자적인 주소 공간을 가지고 있지만, 이 주소 공간이 물리적 메모리에 매핑될 때 공유메모리 주소 영역에 대해서는 **동일한 물리적 메모리 주소로 매핑**시키는 방식.

- 운영체제가 공유메모리를 사용하는 **시스템 콜**을 지원하여, 서로 다른 프로세스들이 공유메모리 영역에 접근하여 읽고 쓰는 방식으로 협업을 수행한다.

- 프로세스 간 통신이 수월하지만, 당연히 데이터 일관성 문제가 발생할 수 있다.
  
  - 그리고 이걸 **커널이 책임지지 않기 때문에**, 프로세스가 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 한다.
