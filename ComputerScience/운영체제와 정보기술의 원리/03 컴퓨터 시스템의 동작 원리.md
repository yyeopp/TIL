# Chapter 03: 컴퓨터 시스템의 동작 원리

---

## 컴퓨터 시스템의 구조

컴퓨터 시스템은 **컴퓨터 내부장치**인 CPU, 메모리와 **컴퓨터 외부장치**인 디스크, 키보드, 마우스, 모니터, 네트워크 장치로 구성된다.

컴퓨터 업무는 기본적으로, 외부장치에서 내부장치로 데이터를 읽어와(**input**) 각종 연산을 수행하고 결과를 외부장치로 다시 내보내는(**output**) 과정이다. 

- 그런 측면에서 컴퓨터 외부장치를 **입출력 장치**라고 부를 수도 있다.

기본적으로 연산은 CPU에서 이루어지지만, 메모리 및 입출력 장치 등 각 하드웨어 장치에는 **컨트롤러**가 붙어있다.

- 컨트롤러는 작은 CPU로, 각 하드웨어를 제어한다.

이러한 구조 속에서 **운영체제**는, 여러 프로그램이 **동시에** 수행되는 **시스템**을 위한 운영체제다.

- 프로그램이 수행되려면 메모리에 올라가 있어야 하는데, 운영체제는 부팅 이후부터 항상 수행되면서 각종 자원들을 관리해야 하므로 **항상** 메모리에 올라가 있다.

- 운영체제의 모든 코드를 메모리에 올릴 필요는 없으므로, 그 중 핵심적인 부분만 상주하게 되고 이를 **커널**이라 한다.

---

## CPU 연산과 I/O 연산

입출력 장치들의 I/O 연산은 입출력 **컨트롤러**가 담당하고, 컴퓨터 내 수행되는 연산은 메인 CPU가 담당한다.

- 이 때 입출력 장치와 메인 CPU는 동시 수행이 가능하다. 두 가지 일이 서로 다른 곳에서 발생하기 때문.

각 장치에 설치된 **장치 컨트롤러**에는 장치로부터 들어오고 나가는 데이터를 **임시로 저장**하기 위한 작은 메모리를 가지고 있는데, 이를 **로컬 버퍼**라고 한다.

내부장치에서 실행 중인 프로그램이 디스크에서 데이터를 읽어오고자 하는 경우,

- **디스크 컨트롤러**는 디스크에서 내용을 읽어 자신의 **로컬 버퍼**에 저장한다.

- 메인 CPU는 *컨트롤러가 로컬 버퍼로 데이터를 읽어오는 작업*이 끝났는 지 지속적으로 체크하지 않는다.

- 대신, 디스크 컨트롤러가 작업이 완료되면 **인터럽트**를 발생시켜 CPU에 보고하게 된다.
  
  - 인터럽트는 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법이다.

- 기본적으로 CPU는 매 시점 메모리에서 명령을 하나씩 읽어서 수행하는데,

- CPU 옆에는 **인터럽트 라인**이 있어서 CPU가 작업을 수행하던 중 인터럽트 라인에 신호가 들어오면 **하던 일을 멈추고** 인터럽트를 처리하게 된다.
  
  - 보다 정확히는, CPU는 **명령 하나를 수행할 때마다** 인터럽트 발생 여부를 확인한다.

- 인터럽트 발생이 확인되면, CPU는 메모리의 다음 명령을 수행하기 전에 인터럽트를 처리한다.

---

## 인터럽트의 일반적 기능

운영체제의 커널에는 인터럽트가 들어왔을 때 해야 할 일이 이미 프로그래밍되어 있다.

- 이를 **인터럽트 처리 루틴**이라고 하는데, 운영체제가 해야 할 일 중 **사용자 프로그램**에 필요한 서비스를 담고 있다고 볼 수 있다.

- 인터럽트 처리 루틴은, 로컬 버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령 수행이 가능함을 **표시**해두는 한다.

인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 구분된다.

- 양자는 인터럽트 라인에 신호를 보내는 방식이 동일하다.

- 하지만 **하드웨어** 인터럽트의 경우 컨트롤러 같은 **하드웨어** 장치가 CPU의 인터럽트 라인을 세팅하는 반면,

- **소프트웨어** 인터럽트는 소프트웨어가 그 일을 수행한다는 차이가 있다.

운영체제는 인터럽트 발생 시 그 처리를 위해 정의된 코드(**인터럽트 처리 루틴**, **인터럽트 핸들러**)를 찾게 되는데, 코드를 쉽게 찾아가기 위해 **인터럽트 벡터**를 가지고 있다.

- 인터럽트 벡터는 인터럽트 종류마다 **번호**를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 **자료구조**이다.

인터럽트 처리 루틴으로 해당 인터럽트를 처리하고 나면 원래 수행하던 작업으로 돌아가 **중단되었던 일을 계속**한다.

- 이 때 돌아갈 위치를 알아둬야 하므로 수행 중이던 작업을 **저장**해둬야 하는데, 운영체제가 별도로 가지고 있다.

### 소프트웨어 인터럽트의 경우

통상적인 인터럽트는 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 **트랩**(trap)이라는 별도의 용어로 지칭되는 편이다.

트랩의 예시로는 **예외상황**(exception)과 **시스템 콜**(system call)이 있다.

- 예외상황은, 사용자 프로그램이 /0 연산 등 **비정상적인 작업**이나, 자신의 메모리 영역 바깥에 접근하려는 시도 등 **권한이 없는 작업**을 시도할 때 이를 처리하기 위해 발생시키는 인터럽트이다.

- 시스템 콜은, 사용자 프로그램이 **운영체제 내부에 정의된 코드**를 실행시키고 싶을 때 **운영체제에 서비스를 요청**하는 방법이다.
  
  - 운영체제 커널에 있는 코드를 사용자 프로그램이 실행하고자 할 땐, **인터럽트 라인 세팅**을 통해 **CPU 제어권을 운영체제로 넘겨** 실행하는 것이다.
  
  - I/O 작업이 대표적이다. 입출력 수행 코드는 프로그램 수준이 아니라 커널 수준에 존재하므로, 커널에 인터럽트를 보내는 게 필수적이다.

양자는 공통적으로 사용자 프로세스로부터 **CPU의 제어권이 운영체제에 이양**되어 처리된다는 게 중요하다.

- 그 방식을 구체화하면 결국 **인터럽트 라인 세팅**을 통해 인터럽트를 발생시키는 것이므로,

- 트랩이 인터럽트의 범주에 포함되는 것이다.

---

## 인터럽트 핸들링(interrupt handling)

인터럽트 핸들링(인터럽트 처리 루틴)은, 인터럽트가 발생한 경우 처리해야 할 일의 절차를 의미한다.

- CPU에서 명령이 실행될 때는 CPU 내부 **임시 기억장치**인 **레지스터**에 데이터를 읽고 쓰면서 작업을 하는데,

- 인터럽트를 처리하면 기존 레지스터 값이 전부 지워지게 되므로 CPU 내에 레지스터 상태 및 기존 명령의 메모리 주소 등 여러 부가 정보들을 저장해둬야 한다.

운영체제는 현재 시스템 내에서 실행 중인 프로그램들을 관리하기 위해 **프로세스 제어블록**(Process Control Block, **PCB**)라는 자료구조를 둔다.

- PCB는 각 프로그램마다 하나씩 존재하며, 해당 프로그램의 **어느 부분이 실행 중이었는지**를 저장한다.
  
  - 실행 중이던 코드의 메모리 주소, 레지스터 값, 하드웨어 상태 등을 저장한다.

즉 정리하면,

- 프로그램 실행 중 인터럽트 발생 시,

- 프로그램의 실행 상태는 PCB에 저장되고 CPU 제어권이 인터럽트 처리 루틴으로 넘어간다.

- 인터럽트 처리가 끝나면 저장된 상태가 PCB로부터 CPU에 복원되어, 다시 실행이 이어진다.

이러한 구조가 발전한 결과, 결과적으로 오늘날의 컴퓨터에서 운영체제는 **인터럽트가 발생할 때에만 실행**되고 있다.

시스템 부팅 후 정상 상태에 도달하면 사용자 프로그램이 계속 CPU를 사용하면 되기 떄문.

인터럽트가 발생할 때에만 운영체제 코드 부분으로 CPU가 이양되어 인터럽트 처리를 수행한다.

---

## 입출력 구조

입출력은, 컴퓨터 시스템이 외부 입출력 장치륻과 데이터를 주고받는 것이다.

그 방식에는 **동기식** 입출력과 **비동기식** 입출력이 있다.

### 동기식 입출력(synchronous I/O)

동기식 입출력은, 어떤 프로그램이 입출력 요청을 했을 때 그 작업을 **완료한 후에야** 그 프로그램이 후속 작업을 수행할 수 있게 하는 방식이다.

- 입출력이 완료되어 **인터럽트**를 통해 그 사실이 전달된 후에야, 해당 프로그램으로 **CPU 제어권이 돌아가는** 방식이다.

- 결과적으로 CPU는 외부 장치에서의 입출력 언산이 끝날 때까지, 그 인터럽트를 기다리며 자원을 낭비하게 된다.

이를 보완하는 방식으로는 일반적으로, 프로그램 입출력 수행 중 **CPU를 다른 프로그램에 이양해 CPU가 쉬지 않을 수 있도록** 하고 있다.

- 이러한 태스크를 관리하기 위해 운영체제는 프로그램을 몇 가지 **상태**로 나누고,

- 입출력 중인 프로그램에 대해서는 그 중 **봉쇄 상태**(blocked state)로 전환시킨다.
  
  - 봉쇄 상태의 프로그램에는 CPU를 할당하지 않는다.

#### 동기성(synchronization)의 문제

CPU를 다른 프로그램에 이양해주는 방식을 사용하지 않으면, 매 시점 시스템 내에서는 오직 **하나의 입출력 연산만** 수행이 가능하다.

- **동기화**가 자동으로 발생하는 이점이 있다.

하지만 CPU를 양도함으로써 **다수의** 입출력 연산이 이루어질 수 있게 되는데, 여기서 **동기화**의 문제가 발생한다.

- 서로 다른 프로그램이 디스크 상 하나의 데이터를 각기 다른 방향으로 변형시키는 입출력 연산을 입력했으나 시점 상 해당 연산이 **동시에** 수행할 때,

- 아무런 질서가 없다면 장치 **컨트롤러**는 본래 사용자가 의도한 입출력 연산의 순서를 바꾸어 잘못된 결과를 초래할 수 있다.

동기식 입출력에서는, 입출력 요청의 **동기화**를 위해 장치별로 **큐**를 두어 요청한 순서대로 처리할 수 있도록 하고 있다.

- 각 장치에는 **큐헤더**가 존재하여 입출력 수행 순서를 지켜주기 위한 큐를 관리하고 있다.

- 장치 **컨트롤러**는, 이 순서에 따라 매 시점 **하나씩** 주어진 입출력 작업을 처리하게 된다.

- 물론 단순히 순서대로만 처리하는 대신, 요청들을 모으고 처리 순서를 *적절히* 바꾸어 입출력의 효율성을 높일 수도 있는데, 따로 자세한 논의가 필요하다.

#### 입출력 종료

요청된 입출력 연산이 완료되면, **인터럽트**의 형식으로 CPU에게 입출력이 완료되었음을 통보한다.

운영체제 커널이 **인터럽트 처리 루틴**으로 가서, 입출력 연산을 끝낸 프로그램이 이제 **CPU를 할당받을 수 있도록** 프로그램의 상태를 **봉쇄 상태로부터 해제**시키는 것으로 종료된다.

### 비동기식 입출력

비동기식 입출력은, 입출력 연산을 요청한 후 연산이 끝나기를 **기다리지 않고** **CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여**하는 방식이다.

프로그램이 입출력 연산을 요청했을 때 경우에 따라서는 그 결과물에 관계 없이 다음 작업을 수행할 수 있을 수 있다.

비동기식 입출력에서는 *그게 가능한* 작업들을 **먼저** 수행하고, 입출력 연산의 결과물이 *반드시 있어야 하는* 작업들을 그 이후에 수행하는 방식을 사용한다.

여기서도 입출력 연산이 완료되면, 장치 컨트롤러는 마찬가지로 **인터럽트**를 통해 CPU에게 알려주고 프로그램이 입출력 연산 결과물을 전달받는다.

그리고 그 시점부터 프로그램은 입출력 결과물을 필요로 하는 명령들을 수행한다.

### 정리

일반적으로 운영체제는 **동기식 입출력**을 사용하고 있다.

장치별로 입출력 처리를 기다리는 프로세스를 **줄 세워 관리**함으로써, **동기성을 보장**하는 것이다.

**구체적인 예시**를 순서대로 들어보자.

- 프로그램 A 실행 중에 디스크에서 데이터를 읽어오는 명령을 만남

- 프로그램 A는 **시스템 콜**(**트랩**, **소프트웨어 인터럽트**)을 통해 CPU에게 이를 전달

- CPU는 지금까지 프로그램 A를 실행하던 상태를 **PCB에** 저장하고, **인터럽트 처리 루틴**으로 이동(**커널 수준**)

- CPU가 **컨트롤러**에게 입출력 연산을 요청
  
  - 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 **로컬 버퍼**로 읽어옴
  
  - 한편, 그동안 운영체제는 프로그램 A를 **봉쇄 상태**로 표시하여 A에는 CPU가 다시 할당되지 못함
  
  - 대신 그동안 CPU를 다른 프로그램 B로 할당
  
  - 원하는 정보가 로컬버퍼에 다 들어오면, 컨트롤러는 **인터럽트**(**하드웨어 인터럽트**)를 발생시켜 CPU에게 이를 알림

- 프로그램 B를 수행 중이던 CPU는 마찬가지로 상태를 **PCB**에 저장하고 해당 인터럽트를 처리

- 인터럽트 처리 루틴이 로컬 버퍼에 있는 데이터를 A의 메모리 영역으로 읽어오고, A의 **봉쇄 상태를 해제**시켜 CPU 할당이 가능함을 표시

- A는 다시 CPU를 기다리는 줄에 설 수 있게 됨

- CPU는 다시 프로그램 B로 돌아가 하던 업무를 수행하고,

- A에게 차례가 돌아오면 CPU를 할당받아 입출력 연산 이후의 작업을 수행함.

---

## DMA(Direct Memory Access)

원칙적으로 메모리는 CPU에 의해서만 접근 가능한 장치다.

다른 장치가 메모리의 데이터에 접근하려면 **CPU에게 인터럽트를 발생시켜** CPU가 이를 대행하는 방식으로만 가능하다.

하지만 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우, 지나치게 **잦은 인터럽트**에 의해 CPU 사용의 효율성이 떨어지는 문제점이 발생한다.

- 특히 위 예시와 같이, 입출력 장치의 데이터를 **로컬 버퍼에서 메모리로 옮기는 경우**가 잦음

이러한 비효율을 극복하기 위해 메모리 접근이 가능한 장치를 하나 더 두는 경우가 많은데, 그것을 DMA라고 한다.

- DMA는 일종의 **컨트롤러**로, CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할을 한다.

- 특히 로컬 버퍼에서 메모리로 데이터를 옮기는 작업을 DMA가 대행하게 된다.

DMA는 CPU처럼 **바이트** 단위로 데이터를 읽어오는 것이 아닌 **블록**(block)이라는 큰 단위로 데이터를 메모리에 읽어온 후, **CPU에게 인터럽트를 발생시켜** 해당 작업의 완료를 알려준다.

- 그것만으로도 CPU에 발생하는 인터럽트의 빈도가 크게 줄 수 있고,

- CPU의 효율적 관리 및 빠른 입출력 연산이 가능하다.

---

## 저장장치의 구조

컴퓨터 시스템을 구성하는 저장장치는 **주기억장치**와 **보조기억장치**로 나뉜다.

- 주기억장치를 보통 **메모리**라 한다. 전원이 나가면 내용이 전부 지워지는 **휘발성**의 **RAM**을 주로 사용한다.

- 보조기억장치를 보통 **디스크**라 한다. 전원이 나가도 저장된 내용을 기억할 수 있는, **비휘발성**의 **마그네틱 디스크**를 주로 사용한다.
  
  - 플래시 메모리, CD, 마그네틱 테이프도 모두 이 쪽이다.

보조기억장치의 용도는 크게 두 가지다.

- **파일 시스템**(file system) 용.
  
  - 전원이 나가도 유지해야 할 정보가 있으면, 그것을 **파일** 형태로 보조기억장치에 저장한다.

- **메모리의 연장 공간**인 **스왑 영역**(swap area) 용
  
  - 메모리는 크기가 한정적이고, 비싸다.
  
  - 다수의 프로그램이 동시에 수행되는 현대 컴퓨터 환경에서는, 메모리 공간이 부족한 경우가 매우 흔하다.
  
  - 이 때 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고, 그렇지 않은 부분은 **디스크의 스왑 영역에 내려놓는** 방식을 사용한다.
    
    - 이를 **스왑 아웃**(swap out) 시킨다고 한다.
  
  - 스왑 아웃된 부분이 다시 필요하면 메모리 영역으로 올려서 사용하면 된다.
  
  - 이러한 스왑 영역은 어디까지나 메모리의 연장 공간으로서 역할하기 때문에, **비휘발성 용도**가 아닌 점에서 구분이 필요하다.

대표적인 보조기억장치인 하드디스크에는 여러 마그네틱 원판들이 있고, **암**(arm)이 이동하면서 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작한다.

- 디스크 원판 표면은 **트랙**으로 나뉘고, 각 트랙은 **섹터**로 나뉜다.

- 섹터에 **최소한의 단위 정보**가 저장된다.

---

## 저장장치의 계층 구조

저장장치의 계층 구조는 **속도**를 기준으로 나눌 수 있다.

당연하지만 속도는 가격에 비례하고, 그 때문에 용량과 반비례한다.

즉, 컴퓨터 시스템에서 **당장 필요한** 정보는 빠른 저장장치에 넣어 **수행 속도**를 높이고, 그렇지 않은 정보는 상대적으로 느린 저장장치에 보관하는 방식이 요구된다.

본격적인 계층 구조는 아래와 같다.

- Primary (**휘발성**)
  
  - 레지스터
  
  - 캐시 메모리
  
  - 메인 메모리

- Secondary (**비휘발성**)
  
  - 마그네틱 디스크
  
  - 광디스크
  
  - 마그네틱 테이프

**캐시 메모리**는 레지스터와 메인 메모리 사이에 존재하는데, **캐싱 기법**을 적용함으로써 적은 용량을 가짐에도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 동작하도록 하고 있다.

### 캐싱 기법

캐싱 기법은, 상대적으로 용량이 적고 빠른 저장장치를 이용해 용량이 크고 느린 저장장치의 성능을 향상시키는 **총체적 기법**을 뜻한다.

이는 느린 저장장치에 있는 내용 중 **당장 사용**되거나 **빈번히 사용될** 정보를 빠른 저장장치에 **선별적으로 저장**함으로써, 두 저장장치 사이의 속도를 **완충**시키는 방법이다.

- 필요한 정보를 느린 저장장치까지 **가지 않고도** 빠른 저장장치에서 곧바로 찾고 끝낼 수 있어서, 전체적인 성능이 향상되는 것이다.

캐싱 기법을 컴퓨터 시스템 내 다양한 저장장치 계층에서 활용함으로써, 적은 용량의 **상위 저장장치**만으로도 대부분 빠른 수행 속도의 성능을 얻어낼 수 있다.

---

## 하드웨어의 보안

### 운영체제의 하드웨어 보안 기법

흔히 사용되는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 **다중 프로그래밍** 환경에서 동작한다.

이 때 서로 다른 프로그램 간의 충돌을 막기 위해서는, **하드웨어에 대한 보안** 기법이 필요하다.

운영체제는 하드웨어 보안을 유지하기 위해 기본적으로 **커널모드**와 **사용자모드**의 두 가지 모드를 지원하고 있다.

- 커널모드는 **운영체제가 CPU 제어권을 가지고** 운영체제의 코드를 실행하는 모드로, **모든 종류의 명령을** 다 실행할 수 있다.

- 사용자모드는 **일반 사용자 프로그램**이 실행되며, **제한적인 명령**만 수행할 수 있다.

- 즉, 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행되도록 하여, 하드웨어 보안을 유지할 수 있다.

#### 모드비트(mode bit)

중요한 연산을 커널모드에서만 수행하도록 정의하더라도, 일단 CPU를 할당받은 사용자 프로그램이 프로그램 내에서 그런 종류의 연산을 수행해버리면 달리 방법이 없다.

아무리 운영체제라고 해도 CPU를 가지고 있지 않으면 코드 실행이 불가하므로, 사용자 프로그램을 감시할 수도 없기 때문이다.

이러한 상황을 방지하기 위한 하드웨어적 지원이, CPU 내부에 두는 **모드비트**이다.

모드비트는 **사용자 프로그램을 감시**하는 역할을 수행한다.

- 모드비트가 0으로 세팅되면 **커널모드**로서 모든 명령을 수행할 수 있고,

- 1로 세팅되면 **사용자모드**로 제한된 명령만을 수행할 수 있다.

CPU는 보안과 관련된 명령을 수행하기 전에, **항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만** 명령을 수행하고 있다.

- 운영체제는 CPU를 점유해 자신의 코드를 수행하다가, (모드비트 0 상태)

- 사용자 프로그램에게 CPU 제어권을 넘길 때 모드비트를 1로 세팅해 넘기면 된다.

**인터럽트**가 발생할 때만 운영체제가 자신의 코드를 작동시키므로, 인터럽트 시 모드비트는 **자동으로 0이 세팅**된다.

- 물론 요청된 작업이 모두 끝나면 모드비트를 다시 1로 만들어 CPU를 돌려준다.

이와 같이 시스템의 보안과 관련된 명령들을 **특권명령**이라 지칭하며, 특권명령은 **모드비트가 0일 때에만 수행할 수 있다.**

### 하드웨어 장치에서의 보안 기법

디스크를 예시로 들 때, 사용자 프로그램이 디스크에 저장된 파일에 자유롭게 접근하면 보안상 문제가 발생할 수 있다.

그래서 **모든 입출력 명령**은 **특권명령으로 규정되어 있다.**

입출력이 필요한 사용자 프로그램이 운영체제에 **시스템 콜**(트랩)을 넣는 것을 그 일환으로 해석할 수 있다. 애초에 주변 장치에 대한 입출력 명령이 **특권명령**이고 **모드비트 0**이 요구되므로 사용자 프로그램 선에서 수행 불가능하기 때문.

운영체제는, 입출력 요청이 올바른 요청인지 확인한 후 입출력을 실행하기 때문에 디스크 속 파일에 대한 보안을 유지할 수 있다.

---

## 메모리 보안

메모리에는 여러 프로그램이 동시에 올라가서 실행되기 때문에, 프로그램 간 **메모리 영역 침범**을 철저히 예방하는 것이 중요하다.

적어도, **인터럽트 벡터**와 **인터럽트 처리루틴**이 있는 곳은 각별한 보안이 요구된다.

- 사용자 프로그램이 인터럽트 처리루틴에 접근할 경우, 원칙적으로 운영체제만 수행할 수 있는 **특권명령**이 변질될 수 있기 때문.

이를 해결하기 위해, 2개의 **레지스터**를 사용하여 프로그램이 접근하려는 메모리 부분이 합법적인지 체크하고 있다.

- **기준 레지스터**(base register)와 **한계 레지스터**(limit register)를 사용한다.

#### 기준 레지스터와 한계 레지스터

**기준 레지스터**는, 어떤 프로그램이 수행되는 동안 해당 프로그램이 **합법적으로 접근할 수 있는** 메모리상의 **가장 작은 주소**를 보관하고 있다.

**한계 레지스터**는, 그 프로그램이 기준 레지스터값부터 접근할 수 있는 **메모리의 범위**를 보관하고 있다.

- 어떤 프로그램이 메모리에 올라갈 때, 메모리에 올라간 부분의 **시작 주소**와 해당 **프로그램의 길이**를 레지스터에 보관하고,

- **메모리 접근 연산**이 있을 때마다 **하드웨어적으로** 접근하려는 위치가 합법적인 범위 내에 있는지 체크하는 것이다.

- 결과적으로, 사용자 프로그램이 접근 가능한 메모리 영역은 (기준 레지스터 ~ 기준 레지스터 + 한계 레지스터)이다.

불법적인 메모리 접근이 발생하면, **예외상황**이라는 소프트웨어적 **인터럽트**가 발생한다.

- 예외상황은 운영체제에 **소프트웨어 인터럽트**를 발생시켜, CPU의 제어권을 **운영체제로 이양**시키고 운영체제가 예외상황을 발생시킨 프로그램을 **강제로 종료**시킨다.

단, 이러한 메모리 보호 기법은 하나의 프로그램이 메모리 한 영역에 연속적으로 위치하는, 아주 단순한 메모리 관리 기법을 사용하는 경우에만 가능하다.

- 하나의 프로그램이 메모리 여러 영역에 나뉘어 위치하는 **페이징 기법** 등이 적용된 상황에서는, 또 다른 방법이 필요하다.

메모리 접근 연산은, 사용자 프로그램이 **CPU**를 가지고 있는 동안 수행할 수 있는 연산이르모 특권명령이 아니다.

- 하지만, 하드웨어적으로 그 접근이 합법적인지 여부를 체크하여 메모리를 보호한다.

- 레지스터값을 세팅하는 연산은 **특권명령**인데, 사용자 프로그램이 자신의 레지스터값을 직접 변경할 수 있다면 메모리 보호 기능이 사실상 무의미해지기 때문.

- 운영체제는 프로그램 실행 시점에 2개의 레지스터값을 **직접 세팅해준다.** 

---

## CPU 보호

싱글 코어를 가정할 때, 특정 프로그램이 CPU를 부적절한 방법으로 독점하고 있으면 다른 프로그램이나 운영체제는 CPU를 가져올 수 없어 시스템이 마비될 수 있다.

이를 막기 위해, 운영체제는 **타이머**(timer)라는 하드웨어를 사용한다.

타이머는 정해진 시간이 지나면 인터럽트를 발생시켜, 운영체제가 **CPU의 제어권을 획득할 수 있도록**하는 역할을 수행한다.

- 일정한 시간 단위로 세팅될 수 있고, 매 클럭 틱 때마다 1씩 감소한다.

- 타이머가 0이 되면 인터럽트가 발생한다.

- 타이머의 값을 세팅하는 명령을 **로드 타이머**(load timer)라고 하는데, **특권명령**에 해당한다.

타이머는 **시분할 시스템**에서 **현재 시간을 계산하기 위해**서도 사용되는데,

시분할 시스템이란 여러 프로그램이 CPU의 시간을 조금씩 나누어 사용하는 것을 말한다. 

- 오늘날 대부분의 컴퓨터가 이에 해당한다.

---

## 시스템 콜을 이용한 입출력 수행

입출력 명령은 특권명령으로, 운영체제 코드에 구현되어 있다.

사용자 프로그램은 운영체제에게 **시스템 콜**이라는 서비스 대행 요청을 하여 입출력을 수행한다.

- 시스템 콜은 **소프트웨어 인터럽트**로서, **트랩**을 발생시켜 CPU 제어권이 사용자 프로그램에서 운영체제로 넘어간다.

- 운영체제는 해당 시스템 콜을 처리하기 위한 인터럽트 처리루틴으로 이행한다.

- 
