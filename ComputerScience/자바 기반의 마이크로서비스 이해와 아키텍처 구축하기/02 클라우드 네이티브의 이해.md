# Chapter 02: 클라우드 네이티브의 이해

---

클라우드 네이티브는, **클라우드 환경에 친화적인** 애플리케이션, 아키텍처, 인프라 등의 환경을 뜨한다.

**클라우드 네이티브라는 기술 환경**은 *기술에 의한 비즈니스*라는 패러다임 전환에 견인차 구실을 하고 있다. 마이크로서비스 또한 그러한 맥락에서 등장한 아키텍처.

즉, 클라우드 네이티브 기술 환경에 대한 이해가 갖춰질 필요가 있다. 특히 그 중에서도 **도커** 환경에 대한 이해가 중요하다.

---

## 클라우드 네이티브

### 클라우드 네이티브 애플리케이션

클라우드 네이티브 애플리케이션은, 비즈니스 환경 변화에 능동적으로 대응하기 위해 **클라우드 네이티브 환경**에서 **SaaS**나 **FaaS** 형태로 서비스되는 애플리케이션을 의미한다.

- Software as a Service

- Function as a Service

- 민첩 / 유연 / 효율적 서비스 구현을 위해, 클라우드 네이티브 환경에서 **여러 개의 마이크로서비스로 구성된** 서비스 애플리케이션이 SaaS나 FaaS 형태로 제공된다.

#### 마이크로서비스

아주 작은 서비스로, **클라우드 환경**에 잘 맞는다.

- 클라우드 자체가 **즉시성과 유연성**을 특징으로 하는 서비스이기 때문. 

- 서비스가 작고 독립적일수록, 클라우드 환경의 장점을 활용하기에 적합하다.

마이크로서비스는 **2주 안에 독립적으로 개발해서 배포가 가능한 크기**를 권고한다.

- 크기가 작고 쉽게 조립할 수 있는 구조를 통해, 필요에 의해 적절히 확장 / 축소시킬 수 있다.

- 클라우드 인프라 환경, 도커 등의 컨테이너 환경은 **격리된 환경**을 제공하는 것, **서비스 생성 및 삭제**하는 것을 매우 쉽게 만들어 MSA 구성을 가능케 했다.

#### SaaS

소프트웨어가 필요할 때, **즉시 필요한 만큼만 사용**할 수 있는 **서비스 형태의 소프트웨어**이다.

마이크로서비스는 SaaS형 애플리케이션 개발 및 활용에 있어서 최적의 서비스 형태이다.

- 클라우드에 인프라 장비와 플랫폼을 위치시키고, 반복적으로 자주 사용되는 서비스들을 SaaS 형태로 공용화하여 서비스하는 식.

- 사용한 만큼만 비용이 발생하므로, 사용자 입장에서 **운영 비용** 부담이 줄고, **즉시 사용** 가능한 이점이 있다. 

대신, 기존 모놀리스 환경의 애플리케이션 개발과 다른 사상이 가지고 개발되어야 한다.

- 기존 애플리케이션이 **맞춤형**이라면,

- SaaS는 **불특정 다수**가 사용하는 서비스이므로 **가용성**과 **소스 버전 관리**가 중요하다.

#### 12팩터

SaaS가 가져야 할 특성과 지켜야 할 패턴들에 대한 경험적인 내용을 정리한 것.

**클라우드 네이티브 애플리케이션으로서의 마이크로서비스**를 개발하고 운영할 때, 구현 측면에서 좋은 모델이 될 수 있다.

##### [1] 코드베이스

하나의 애플리케이션은 하나의 코드베이스를 가지고, **버전으로 추적 관리**되어야 한다.

- 저장소 내 원천 소스는 오직 하나고, 컴파일되어 여러 phase의 서버 환경에 배포될 수 있다.

##### [2] 종속성

프로그램에 사용하는 라이브러리들에 **암묵적인 종속성**이 발생하지 않아야 한다.

- 명시적 종속성이 아닌 경우 오류 유발의 원인이 될 수 있다.

##### [3] 환경 설정

코드에서 사용하는 configuration 정보는 코드와 **완전히 분리되어 관리**되어야 한다.

- DB 연결 정보, 호스트명, 백엔드 리소스 정보 등.

- 환경 변수로 관리하고, 코드가 그에 종속되지 않도록 한다.

##### [4] 백엔드 서비스

백엔드 서비스는 모두 **리소스**로 취급한다.

- 데이터베이스나 메시지 큐 같은 시스템들.

- 이들을 연결하거나 분리할 때, 애플리케이션 코드를 수정하지 않아야 한다.

백엔드 서비스를 구별하기 위한 **리소스 식별자**는 **URI**여야 한다.

##### [5] 빌드, 릴리스 및 실행

소스 코드는 **빌드, 릴리스, 실행** 단계로 분리되어 운영된다.

##### [6] 프로세스

프로세스는 **무상태**(stateless)로 실행되며, **상태 정보를 공유하지 않아야** 한다.

- 상태 정보를 **영구 보관**하려면, **캐싱**이 아닌 **DB**를 사용해야 한다.

- 현재 수행되는 프로그램의 실행에 집중할 뿐, 데이터 캐싱으로 다음 수행 때 참조하는 일이 없어야 한다.

##### [7] 포트 바인딩

애플리케이션은 하나의 독립된 서비스로 **외부에서 접속할 수 있도록** 포트를 이용해 구분되어야 한다.

- **포트로 바인딩**된 독립된 서비스들은, **다른 서비스의 백엔드 서비스로 활용 가능**하다.

##### [8] 동시성

특정 서비스에 시스템 부하가 발생할 때, 하드웨어를 스케일업하는 것이 아닌 **프로세스의 워크로드를 수평 확장**할 수 있는 형태여야 한다.

##### [9] 폐기 가능

**Graceful shutdown**이 보장되어야 한다.

즉, 예상치 못한 시스템 상황에서도 프로세스가 비정상 종료되지 않도록 **논리적인 대응 메커니즘**을 가져야 한다.

- 프로세스 기동 시간은 최소화하고, 종료 시의 안전성을 보장해야 한다.

##### [10] 개발, 테스트, 운영 환경의 일관성

개발 환경은 **테스트나 운영 환경과 최대한 같아야** 한다.

- 각 phase 간 발생하는 문제를 최소화하고, **지속 배포**가 가능한 환경을 만들 수 있다.

##### [11] 로그

로그는 **스트림 이벤트**로 취급해, 애플리케이션에서 로그 처리에 관여 / 가공 / 관리하지 않도록 해야 한다.

대신 이를 수집 전달하는 오픈소스를 이용해 관리한다.

##### [12] 일회성 프로세스

일회성 작업은 구분하여 **별도의 프로세스로 구성**한다.

#### FaaS

Function as a Service는, 서비스의 수준을 **기능 단위까지 세분하여 제공**하는 **기능 서비스**이다.

기능 단위를 필요할 때 **즉시 사용**할 수 있고, **기능들의 조합**을 통해 새로운 서비스를 만들 수 있다.

- 클라우드 플랫폼 사업자들이 AI, 빅데이터 분석, 챗봇 같은 기능들을 필요 시 플랫폼에 업로드해서 사용하고, 이에 따른 비용을 지급한다.

- **품질과 속도** 측면에서 장점이 크다.
  
  - 직접 개발할 필요가 줄어들고, 누군가 미리 만들고 검증된 결과물을 사용하기 때문

### 클라우드 네이티브 아키텍처

#### 확장 가능한 아키텍처

모놀리스 구조라면, 애플리케이션이 클라우드의 **하나의 인스턴스**에서 실행된다.

- 시스템 부하 발생 시 인스턴스를 **수평적으로 확장**시키는 게 구조적으로 매우 어렵다.

- 아키텍처팀이 SI 프로젝트를 진행한다고 하면, 설계 단계에서 **과거 지표**를 바탕으로 시스템 용량을 산정해 시스템을 설계하는 것이 매우 중요해진다.
  
  - 예상보다 많은 부하가 발생하여 장애가 발생하면 안 되므로, 시스템 구성을 이중 / 삼중화하는 등 여러 대책이 마련된다.

반면 클라우드 네이티브 아키텍처는 시스템의 **수평적 확장**에 훨씬 유연하다.

- 필요에 따라 수평으로 유연하게 증감시키는 식으로 장애에 대응하면, 설계도 쉽고 비용도 적다.

- **서비스의 연속성을 보장**하는 측면에서도 의미가 있다.

- 대신, 서비스의 **상태**를 **마이크로서비스 단위까지** 지속적으로 인지하고 모니터링하는 것이 매우 중요해진다.

#### 탄력적 아키텍처

서비스의 **생성-통합-배포**로 이어지는, **환경 변화에 따른 대응**에 있어서 그 시간을 단축하고 오류 예측 및 적절한 대응에 능한 아키텍처 구조이다.

- **분산 병렬 처리**, **수평적 확장**, **무상태 통신 방식**, **자동 복원 능력** 등이 지원되어야 한다.

모놀리스 환경에서는 장애 대응에 있어서 **스케일업** 위주의 아키텍처와 **백업 및 복구** 같은 시스템적 메커니즘을 주로 고려한다.

- 시스템 성능의 임계치를 사전에 예측해 그에 부합하는 하드웨어를 도입하고,

- 장애 상황에 대비한 **재해 복구 시스템**을 구축하는 식.

반면 클라우드 네이티브 아키텍처는 **수펑적 시스템 확장**에 초점을 맞춘다.

- **최소한의 시스템 사양**으로 운영하고, 예기지 못한 오류는 **수용할 수 있는 구조**로 설계해, 최소의 영향으로 **복원**이 가능한 구조를 만드는 데 중점을 둔다.

- 이를 위해 아래와 같은 고려가 필요하다.

##### 분할된 서비스 구조

**상호 결합도를 최소화**하여, 장애를 격리시킨다.

장애가 난 서비스의 크기가 작을수록, 빠르게 수정 배포하여 대응할 수 있다.

##### 무상태 통신 프로토콜의 구성

통신을 **비동기적으로 처리**하여, 클라이언트와 서버 간 동작 상태 정보를 저장하지 않도록 한다.

- 장애 격리가 가능하고, **가용성** 측면에서도 유용하다.

##### 회로 차단 기능 적용

특정 서비스에 평균적인 리소스 사용량 이상을 요구하는 비정상적 상태가 발생하거나, 오류가 발생했을 시 이를 대신할 수 있는 **대체 경로**를 마련한다.

이를 통해 서비스 전체의 장애는 회피하도록 설계한다.

#### 장애 격리

특정 서비스의 오류로 인해 다른 서비스까지 영향이 도달하는 것을 없애는 것.

- 논리적 격리는 서비스를 완전히 독립적으로 나누는 것

- 물리적 격리는 서비스를 단독으로 기동부터 중지할 수 있도록 인프라 환경을 제공하는 것.

모놀리스 환경이라면 서비스 간의 영향도를 차단하는 것이 매우 어렵다.

MSA 구성 시, 서비스가 독립적으로 구성되므로 영향이 제한적이다.

- 장애 발생한 서비스에 대해서만 빠른 조치 및 변경, 배포로 이어지는 대응이 가능하다.

- 즉, **서비스 복원력**이 높다.

### 클라우드 네이티브 인프라

#### 컨테이너 기반 패키지

**컨테니어 단위의 패키지**이다.

컨테이너로 패키지된 단위가 하나의 **실행 단위**가 된다. 이는 시스템일 수도 있고, 서비스 애플리케이션일 수도 있다.

- 컨테이너 단위로 독립적인 **인터페이스**와 **IP**, **포트**를 가지게 된다.

- 리눅스 컨테이너 기술을 응용한 **도커 컨테이너**가 사실상 업계 표준으로 사용된다.

컨테이너 이전에는, 배포되는 패키지의 형태가 `jar`나 `war` 형태로 압축된 **파일 타입**이었다.

- 하나의 압축 파일에 전체 소스가 압축되어 있고, 서버 기동 시 바이너리 패키지로 풀려 실행된다.

- 해당 패키지에 문제가 발생하면, 배포의 역순으로 코드를 롤백해야 한다.

**도커 컨테이너**로 실행되는 **도커 이미지**로 패키징이 이루어지면, 도커 이미지를 받아서 컨테이너로 실행하는 방식으로 배포가 이루어진다.

- 만약 문제가 있다면, **컨테이너를 내리고 이미지를 재작성해서 실행**하면 된다.

- 마이크로서비스로 잘 분할되어 있다면 장애 대응 과정은 더욱 간소화된다.

- 수평적 확장 및 민첩한 복원력을 가질 수 있다.

#### 동적 관리

시스템은 컨테이너로 패키징된 서비스의 추가 및 삭제를 자동으로 감지하여, 서비스에 들어오는 요청을 적절히 **라우팅**할 수 있다.

마이크로서비스 개수 및 이를 패키징한 컨테이너가 많아질수록, 이들의 동작을 감지하고 관리하는 것이 매우 중요하다.

### 지속적 통합과 배포

#### CI

지속적 통합은, 개발 환경에서 개발 중인 코드를 통합 및 테스트를 병행 수행하는 일련의 프로세스이다.

- 소스 코드를 지속적으로 통합하여 배포하는 것은 클라우드 네이티브 시스템 환경 구축에서 매우 중요한 요소이다.

CI의 구성 요소로는 **통합 서버**, **소스 관리 도구**(SCM), 빌드 도구, 테스트 도구.

- 빌드 도구에는 일반적으로 Jenkins가 많이 사용된다.

깃 같은 소스 저장소에 개발자가 소스를 푸시하면, 빌드 도구가 배포 대상의 파일을 실행 가능한 형태인 바이너리 파일로 패키징(**빌드**)한다.

- **빌드 과정과 주기가 자동화**되는 것이 CI의 핵심이다.

- MSA 환경에서는 서비스가 세분화되어, 빌드 시간을 상대적으로 짧게 가져갈 수 있다.

#### CD

**지속적 배포**에는 두 가지 유형이 있다.

- continuous **delivery**는 실행 환경으로 **배포하기 직전인 상태까지** 배포하는 형태
  
  - 승인 및 배포 담당자가 따로 있어서, **실행 환경으로의 배포**는 수동으로 이루어진다.
  
  - 다소 엄격한 배포 절차로, 대부분의 기업 시스템이 이와 같다.

- continuous **deployment**는 **실행 환경까지 자동으로 배포**하는 형태.
  
  - 빌드된 소스 코드의 실행 파일을, 아무 개입 없이 자동으로 실행 환경으로의 배포한다.
  
  - 자동화 정책, **스케줄러** 관리가 중요해진다.

##### 파이프라인

**통합 및 배포까지 일련의 프로세스를 하나로 연결하여 자동화 및 시각화**된 프로세스를 구축한 것.

많은 수의 마이크로서비스에 대해 소스를 통합하고 버전 관리를 하기 위해서는, CI/CD 환경이 필수적으로 형성되어야 한다.

- 이 때 파이프라인이 **서비스 별로 하나씩** 구성될 필요가 있다.

#### 카나리 배포와 블루그린 배포

빌드된 소스를 릴리스하는 두 가지 유형.

- **카나리 배포**는, 새 버전의 서비스를 **일부 사용자들에게만 배포하여 정상 유무를 확인**한다.

- **블루그린 배포**는, 운영 환경을 이중으로 두고 한쪽에 새 버전을 배포하여, 들어오는 리퀘스트를 새 버전 서비스로 **라우팅**하고, 문제가 없음이 확인되면 이전 환경을 사용 중지한다.

MSA는 변경에 아주 유연한 구조를 가져야하므로, 잦은 배포에 유연하게 대응할 수 있는 **자동화된 배포 인프라와 배포 전략**이 필요하다.

### 데브옵스

#### 팀의 구성

DevOps는, 애플리케이션과 서비스 개발에서 **배포 운영까지 빠르게 제공하기 위한 조직의 협업 문화**를 뜻한다.

데브옵스 측면에서는, 개발에서 운영까지를 **하나의 파이프라인으로 형성**하여 소스 배포가 필요할 때 **즉시 반영**되는 것이 목표이다.

- 이 때 가장 이상적인 팀 구성 모델은, 서비스 기획, 설계, 개발, 배포 및 운영까지의 **서비스 생명주기**가 한 팀으로 같은 작업 공간 내에서 결정되고 수행되는 조직.
  
  - 팀은 기획자, 아키텍트, 설계자, 개발자, 디자이너 등이 모두 포함되어 각각의 **전문성**을 가지고 있을 필요가 있다.

- 원하는 시점에 즉시 서비스 배포 / 운영이 가능하여 변화에 빠르게 대응할 수 있고, 의사소통 및 의사결정 비용을 크게 절감할 수 있다.

**마이크로서비스** 측면에서도, 데브옵스가 매우 적절하다.

- 의사결정 권한이 모두 주어진 상태에서 시장 변화에 빠르게 대응이 가능하기 때문.

- **자율적 조직**으로서 MSA의 한 구성요소를 온전히 책임지는 whole team으로 작동할 수 있다.

#### 자동화와 시각화

즉, 데브옵스의 핵심은 **개발 프로세스와 운영 프로세스 간의 자연스러운 연결**이다.

이 때 프로세스 전체가 **자동화 및 시각화**되는 것이 보다 이상적이다.

- 깃, 젠킨스, 대시보드, 이슈 추적 등은 이러한 목적에 적합한 오픈소스 툴.

- 개발자는 생산성 향상, 품질 향상의 효과를 누릴 수 있고,

- 기획 / 운영자는 상황을 직관적으로 이해할 수 있어 의사소통 비용을 최소화할 수 있다.

---

## 컨테이너

### 컨테이너 개념

항만 물류에 사용되는 그 컨테이너에서 유래한 개념이다. 핵심은 **격리**.

**리눅스** 운영체제가 이러한 격리 개념을 가지고 있는데, 운영체제가 독립된 공간을 할당하여 독립된 자원을 할당하고, 프로세스 간 간섭이 없는 환경을 제공할 수 있다.

- 애플리케이션은 격리된 환경에서, 용도에 맞게 **안전하게** 실행될 수 있다.

마이크로서비스 입장에서 컨테이너 기술은 매우 유용하다. **컨테이너 단위로 마이크로서비스를 묶어서** 필요한 시점에 즉시 배포할 수 있기 때문.

- 컨테이너 단위의 독립된 공간에서 서비스를 패키지해, 필요한 만큼만 자원을 할당하여 **경량화된 서비스**를 구성할 수 있다.

- 격리된 공간은 다른 서비스에 영향을 주지 않아, **자유로운 배포**가 가능하다.

- 사용량이 증가하면 컨테이너를 하나 더 올리면 되므로, **편리한 확장**이 가능하다.

#### 프로세스 격리

컨테이너 내의 프로세스는 다른 컨테이너에서 동작하는 프로세슬부터 영향을 받지 않는다.

**네트워크 자원**까지도 분할이 가능하다. 별도의 IP 어드레스를 이용해 엑세스할 수도 있다.

#### 가상화와 컨테이너

가상화는 **하이퍼바이저**라는 소프트웨어를 이용해, 하나의 시스템에서 **여러 운영체제**를 사용할 수 있도록 지원하는 기술이다.

반면 컨테이너는 그러한 별도의 소프트웨어 없이, 컨테이너 엔진을 통해 격리된 공간을 구성한다.

##### 가상화

하이퍼바이저를 이용해, 물리적인 하드웨어 시스템을 논리적인 단위로 나누어 별도의 공간으로 할당한다.

격리된 각 공간을 **가상 머신**이라 하고, 가상 머신에 설치한 운영체제를 **게스트 운영체제**라고 한다.

- 게스트 운영체제는 하이퍼바이저로부터 물리 하드웨어 자원을 제공받게 된다.

완벽하게 분리된 게스트 운영체제를 구성할 수 있는 장점이 있지만, 전체 하드웨어 관점에서 여러 개의 운영체제와 미들웨어를 각각 설치하여야 하는 오버헤드가 있다.

##### 컨테이너

컨테이너 엔진을 통해 가상의 격리된 공간을 생성한다.

호스트 운영체제를 그대로 사용하여 자원도 공유하지만, **프로세스 간 격리**를 통해 독립성을 구현하는 방식.

호스트 운영체제 자원을 공유하므로 오버헤드가 적어, **경량화**된 컨테이너 구성이 가능하다.

### 리눅스 컨테이너

#### 리눅스 컨테이너란?

하나의 호스트 운영체제 위에, 여러 격리된 시스템 환경을 구성할 수 있는 **운영체제 수준의 가상화 기술**이다.

**namespace**와 **cgroups**라는 커널 기능을 사용하여 격리된 공간을 제공한다.

#### namespace

**고유의 이름**을 바탕으로 컨테이너별로 격리된 공간을 가질 수 있도록 지원하는 기술이다.

시스템을 구성하는 다양한 요소들을 할당하고 관리할 수 있도록 한다.

- 총 6가지의 네임스페이스가 제공된다.

- PID, NET, MNT, UID, UTS, IPC

#### cgroups

**물리적인 하드웨어 리소스를 프로세스 그룹 단위로 제어**하는 커널 기능.

### 도커 컨테이너

#### 도커 이미지

도커 엔진에서 사용하는 기본 단위로, **도커 컨테이너**를 생성하는 요소다.

하나 혹은 여러 개의 이미지를 **레이어**로 겹쳐서 도커 컨테이너를 생성하게 된다.

- **베이스 이미지**는, **리눅스** 배포판의 사용자 영역을 이미지로 만들어, 컨테이너 부팅 시 최소한의 실행 파일과 라이브러리만을 설치하고 그 위에 **도커 이미지**를 올려 애플리케이션을 구동할 수 있도록 한다.

#### 도커 컨테이너

도커 컨테이너는 도커 이미지를 독립된 공간에 할당하여 실행한 **런타임 객체**이다.

도커 엔진 위에서 기동되어, 가상의 IP와 포트, 이름을 가질 수 있다. 내부의 파일 시스템을 제어할 수도 있다.

컨테이너별로 구성 요소를 다르게 만들 수 있고, 프로세스 간 격리를 실현한다.

#### 도커 레지스트리

도커 이미지를 관리 및 공유할 수 있게 제공된 저장 공간이다.

도커 이미지를 업로드하면, 이를 필요로 하는 불특정 다수가 다운로드하여 손쉽게 애플리케이션 환경을 구성할 수 있다.

개인 및 공용의 형태로 사용할 수 있다.

#### 도커 네트워크

도커 컨테이너 단위로 서비스할 수 있도록 **네트워크 환경**을 제공하는 가상의 네트워크 환경이다.

가상의 **브리지**인 **docker0**이 이를 담당한다.

- 호스트 서버의 **eth0**은 자체 IP를 가지고 **퍼블릭**으로 노출된다.

- 도커 데몬이 기동되면 내부 컨테이너들도 각각 eth0이 있고, **도커 네트워크**에 의해 IP가 자동으로 할당된다.

- 외부에서 퍼블릭 네트워크로 들어오는 연결은  **물리 NIC**(eth0)에 연결되고, NIC는 도커 컨테이너들과의 **브리지** 역할을 하는 docker0에 연결된다.

- docker0은 도커 내부 컨테이너들의 **가상 NIC**인 **veth**와 연결된다.

- 외부로부터 들어온 요청은 docker0에 의한 목적지 컨테이너의 IP 식별을 거쳐서, 개별 컨테이너의 veth를 거쳐 컨테이너가 가진 가상 **eth0**로 접수된다.

이 때 도커 네트워크는 **NAPT** 기능을 사용하는데, **하나의 IP로 가상의 여러 IP 및 포트와 변환**하는 기능이다.

- **NAT**는 공용 IP와 사설 IP를 1:1로 변환하는 반면,

- NAPT는 포트까지 변환하여 **1:N**으로 변환할 수 있다.

- 도커는 리눅스의 **IP 테이블**을 **NAPT**로 사용하여, 이러한 기능을 수행한다.

사용자가 호스트 IP의 8080 포트 서비스 요청을 했다고 할 때,

- 호스트의 eth0, 8080 포트가 받고,

- docker0으로 넘어가 목적지 컨테이너의 **내부 IP**와 **포트**를 확인하며,

- **NAPT**에 의해 해당 컨테이너의 IP를 80번 포트로 호출하여 연결이 이루어진다.

#### 도커와 마이크로서비스

MSA를 구성하는 과정에서 **도커 컨테이너**는 매우 잘 어울리는 기술이다.

독립된 서비스의 **생명주기**를 격리된 도커 컨테이너로 손쉽게 지원할 수 있고, 여기에 서비스 등록, 발견, 모니터링 등 **에코 시스템**이 결합하면 마이크로서비스를 위한 **최적의 환경**이 구성될 수 있다.
