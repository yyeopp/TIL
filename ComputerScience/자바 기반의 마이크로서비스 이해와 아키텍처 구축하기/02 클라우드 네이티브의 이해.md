# Chapter 02: 클라우드 네이티브의 이해

---

클라우드 네이티브는, **클라우드 환경에 친화적인** 애플리케이션, 아키텍처, 인프라 등의 환경을 뜨한다.

**클라우드 네이티브라는 기술 환경**은 *기술에 의한 비즈니스*라는 패러다임 전환에 견인차 구실을 하고 있다. 마이크로서비스 또한 그러한 맥락에서 등장한 아키텍처.

즉, 클라우드 네이티브 기술 환경에 대한 이해가 갖춰질 필요가 있다. 특히 그 중에서도 **도커** 환경에 대한 이해가 중요하다.

---

## 클라우드 네이티브

### 클라우드 네이티브 애플리케이션

클라우드 네이티브 애플리케이션은, 비즈니스 환경 변화에 능동적으로 대응하기 위해 **클라우드 네이티브 환경**에서 **SaaS**나 **FaaS** 형태로 서비스되는 애플리케이션을 의미한다.

- Software as a Service

- Function as a Service

- 민첩 / 유연 / 효율적 서비스 구현을 위해, 클라우드 네이티브 환경에서 **여러 개의 마이크로서비스로 구성된** 서비스 애플리케이션이 SaaS나 FaaS 형태로 제공된다.

#### 마이크로서비스

아주 작은 서비스로, **클라우드 환경**에 잘 맞는다.

- 클라우드 자체가 **즉시성과 유연성**을 특징으로 하는 서비스이기 때문. 

- 서비스가 작고 독립적일수록, 클라우드 환경의 장점을 활용하기에 적합하다.

마이크로서비스는 **2주 안에 독립적으로 개발해서 배포가 가능한 크기**를 권고한다.

- 크기가 작고 쉽게 조립할 수 있는 구조를 통해, 필요에 의해 적절히 확장 / 축소시킬 수 있다.

- 클라우드 인프라 환경, 도커 등의 컨테이너 환경은 **격리된 환경**을 제공하는 것, **서비스 생성 및 삭제**하는 것을 매우 쉽게 만들어 MSA 구성을 가능케 했다.

#### SaaS

소프트웨어가 필요할 때, **즉시 필요한 만큼만 사용**할 수 있는 **서비스 형태의 소프트웨어**이다.

마이크로서비스는 SaaS형 애플리케이션 개발 및 활용에 있어서 최적의 서비스 형태이다.

- 클라우드에 인프라 장비와 플랫폼을 위치시키고, 반복적으로 자주 사용되는 서비스들을 SaaS 형태로 공용화하여 서비스하는 식.

- 사용한 만큼만 비용이 발생하므로, 사용자 입장에서 **운영 비용** 부담이 줄고, **즉시 사용** 가능한 이점이 있다. 

대신, 기존 모놀리스 환경의 애플리케이션 개발과 다른 사상이 가지고 개발되어야 한다.

- 기존 애플리케이션이 **맞춤형**이라면,

- SaaS는 **불특정 다수**가 사용하는 서비스이므로 **가용성**과 **소스 버전 관리**가 중요하다.

#### 12팩터

SaaS가 가져야 할 특성과 지켜야 할 패턴들에 대한 경험적인 내용을 정리한 것.

**클라우드 네이티브 애플리케이션으로서의 마이크로서비스**를 개발하고 운영할 때, 구현 측면에서 좋은 모델이 될 수 있다.

##### [1] 코드베이스

하나의 애플리케이션은 하나의 코드베이스를 가지고, **버전으로 추적 관리**되어야 한다.

- 저장소 내 원천 소스는 오직 하나고, 컴파일되어 여러 phase의 서버 환경에 배포될 수 있다.

##### [2] 종속성

프로그램에 사용하는 라이브러리들에 **암묵적인 종속성**이 발생하지 않아야 한다.

- 명시적 종속성이 아닌 경우 오류 유발의 원인이 될 수 있다.

##### [3] 환경 설정

코드에서 사용하는 configuration 정보는 코드와 **완전히 분리되어 관리**되어야 한다.

- DB 연결 정보, 호스트명, 백엔드 리소스 정보 등.

- 환경 변수로 관리하고, 코드가 그에 종속되지 않도록 한다.

##### [4] 백엔드 서비스

백엔드 서비스는 모두 **리소스**로 취급한다.

- 데이터베이스나 메시지 큐 같은 시스템들.

- 이들을 연결하거나 분리할 때, 애플리케이션 코드를 수정하지 않아야 한다.

백엔드 서비스를 구별하기 위한 **리소스 식별자**는 **URI**여야 한다.

##### [5] 빌드, 릴리스 및 실행

소스 코드는 **빌드, 릴리스, 실행** 단계로 분리되어 운영된다.

##### [6] 프로세스

프로세스는 **무상태**(stateless)로 실행되며, **상태 정보를 공유하지 않아야** 한다.

- 상태 정보를 **영구 보관**하려면, **캐싱**이 아닌 **DB**를 사용해야 한다.

- 현재 수행되는 프로그램의 실행에 집중할 뿐, 데이터 캐싱으로 다음 수행 때 참조하는 일이 없어야 한다.

##### [7] 포트 바인딩

애플리케이션은 하나의 독립된 서비스로 **외부에서 접속할 수 있도록** 포트를 이용해 구분되어야 한다.

- **포트로 바인딩**된 독립된 서비스들은, **다른 서비스의 백엔드 서비스로 활용 가능**하다.

##### [8] 동시성

특정 서비스에 시스템 부하가 발생할 때, 하드웨어를 스케일업하는 것이 아닌 **프로세스의 워크로드를 수평 확장**할 수 있는 형태여야 한다.

##### [9] 폐기 가능

**Graceful shutdown**이 보장되어야 한다.

즉, 예상치 못한 시스템 상황에서도 프로세스가 비정상 종료되지 않도록 **논리적인 대응 메커니즘**을 가져야 한다.

- 프로세스 기동 시간은 최소화하고, 종료 시의 안전성을 보장해야 한다.

##### [10] 개발, 테스트, 운영 환경의 일관성

개발 환경은 **테스트나 운영 환경과 최대한 같아야** 한다.

- 각 phase 간 발생하는 문제를 최소화하고, **지속 배포**가 가능한 환경을 만들 수 있다.

##### [11] 로그

로그는 **스트림 이벤트**로 취급해, 애플리케이션에서 로그 처리에 관여 / 가공 / 관리하지 않도록 해야 한다.

대신 이를 수집 전달하는 오픈소스를 이용해 관리한다.

##### [12] 일회성 프로세스

일회성 작업은 구분하여 **별도의 프로세스로 구성**한다.

#### FaaS

Function as a Service는, 서비스의 수준을 **기능 단위까지 세분하여 제공**하는 **기능 서비스**이다.

기능 단위를 필요할 때 **즉시 사용**할 수 있고, **기능들의 조합**을 통해 새로운 서비스를 만들 수 있다.

- 클라우드 플랫폼 사업자들이 AI, 빅데이터 분석, 챗봇 같은 기능들을 필요 시 플랫폼에 업로드해서 사용하고, 이에 따른 비용을 지급한다.

- **품질과 속도** 측면에서 장점이 크다.
  
  - 직접 개발할 필요가 줄어들고, 누군가 미리 만들고 검증된 결과물을 사용하기 때문

### 클라우드 네이티브 아키텍처

#### 확장 가능한 아키텍처

모놀리스 구조라면, 애플리케이션이 클라우드의 **하나의 인스턴스**에서 실행된다.

- 시스템 부하 발생 시 인스턴스를 **수평적으로 확장**시키는 게 구조적으로 매우 어렵다.

- 아키텍처팀이 SI 프로젝트를 진행한다고 하면, 설계 단계에서 **과거 지표**를 바탕으로 시스템 용량을 산정해 시스템을 설계하는 것이 매우 중요해진다.
  
  - 예상보다 많은 부하가 발생하여 장애가 발생하면 안 되므로, 시스템 구성을 이중 / 삼중화하는 등 여러 대책이 마련된다.

반면 클라우드 네이티브 아키텍처는 시스템의 **수평적 확장**에 훨씬 유연하다.

- 필요에 따라 수평으로 유연하게 증감시키는 식으로 장애에 대응하면, 설계도 쉽고 비용도 적다.

- **서비스의 연속성을 보장**하는 측면에서도 의미가 있다.

- 대신, 서비스의 **상태**를 **마이크로서비스 단위까지** 지속적으로 인지하고 모니터링하는 것이 매우 중요해진다.

#### 탄력적 아키텍처

서비스의 **생성-통합-배포**로 이어지는, **환경 변화에 따른 대응**에 있어서 그 시간을 단축하고 오류 예측 및 적절한 대응에 능한 아키텍처 구조이다.

- **분산 병렬 처리**, **수평적 확장**, **무상태 통신 방식**, **자동 복원 능력** 등이 지원되어야 한다.

모놀리스 환경에서는 장애 대응에 있어서 **스케일업** 위주의 아키텍처와 **백업 및 복구** 같은 시스템적 메커니즘을 주로 고려한다.

- 시스템 성능의 임계치를 사전에 예측해 그에 부합하는 하드웨어를 도입하고,

- 장애 상황에 대비한 **재해 복구 시스템**을 구축하는 식.

반면 클라우드 네이티브 아키텍처는 **수펑적 시스템 확장**에 초점을 맞춘다.

- **최소한의 시스템 사양**으로 운영하고, 예기지 못한 오류는 **수용할 수 있는 구조**로 설계해, 최소의 영향으로 **복원**이 가능한 구조를 만드는 데 중점을 둔다.

- 이를 위해 아래와 같은 고려가 필요하다.

##### 분할된 서비스 구조

**상호 결합도를 최소화**하여, 장애를 격리시킨다.

장애가 난 서비스의 크기가 작을수록, 빠르게 수정 배포하여 대응할 수 있다.

##### 무상태 통신 프로토콜의 구성

통신을 **비동기적으로 처리**하여, 클라이언트와 서버 간 동작 상태 정보를 저장하지 않도록 한다.

- 장애 격리가 가능하고, **가용성** 측면에서도 유용하다.

##### 회로 차단 기능 적용

특정 서비스에 평균적인 리소스 사용량 이상을 요구하는 비정상적 상태가 발생하거나, 오류가 발생했을 시 이를 대신할 수 있는 **대체 경로**를 마련한다.

이를 통해 서비스 전체의 장애는 회피하도록 설계한다.

#### 장애 격리

특정 서비스의 오류로 인해 다른 서비스까지 영향이 도달하는 것을 없애는 것.

- 논리적 격리는 서비스를 완전히 독립적으로 나누는 것

- 물리적 격리는 서비스를 단독으로 기동부터 중지할 수 있도록 인프라 환경을 제공하는 것.

모놀리스 환경이라면 서비스 간의 영향도를 차단하는 것이 매우 어렵다.

MSA 구성 시, 서비스가 독립적으로 구성되므로 영향이 제한적이다.

- 장애 발생한 서비스에 대해서만 빠른 조치 및 변경, 배포로 이어지는 대응이 가능하다.

- 즉, **서비스 복원력**이 높다.

### 클라우드 네이티브 인프라

#### 컨테이너 기반 패키지

**컨테니어 단위의 패키지**이다.

컨테이너로 패키지된 단위가 하나의 **실행 단위**가 된다. 이는 시스템일 수도 있고, 서비스 애플리케이션일 수도 있다.

- 컨테이너 단위로 독립적인 **인터페이스**와 **IP**, **포트**를 가지게 된다.

- 리눅스 컨테이너 기술을 응용한 **도커 컨테이너**가 사실상 업계 표준으로 사용된다.

컨테이너 이전에는, 배포되는 패키지의 형태가 `jar`나 `war` 형태로 압축된 **파일 타입**이었다.

- 하나의 압축 파일에 전체 소스가 압축되어 있고, 서버 기동 시 바이너리 패키지로 풀려 실행된다.

- 해당 패키지에 문제가 발생하면, 배포의 역순으로 코드를 롤백해야 한다.

**도커 컨테이너**로 실행되는 **도커 이미지**로 패키징이 이루어지면, 도커 이미지를 받아서 컨테이너로 실행하는 방식으로 배포가 이루어진다.

- 만약 문제가 있다면, **컨테이너를 내리고 이미지를 재작성해서 실행**하면 된다.

- 마이크로서비스로 잘 분할되어 있다면 장애 대응 과정은 더욱 간소화된다.

- 수평적 확장 및 민첩한 복원력을 가질 수 있다.

#### 동적 관리

시스템은 컨테이너로 패키징된 서비스의 추가 및 삭제를 자동으로 감지하여, 서비스에 들어오는 요청을 적절히 **라우팅**할 수 있다.

마이크로서비스 개수 및 이를 패키징한 컨테이너가 많아질수록, 이들의 동작을 감지하고 관리하는 것이 매우 중요하다.

### 지속적 통합과 배포

#### CI

지속적 통합은, 개발 환경에서 개발 중인 코드를 통합 및 테스트를 병행 수행하는 일련의 프로세스이다.

- 소스 코드를 지속적으로 통합하여 배포하는 것은 클라우드 네이티브 시스템 환경 구축에서 매우 중요한 요소이다.

CI의 구성 요소로는 **통합 서버**, **소스 관리 도구**(SCM), 빌드 도구, 테스트 도구.

- 빌드 도구에는 일반적으로 Jenkins가 많이 사용된다.

- 
