# Chapter 02: 리눅스 커널 구조

---

### 리눅스의 개념적 구조

운영체제를 **자원관리자**라고 정의한다면, **자원**은 무엇인가?

자원은 크게 물리적인 자원과 추상적인 자원으로 구분된다.

- 물리적 자원은 CPU, 메모리, 디스크, 터미널, 네트워크 등 시스템 구성요소와 주변 장치 등이 있다.

- 추상적 자원은 CPU를 추상화시킨 **태스크**, 메모리를 추상화시킨 **세그먼트**와 **페이지**, 디스크를 추상화시킨 **파일**, 네트워크를 추상화시킨 **통신 프로토콜, 패킷** 등이 있다.

- 물리적인 자원에 대응되지 않고 추상적 객체로만 존재하는 자원도 있는데, **보안**이나 사용자 ID에 따른 **접근 제어** 등이 그 예시이다.

이러한 측면에서 리눅스 커널 내부는 5가지로 나눌 수 있다.

- CPU라는 물리적 자원을 태스크라는 추상적 자원으로 제공해주는 **태스크 관리자**
  
  - 태스크의 생성, 실행. 상태 전이, 스케줄링, 시그널 처리, 프로세스 간 통신 등 서비스를 제공한다.

- 메모리를 세그먼트나 페이지라는 개념으로 제공해주는 **메모리 관리자**
  
  - 물리 메모리 관리, 가상 메모리 관리, 세그멘테이션, 페이징, 페이지 부재 결함 처리 등 서비스를 제공한다.

- 디스크를 파일이라는 개념으로 제공해주는 **파일시스템**
  
  - 파일의 생성, 접근 제어, inode 관리, 디렉토리 관리, 수퍼 블록 관리 등 서비스를 제공한다.

- 네트워크 장치를 소켓이라는 개념으로 제공해주는 **네트워크 관리자**
  
  - 소켓 인터페이스, TCP/IP 같은 통신 프로토콜 등의 서비스를 제공한다.

- 각종 장치를 디바이스 드라이버를 통해 일관되게 접근하도록 해주는 **디바이스 드라이버 관리자**
  
  - 디스크, 터미널, CD, 네트워크 카드 등 주변 장치를 구동하는 드라이버들로 구성된다.

운영체제가 자원을 관리하는 이유는 결국 사용자에게 서비스를 제공하기 위해서이다.

사용자라 함은 user space에서 동작하는 **태스크**를 의미하고, 서비스는 **시스템 호출**이다.

즉, 운영체제는 **시스템 호출을 통해 태스크가 자원을 사용할 수 있게 해주는 자원관리자**이다.

### 리눅스의 소스레벨 구조

리눅스가 설치된 PC에서는 `/usr/src/kernels` 디렉터리에서 리눅스의 소스를 볼 수 있다.

해당 소스 구조를 보면서, 앞서 배운 논리적인 구조와 연결해보는 게 필요하다.

#### kernel 디렉터리

**태스크 관리자**가 구현된 디렉터리다. 태스크 생성, 소멸, 프로그램 실행, 스케줄링, 시그널 처리 등 기능이 구현되어 있다.

- 문맥 교환과 같이 하드웨어 종속적인 태스크 관리 부분은 arch 디렉터리에 따로 있다.

#### arch 디렉터리

리눅스 커널 기능 중 **하드웨어 종속적인** 부분들이 구현된 디렉터리다.

CPU 타입에 따라 하위 디렉터리가 다시 구분되고 있는데, 대표적으로 인텔의 i386, ARM의 ARM 계열, 모토로라의 68시리즈, SUN의 Sparc, IBM의 PPC 등이 있다.

- i386을 기준으로 할 때. arch/x86 디렉터리가 생성된다.

- /boot 디렉터리에는 시스템 부팅 시 사용하는 부트스트랩 코드가,

- /kernel에는 태스크 관리자 중에서 문맥 교환이나 쓰레드 관리 같은 기능,

- /mm에는 메모리 관리자 중 페이지 부재 결함 처리 같은 하드웨어 종속적인 기능이,

- /lib에는 커널이 사용하는 라이브러리 함수가,

- /math-emu에는 FPU(Floating Point Unit)에 대한 에뮬레이터가 구현되어 있다.

##### fs 디렉터리

리눅스에서 지원하는 다양한 **파일시스템**과 open(), read(), write() 등 **시스템 호출**이 구현된 디렉터리다.

- 현재 리눅스에는 60가지 이상의 파일시스템이 구현되어 있다.
  
  - 각 파일시스템은 /fs 하부에 들어있는데, ext2, ext3, ext4, nfs, fat, proc, sysfs, devfs, isofs, ntfs, reiserfs, f2fs, xfs 등이 있다.

- 다양한 파일시스템을 사용자가 일관된 인터페이스로 접근할 수 있도록 리눅스가 도입한, **가상 파일시스템**도 여기에 존재한다.

#### mm 디렉터리

메모리 관리자가 구현된 디렉터리다.

물리 메모리 관리, 가상 메모리 관리, 태스크마다 할당되는 메모리 객체 관리 등의 기능이 구현되어 있다.

#### driver 디렉터리

리눅스에서 지원하는 디바이스 드라이버가 구현된 디렉터리다.

**디바이스 드라이버**란, 디스크, 터미널, 네트워크 카드 등 주변 장치를 추상화시키고 관리하는 커널 구성 요소이다.

리눅스 설계 당시 디바이스 드라이버를 3가지 종류로 구분했는데,

- 파일시스템을 통해 접근되는 **블록 디바이스 드라이버**

- 사용자 수준 응용 프로그램이 장치파일을 통해 직접 접근하는 **문자 디바이스 드라이버**

- TCP/IP를 통해 접근되는 **네트워크 디바이스 드라이버**.

이러한 구분은 현재 충분치 않다. USB, LCD, DSP, Sound 등 다양한 장치가 추가됐기 때문.

#### net 디렉터리

리눅스가 지원하는 통신 프로토콜이 구현된 디렉터리다.

대표적인 프로토콜인 TCP/IP 뿐만 아니라, UNIX 도메인 통신 프로토콜, 802.11, IPX, RPC, AppleTalk, bluetooth 등 다양한 통신 프로토콜을 구현해놓았다.

다양한 통신 프로토콜의 추상화 계층으로서 사용자 인터페이스를 제공하는 **소켓** 또한 구현되어 있다.

#### ipc 디렉터리

리눅스 커널이 지원하는 프로세스 간 통신 기능이 구현된 디렉터리다.

대표적인 프로세스 간 통신은 파이프, 시그널, SYS V IPC 소켓 등이 있고,

해당 디렉터리에는 message passing, shared memory, semaphore이 구현되어 있다.

#### init 디렉터리

커널 초기화 부분, 커널의 메인 시작 함수가 구현된 디렉터리다.

하드웨어 종속적인 초기화는 arch 디렉터리에서 이루어지고, 이후에 init 디렉터리에 있는 `start_kernel()`이라는 C함수로 제어가 넘어와 커널 전역적인 초기화를 수행하게 된다.

#### include 디렉터리

리눅스 커널이 사용하는 헤더 파일들이 구현된 디렉터리다.

하드웨어 독립적인 부분이 /linux 디렉터리에, 하드웨어 종속적인 부분이 /asm-$(ARCH) 디렉터리에 정의되어 있다.

#### others 디렉터리

리눅스 커널 주요 기능 외에 다른 기능을 담은 여러 디렉터리들이 존재한다.

- 커널 및 명령어들에 대한 자세한 문서가 존재하는 Documentation 디렉터리

- 커널 라이브러리 함수들이 구현된 lib 디렉터리

- 커널 구성 및 컴파일 시 이용되는 스크립트를 담은 scripts 디렉터리

---

## 리눅스 커널 컴파일

> ##### 컴파일
> 
> 어떤 언어의 코드 전체를 다른 언어로 바꿔주는 과정

윈도우 운영체제를 교체하려면 아예 삭제하고 처음부터 새로 설치해야 하지만,,

리눅스를 업데이트한다면 그저 새로운 커널 소스를 **컴파일**하고 컴파일된 커널로 재부팅하면 된다.

- 즉, 리눅스 커널이라고 해서 고차원적인 무엇인가로 볼 필요가 없고,

- 마치 C언어나 Java로 만든 프로그램처럼 코드 작성 -> 컴파일 -> 실행의 과정을 거치는 하나의 프로그램으로 보면 된다.
  
  - 단, 여느 `HelloWorld.java` 같은 프로그램보다 **많은 양의 파일들을 컴파일해야**한다는 점
  
  - `bzImage`라는 이름으로 컴파일된다는 점
  
  - 만들어지는 방법은 같지만 **수행될 때 매우 다르다는** 점을 고려해야 한다.
    
    - 커널은 메모리에 **상주**하지만, 단순 프로그램은 필요할 때 적재됨
    
    - 단순 프로그램들은 사용자 권한으로 동작하지만, 커널은 더욱 강력한 **커널 권한**으로 동작
    
    - 커널을 만들 때는 많은 소스 파일을 컴파일해야 하기 때문에 **make** 유틸리티를 활용

### 리눅스 커널을 만드는 과정

#### 커널 구성(Kernel configuration)

새로 만들어질 리눅스 커널에게, 현재 시스템에 존재하는 하드웨어 특성, 커널 구성 요소, 네트워크 특성 등의 정보를 알려주는 과정.

매우 복잡하고, 하드웨어 정보에 대한 사전 지식을 충분히 갖춰야 한다.

수행 방법으로는 `make config`, `make menuconfig`, `make xconfig` 등의 방법이 있다.

사용자 선택 사항은 `include/linux/autoconf.h`와 `.config` 파일에 저장되어, **커널 컴파일** 단계에서 사용한다.

#### 커널 컴파일(Kernel compile)

커널 소스 파일을 이용해 **실행 가능한** 커널을 만드는 과정이다.

`make bzImage`라는 명령으로 생성될 수 있다.

컴파일된 결과물은 `kernel/arch/x86/boot`에 생성된다.

#### 커널 인스톨(Kernel installation)

생성된 커널로 **시스템이 부팅**될 수 있도록 만드는 과정.

생성된 커널 **이미지**를 루트 파일시스템으로 복사하고, 모듈 인스톨, 부트 로더 수정 등의 과정이 이루어진다.

### 커널 구성

> 이미 리눅스가 구동되고 있는 환경에서, 새로운 리눅스 커널 소스를 받아서 자체적으로 구성, 컴파일, 인스톨할 수 있다는 게 기본 전제다.
> 
> - 이를 통해 **나만의** 리눅스 배포판이 만들어지는 의미가 있다.

커널 소스가 있는 디렉토리로 이동해서 `make menuconfig`를 수행하면, Makefile에 의해 **커널 구성 스크립트**가 시작된다.

해당 스크립트를 통해 리눅스의 **모듈** 기능을 확인 가능한데, 커널 구성 요소로 어떤 것을 넣고 뺄 것인지 수많은 y/n 질문에 답해야 한다.

- 모듈 사용 여부, 일반적인 시스템 정보, 시스템에 존재하는 블록 디바이스 특성, 네트워크 통신 프로토콜, SCSI 디바이스 특성 등.

- 자신이 원하는 시스템에 적합한 깔끔한 리눅스 커널을 만들려면, 이 질문들에 잘 답해야 한다.

이러한 configuration의 결과는 커널 소스 디렉터리에서 `.config` 파일로 확인할 수 있다.

- 배포판이 사용한 config 파일을 복사해서 붙여두는 것도 좋은 방법이다.

### 커널 컴파일

`make` 명령을 통해 커널을 컴파일할 수 있다.

- 과거 버전에서는 커널 구성 이후 선택된 구성 요소 간의 의존성 체크 과정이 있었는데, 2.6부터 불필요해졌다.

컴파일 결과는 bzImage 또는 zImage라는 파일이다.

- 작업 과정이 복잡한데 굳이 안 봐도 될 것 같다.

- 양자는 모두 gzip 알고리즘으로 압축된 파일이지만,

- 물리 메모리의 1M 위치에 로드될 수 있는 **작은 크기**의 커널이면 zImage 형태로 파일을 생성하고, 그렇지 않으면 bzImage 형태로 파일을 생성하는 차이가 있다.

### 커널 인스톨

컴파일이 완료되면 새로운 커널이 만들어진 것이나 마찬가지다.

단, 여기에 모듈로 선택된 구성 요소들도 컴파일해야 하고, 최종적으로 설치해야 한다.

- `make modules`와 `make modules_install` 명령으로 수행된다.

- 이를 통해 모듈로 구성된 커널 내부 구성 요소를 커널에게 알려주고, 나중에 그 구성 요소들이 사용되는 시점에 **자동으로** 커널에 적재될 수 있도록 설정한다.

마지막으로 **부트스트랩 루틴**에게 새로운 커널이 어디에 위치하는지 알려주는 `make install` 명령으로 인스톨이 마무리된다.

### 커널 구성 요소를 어떻게 선택하고 적용할 수 있는가?

커널 구성 과정에서 y/n 선택이 잦았는데, 그게 어떻게 컴파일로 이어질까?

커널 소스 디렉터리에서 `drivers/block` 위치에 가보면,`Kconfig`라는 파일이 있다.

- 여기에 커널 구성 요소에 대한 간단한 docs와, 구성 과정에서 화면에 출력할 내용이 적혀 있다.

y/n을 선택하면, `.config` 파일에 해당 **변수**에 대한 값이 선택된 값으로 저장된다.

근데 사실 `.config` 파일은 그 자체로 커널 컴파일 시 사용되는 파일이 아니다.

- 실제 컴파일 시 `~/include/generated/autoconf.h`이 자동 생성되어 이를 기반으로 컴파일된다.

컴파일을 직접 주도하는 `drivers/block/Makefile`이, `.config`를 읽어서 **컴파일 대상이 될 항목 리스트**를 구성한다.

> `autoconf.h`랑은 무슨 관계지
