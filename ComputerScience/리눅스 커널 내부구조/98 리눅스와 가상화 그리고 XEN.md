# 부록 A: 리눅스와 가상화

---

## 가상화 기법의 이해

### 기본 개념 및 역사

**가상화**는, **물리적인 자원과 사용자가 사용하는 자원을 분리하는 것**이다.

역사적으로도 여러 시도가 있었다.

- 60년대에 IBM을 중심으로 컴퓨터 하드웨어를 독립된 여러 **가상 머신**으로 구분하고 각 가상 머신에서 서로 다른 운영체제를 수행시키는 연구가 진행된 바 있다.

- 90년대 초에는 SUN 등을 중심으로 언어 수준에서 제공한 가상 머신 상에 **상호 연동** 가능한 응용 프로그램을 수행하는 기법이 제안되었다.

- 2000년대에는 Xen, VMware, MS 등을 중심으로 시스템을 논리적으로 분할하고 추상화된 자원을 제공하는 **VMM**(Virtual Machine Monitor)에 대한 연구가 진행되었다.

가상화는 물리적인 자원과 논리적인 자원을 구분하고, 이를 위해 **가상화 층**(virtualization layer)을 도입한다.

- 가상화 층을 통해 실제 물리적 자원의 복잡함을 숨기고, **단일하며 일관된 가상 자원**들을 제공한다.

- 하나의 물리 자원을 여러 가상 자원으로 나누어 제공할 수 있고,

- 반대로 다양한 물리 자원들을 하나의 논리 자원으로 통합하여 제공할 수 있다.

### 가상화 기술의 장점

- 서버의 **이용률**을 높이고 **관리 부하**를 줄일 수 있다.
  
  - 다양한 응용툴과 시스템 소프트웨어들을 하나의 시스템으로 **통합 운영**할 수 있기 떄문에 이용률을 증가시킬 수 있다.
  
  - 가상화 층을 통해 통합 관리가 가능하므로, 관리 비용이 줄어든다.

- 각 사용자의 **수행 환경**을 다른 환경들로부터 **고립**시킬 수 있다.
  
  - 각 사용자는 **물리** 자원에 직접 접근하지 않고, 가상화 층에서 제공하는 **가상** 자원에만 접근한다.
  
  - 사용자의 비정상적인 행위와 결함을, 해당 사용자의 **가상 머신으로 제한**할 수 있어 신뢰성이 증가한다.
  
  - 다른 사용자의 정보는 단일한 가상화 층을 통해서만 접근 가능하기 때문에, 안전한 환경을 제공할 수 있어 **보안** 수준이 높아진다.

- 여러 물리 자원들을 단일한 가상 자원으로 **집합**시킬 수 있다.
  
  - 물리적으로 떨어진 저장 공간들을 **논리적으로 연결**하고 동일한 **인터페이스**로 접근하면, 큰 저장 **용량**과 **병렬 접근**을 지원할 수 있다.
  
  - 서로 독립된 PC들을 연결하면, 고성능 **클러스터** 시스템이나 **GRID** 시스템을 만들 수 있다.

- 시스템의 **이동성**을 증가시킨다.
  
  - 응용 프로그램과 OS는 가상화 층이 제공한 가상 자원을 이용하게 되므로, 동일한 가상 자원을 이용한다면 **실제 물리 자원의 종류에 무관하게** 응용 프로그램과 OS를 migration할 수 있다.
  
  - 결과적으로 다양한 **하드웨어**들의 효과적인 **상호 운용** 정도를 향상시킬 수 있다.

- 새로운 시스템이나 아직 개발되지 않은 하드웨어를 **모의실험**하는 기능을 제공한다.
  
  - 가상화 기술의 핵심은 물리 자원을 가상 자원으로 **추상화**시키는 것인데, 심지어는 **현존하지 않는 물리 자원**에 대해서도 가상 자원으로 추상화하는 게 가능하다.
  
  - 하드웨어 설계, 제작 및 모의실험을 통한 성능 평가를 가능하게 한다.

정리하면, **통합, 고립, 집합, 이동, 에뮬레이션**의 장점을 제공한다.

### 가상화 기술의 분류: 컴퓨터 시스템의 층 구조에 따른 분류

컴퓨터 시스템은 크게 하드웨어 층과 소프트웨어 층으로 구분될 수 있다.

소프트웨어 층은 다시 시스템 소프트웨어와 응용 소프트웨어 층으로 구분된다.

시스템 소프트웨어를 운영체제, 미들웨어, 프로그램 언어, 런타임 라이브러리 등의 층으로 세분한다.

- 가상화 기술은, 컴퓨터 시스템의 층 구조에 새로운 **가상화 층**을 도입한다.

- **가상화 층을 어디에 도입하느냐**에 따라 가상화 방법을 구분할 수 있다.

#### 하드웨어 기반 가상화 방법

물리 자원과 그 물리 자원을 사용하는 운영체제 사이에, **VMM**(Virtual Machine Monitor) 또는 **Hypervisor**라고 불리는 **소프트웨어 추상화 계층**을 추가한다.

VMM은 물리 자원을 **가상 자원으로 추상화**시키고 이러한 가상 자원 위에서 리눅스, Windows 같은 **Guest OS**가 수행된다.

결과적으로, 가상 자원과 GuestOS, 그 위에 놓이는 응용 프로그램들이 모여 하나의 **추상화된 가상 기계**(**VM, Virtual Machine**)를 구성하게 된다.

#### 운영체제 기반 가상화 방법

하드웨어와 가상 기계 사이 VMM 같은 별도의 가상화 층은 없고,

대신 **OS 내부**에서 가상 자원들을 생성하고 이 자원 상에서 **Guest OS**가 동작하는 방식이다.

즉, OS가 그 자체적으로 물리 자원에 대한 추상화를 제공하고 있다는 측면을 확장해, Guest OS에게 가상 자원을 제공할 수 있도록 한 것이다.

#### 미들웨어 기반 가상화 방법

**프로그래밍 언어** 또는 **런타임 라이브러리** 수준에서 가상 머신을 제공하고, 이 가상 머신 상에서 **하드웨어 독립적인** 프로그램이 수행된다.

SUN의 JAVA VM이 대표적인 예시가 된다.

프로그램의 이식성과 상호 호환성을 향상시키려는 목표가 크다.

### 가상화 기술의 분류: 목표로 하는 시스템에 따른 분류

가상화는 목표로 하는 시스템에 따라 구분할 수도 있다.

- **서버** 가상화
  
  - 하나의 시스템 상에 존재하는 하드웨어들을 **여러 개의 가상 자원들로 추상화**시키고, 각 가상 자원에 **서로 다른 OS들**을 동시에 수행시키는 방법이다.
  
  - 하나의 시스템에 대해 **다중 사용자 접근**을 가능케 하여 시스템 **이용률**을 향상시킬 수 있다.

- **저장공간** 가상화
  
  - 여러 개의 물리 저장 공간을 단일한 **가상 저장 공간**으로 **집합**하여, 빠른 I/O 성능과 신뢰성을 제공한다.

- **네트워크** 가상화
  
  - 가상화 층을 이용해 네트워크를 독립된 **가상 사설 네트워크**(**VPN**, Virtual Private Network)로 파티션하고, 각 파티션 간 **접근 제어**와 **통제 방법**을 연구한다.

- **임베디드** 가상화
  
  - 전통적인 서버 가상화에서 추구했던 통합과 고립 뿐만 아니라, 다양한 내장형 장치를 가상화시켜 **표준화된 인터페이스로 접근**함으로써 이동성과 상호 호환성을 향상시킨다.

---

## 가상화 기술

핵심 기술은 결국 **물리 자원을 가상 자원으로 추상화 하는** 기술이다.

실제 시스템에는 CPU, memory, storage, network 등 다양한 물리 자원이 존재하고, 가상화 기술을 제공하는 대표적인 가상화 층인 **VMM**은 이러한 물리 자원을 가상 머신에서 사용할 수 있는 여러 가상 자원들로 변환한다.

Linux, BSD, Windows XP 같은 GuestOS는 이러한 가상 자원을 기반으로 동작한다.

### VMM의 물리 자원 추상화

VMM은 물리 자원을 여러 GuestOS가 공평하게 사용할 수 있도록, 효율적으로 **공유**해야 하고 동시에 GuestOS들을 효과적으로 **보호**해야 한다.

즉, 추상화 시의 요구 조건이 2가지이고, 서로 **상반된다**.

- VMM이 생성하는 가상 자원은 실제 물리 자원에 비견되는 **인터페이스**를 제공해야 한다.
  
  - GuestOS가 물리 자원에 접근할 때와 **동일한 방식으로** 가상 자원에 접근할 수 있어야 한다.

- VMM은 GuestOS의 동작을 제어할 수 있어야 하고, 필요한 경우에는 GuestOS의 자원 접근을 **통제**할 수 있어야 한다.

양자는 tradeoff 관계에 있고, 설계 시 어디에 비중을 두느냐에 따라 VMM의 특성은 달라진다.

### VMM 설계 방법

크게 **전가상화**(Fully Virtualization)와 **반가상화**(Para Virtualization)로 구분할 수 있다.

- 전가상화는 VMM이 범용적인 가상 자원을 제공하기 때문에, GuestOS를 전혀 수정하지 않고 그대로 수행할 수 있다.

- 반가상화는 효과적인 GuestOS 제어 및 성능 향상을 위해, VMM과 GuestOS 간에 **의존 관계**가 나타나고 이 때문에 GuestOS의 일부 수정을 요한다.

### VMM의 가상화 기술

#### CPU 가상화

물리 CPU에 대한 **논리적인 CPU**들을 생성하고, 이것들을 공평성과 효율성에 맞게 각 가상 머신에게 할당하는 것을 의미한다.

##### Direct Execution

CPU 가상화에서 중요한 기술 중 하나는 **Direct Execution**의 지원이다.

- Direct Execution은, 가상 머신을 **실제 머신 상에서 직접 수행**할 수 있으며, 동시에 CPU에 대한 제어는 **전적으로 VMM이 담당**하는 것을 의미.

- 이를 위해 VMM의 수행 특권과 가상 머신 상에서 수행되는 GuestOS 및 응용 프로그램의 수행 특권이 구분되어야 한다.

- 결과적으로, GuestOS 및 응용 프로그램이 **일반 명령**을 수행할 때는 *VMM에 투명하게* **직접 수행**되지만, **특권 명령**을 수행할 때에는 VMM에게 trap 또는 hypercall 같은 기법을 통해 알려야 한다.

Direct Execution이 필요한 예시를 들자먄,

- 한 GuestOS가 **인터럽트 불허** 정책을 채택한다고 했을 때,
  
  - 만약 해당 OS가 가상화를 적용하지 않은 환경이라면 그냥 실제 CPU에 인터럽트 불허 요청이 적용되겠지만,
  
  - 가상화가 적용된 상태라면 인터럽트 불허 요청이 해당 GuestOS로 한정되어야 하기 때문에 실제 CPU로 직접 적용되어서는 안 된다.
  
  - 즉, 인터럽트 불허 요청이 **VMM으로 전달**되어야 하고, VMM은 GuestOS가 사용하는 **가상의 CPU**에서 인터럽트가 불허되었다고 표시한다.
  
  - 이후 인터럽트가 발생했을 때 해당 GuestOS를 패싱하고 다른 GuestOS들에게 전달하는 방식을 사용해야 할 것이다.

실제 Direct Execution을 구현하는 것은 쉽지 않다. 대부분의 CPU가 VMM의 존재를 고려하지 않고 설계되어, 결국 **VMM으로의 trap을 발생시키지 않기 때문**.

- GuestOS의 **특권 명령** 수행이 VMM에게 전달되어야 하는데, 대부분의 상용 CPU는 그 정보를 모두 알려 주지 않고 있는 것이다.

- **Xen**의 경우 이를 해결하기 위해 GuestOS의 소스를 일부 수정하는 방식을 사용하고 있다.
  
  - trap을 발생하지 않는 특권 명령 사용 부분에 trap을 발생시키도록 인위적으로 수정하는 것.
  
  - 이 때문에 Xen은 *GuestOS의 수정을 필요로 하는* 반가상화 VMM으로 분류된다.

- VMware ESX 서버의 경우 전가상화 기술을 사용한다.
  
  - runtime binary translator를 이용해, 수행 중에 특권 명령어를 trap이 발생하는 명령어로 변경한다.
  
  - 덕분에 GuestOS 소스 수정이 필요하지 않지만, **변환**이 강제되어 성능이 저하된다.
  
  - 이를 해결하기 위해 변화 내용을 캐싱하는 trace cache, 불필요한 trap에 대한 자동 제거 등 기법을 개발했다.

##### 스케줄링 기법

다른 중요한 기술은 물리 CPU를 가상 CPU들에게 효율적이고 공평하게 할당해주는 것이다.

VMM은 공평성 원칙을 기반으로 다양한 **스케줄링 기법**을 지원한다.

- Xen은 BVT Scheduling을 지원하고 있다.
  
  - 이는 fair share 원칙에 따라, CPU를 각 가상 머신에 할당한다. 
  
  - 동시에 Virtual time warp를 도입하여 오랫동안 대기한 가상 머신이 이벤트를 받으면 빠르게 CPU를 할당한다.

#### 메모리 가상화

물리 메모리를 GuestOS가 이용하기 쉬운 형태의 **가상 메모리**로 추상화시켜 지원함과 동시에, 각 가상 머신이 **trashing 없이** 효과적으로 동작할 수 있도록 각 가상 머신의 요구에 맞게 **메모리를 동적 할당**하는 것.

##### shadow page table

VMM에서 메모리 가상화를 구현하는 전통적인 방법이다.

Shadow page table은 VMM에서 관리되며, 모든 가상 머신의 **페이지 테이블** 내용을 동일하게 담고 있다.

- 특정 가상 머신에서 페이지 테이블 내용이 바뀌면, 이것이 VMM에게 알려지고 VMM은 shadow page table에 변경 사항을 반영한다.

결과적으로 VMM은 모든 물리 메모리에 대해 제어할 수 있고, 어떤 물리 메모리가 어떤 가상 머신에 할당되었는지 파악할 수 있다.

##### 동적 회수와 할당

각 가상 머신에 메모리를 같은 크기로 나누어 할당하면 편리하겠지만, 각 머신의 워크로드는 서로 특징이 다르고 워킹 셋도 다르다.

VMM은 이에 맞도록 각 머신에 필요한 메모리를 할당하거나 회수할 필요가 있다.

VMware ESX와 Xen은 **Balloon process**를 사용한다.

- VMM이 가상 머신으로부터 메모리를 회수할 때에는, **balloon에게 inflating을 요구**한다.

- balloon은 **가상 머신으로부터 메모리를 할당**받고, 이 공간을 VMM에게 반납한다.

- 이 때 가상 머신이 balloon에게 할당해준 페이지들은 **스스로 가장 사용하지 않는 페이지**들을 줬을 것이기 때문에, 페이지 회수에 따른 가상 머신의 성능 저하가 최소화된다.

- 가상 머신에게 페이지를 더 할당해주고 싶으면 **balloon에게 deflate를 요청**하고, balloon은 기존에 가상 머신으로부터 할당받은 페이지를 가상 머신에게 반납한다.

- 결과적으로 VMM과 가상 머신 사이에서 balloon의 크기가 커졌다가 줄었다가를 반복하는 모양새가 된다.

#### I/O 가상화

I/O 가상화는 각 가상 머신 간의 간섭을 없애며, 동시에 각 가상 머신이 예약한 입출력 품질을 보장할 수 있도록 가상화되어야 한다.

하지만, 입출력 장치가 너무 많고 다양하여 **단일 인터페이스**로 추상화하는 것이 어렵다.

특히 최근 graphic 장치나 네트워크 장치는 고성능을 요구하기 때문에, 가상화의 부하가 크면 문제가 될 수 있다.

- 이를 해결하는 전통적인 I/O 가상화 기법은 **전용 I/O CPU**를 사용하는 것이다.

- 전용 CPU는 I/O 요청 인터페이스를 제공하며 **장치 제어**를 직접 담당하기 때문에, 가상화의 부하를 크게 줄일 수 있다.

##### Xen의 I/O 가상화

Xen의 경우 각 가상 머신이 가상의 네트워크와 디스크 자원을 사용하며, 가상 자원의 접근이 매우 효율적으로 실제 자원에게 전달되어 처리되도록 구현되었다.

가상 머신이 수행하는 공간은 **도메인**이라 부르는데, 시스템 초기화 시점에 초기 도메인(**Domain 0**)이 네트워크와 디스크를 **VIF**(Virtual **network** interFace)들과 **VBD**(Virtual **Block**interFace)들로 추상화하고 다른 도메인들(**Domain U**)에게 할당한다.

VIF나 VBD에 대한 접근은 Xen을 통해, 실제 네트워크와 디스크에 대한 접근이 된다.

- 도메인과 Xen은 **공유 메모리**를 이용해 데이터를 주고 받는데, 공유 메모리는 **I/O ring**으로 관리된다.

- I/O ring은 **원형 큐** 구조이고, 각 도메인이 생성하여 Xen과 통신하기 위해 사용된다.

- 비동기적 데이터 전송을 사용하며, zero copy 구조이기 때문에 전송 속도가 빠르다.

- 요청의 처리 순서를 제어할 수 있어, 자원 제어와 QoS 보장이 가능하다.

### Xen의 가상화 기술 정리

- 하드웨어 상에 **Hypervisor**라 불리는 VMM을 사용한다.
  
  - Hypervisor는 물리 자원을 추상화하여 가상 CPU, 메모리, 디스크, 네트워크를 생성한다.

- 추상화된 자원 위에 GuestOS가 동작한다.
  
  - 반가상화를 사용하므로, GuestOS의 소스는 일부 수정이 요구된다.

- GuestOS와 응용 프로그램들이 하나의 **가상 머신**을 이루며 동작하는 공간을 **도메인**이라고 한다.
  
  - 그 중에서도 **Control Plane Software**가 동작하는 도메인을 Domain 0라 하는데, **시스템 제어 및 I/O 가상화**를 주관한다.
  
  - 일반 사용자 소프트웨어가 동작하는 도메인을 Domain U라고 한다.

- 응용 프로그램의 GuestOS 접근은 system call을 통해 이루어지고, GuestOS의 hypervisor 접근은 hyper call에 의해 이루어진다.

### 가상화 기술 최근의 움직임

#### 가상화를 지원하는 하드웨어 등장 및 이를 이용하는 가상화 기술

인텔, AMD 등에서 가상화를 지원하는 CPU를 발표하고 있다.

- VMM을 위해 새로운 특권 모드를 하드웨어 수준에서 지원하는 등. VMM의 설계가 쉬워진다.

- 기존 하드웨어를 활용하면서 발생하던 많은 문제들이 쉽게 해결될 수 있다.

VMM의 효과적인 구현을 가능하게 하며, 가상화의 상용화를 가속시키는 요인이 될 것이다.

#### 새로운 가상화 접근 방법에 대한 발전

전가상화와 반가상화에 대한 성능 논쟁은 계속되고 있고, 최근에는 반가상화에서 분기된 **paenevirtualization**에 대한 제안도 나오고 있다.

##### Paenevirtualization

반가상화가 **하드웨어 기반** 가상화 기술이였다면, paene는 **운영체제 기반** 가상화 기술이다.

**Container**라는 개념을 사용하는데, **자원(resource) 고립, 이름 공간(name space) 고립, 보안(security) 고립, 결함(fault) 고립** 등을 제공하는 수행 공간이다.

Paene가 반가상화에 비견되는 **고립**을 제공함과 동시에, 효율은 더 좋다는 주장들이 제기된다.

> 이게 Docker 같다.

##### Previrtualization

반가상화에서 VMM에 부합하기 위해 GuestOS의 수정이 불가피했는데, Pre 또한 GuestOS의 수정이 필요하다는 점에서 비슷한 점이 있다.

하지만 Pre에서는 hypervisor 위에 **in-place VMM**을 두어 실제 수정해야 하는 부분이 매우 적고, **반가상화에서 발생하는 GuestOS와 VMM 간 종속 관계**를 제거할 수 있다.

- 이 때 in-place VMM이란 **soft layering**이라는 층 구조로, 가상화 구성 요소들 간의 **모듈성**을 증가시키는 역할을 한다.

#### 경량화 된 가상화 기술의 등장

가상화 층이 **임베디드 시스템**에서 사용될 경우, 다양한 시스템 간 **상호 호환성**을 제공할 수 있고 개발 과정의 복잡도를 완화할 수 있을 것이다.

임베디드에 적용하기 위해, 경량 가상화에 대한 연구가 이루어지고 있다.

### 앞으로의 전망

full, para, paene, pre 등 다양한 접근 방법을 확인해봤다. 향후 각 기술은 어떻게 발전하고 진화할 것인가?

- 자원의 **공유와 고립**, GuestOS와 VMM의 관계, 경량화 등에서 짚어볼 필요가 있다.

#### full, para

이들은 각 가상 머신에 **강한 고립**을 제공한다.

즉, 단일한 고성능 하드웨어 상에 여러 가상 머신을 제공하는 환경에서 효과적으로 사용된다.

결함 고립, 보안 수준 향상, 가용성 향상 등에도 좋다.

- 성능을 따지자면 para 쪽이 더 좋다는 게 정설. CPU의 제한을 동적 수행 중에 해결하는 것이 아니라, GuestOS 내용을 바꿔버림으로써 극복했기 때문에 당연하다.

- 하지만 이러한 방식은 GuestOS와 VMM 간의 종속성을 크게 발생시켜, para 방식의 큰 단점이 된다.

- 따라서 full의 경우 **가상화**를 지원하는 CPU의 본격적인 생산을 따라갈 것이고,

- para의 경우 **표준 VMI**(Virtual Machine **Interface**)를 정의하여 종속성을 줄이는 방향, GuestOS 수정에 대한 **자동화** 방향으로 발전할 것이다.

#### paene

**약한 고립**, 즉 자원에 대한 가상 머신들 간 **공유 가능성**을 더욱 확대하였다.

상호 협력이 필요한 응용프로그램들을 수행하는 환경에 효과적이다.

#### pre

**경량화**에 장점이 있다.

**마이크로커널**을 기반으로 하기 때문에 기존 VMM보다 가볍고, **soft layering**을 도입하여 각 요소들 간 **모듈화**가 이루어졌기 때문에 동적 재구성에 용이하다.

즉, 임베디드 환경에 적용될 가능성이 크다.


