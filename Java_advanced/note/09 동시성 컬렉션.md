# 동시성 컬렉션

---

## 동시성 컬렉션이 필요한 이유

`java.util` 에 있는 **컬렉션 프레임워크**를 실무적으로 정말 많이 사용한다.

컬렉션 프레임워크는 과연 **원자적인 연산**을 제공하고 있을까?

- 다른 말로, 멀티스레드 환경에서 **스레드 세이프**할까?

결론적으로, 컬렉션 프레임워크가 제공하는 대부분의 연산은 **원자적이지 않다**.

### 멀티스레드 문제 확인

```java
@Override
    public void add(Object object) {
        elementData[size] = object;
        size++;
    }
```

- `ArrayList`의 `add` 메서드를 단순화하면 대충 위와 같이 묘사할 수 있다.

- 단순히 데이터 하나를 추가하는 기능이지만, 배열에 데이터를 추가하고 size 필드를 증가시키는 3가지 이상의 연산이 발생한다.

- 즉, 원자적이지 않기 때문에, 멀티스레드 환경에서 오작동할 가능성이 있다.

### 컬렉션 프레임워크의 스레드 언세이프 문제

`ArrayList` 뿐만 아니라 `HashSet`, `HashMap` 등 수많은 컬렉션들의 메서드들은 내부적으로 많은 연산을 들고 있다.

- 겉으로 봤을 때는 단순한 메서드여도,

- 절대로 스레드 세이프하다고 볼 수가 없다.

멀티스레드 상황에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면, `java.util` 패키지가 제공하는 일반적인 컬렉션은 사용하면 안 된다.

### 동기화를 통한 해결

컬렉션 프레임워크가 가진 모든 메서드에 대해 `synchronized` 블록을 처리하면, **동기화 락**에 의해 간단하게 스레드 세이프한 컬렉션을 만들어낼 수 있다.

하지만, **모든 컬렉션** 자료구조의 **모든 메서드**에 일일이 `synchronized`를 처리하도록 새로 구성하는 게 비효율적이다.

### 프록시 도입

기존 컬렉션 자료구조 클래스를 그대로 사용하면서, **멀티스레드 상황에서 동기화가 필요할 때만** `synchronized` 기능을 추가하는 방법을 찾을 필요가 있다.

#### 프록시 (Proxy)

컬렉션 클래스를 사용하기 전에, **프록시**를 호출하여 대신 `synchronized` 기능을 처리하도록 설계한다.

- 부가기능 도입을 위한 **프록시 패턴** 처리라고 이해하면 된다.

타겟 컬렉션 클래스를 **주입받는 프록시 클래스**를 만들고, 타겟 컬렉션과 **동일한 인터페이스를 구현**함과 동시에, `synchronized` 만 첨가하는 방법.

#### 프록시 패턴

**프록시 패턴**은 어떤 객체에 대한 접근을 제어하기 위해 그 객체의 대리인 또는 인터페이스 역할을 하는 객체를 제공하는 패턴이다.

- 접근 제어 : 실제 객체에 대한 접근을 제한하거나 통제

- 성능 향상 : 실제 객체의 생성을 지연하거나 캐싱하여 성능을 최적화

- 부가 기능 제공 : 실제 객체에 추가적인 기능을 투명하게 제공

---

## 자바 동시성 컬렉션 - synchronized

`java.util` 패키지의 컬렉션 프레임워크들은 스레드 언세이프이다.

그렇다고 모든 자료 구조에서 `synchronized` 처리를 해두는 것은 지양해야 한다.

- 아무리 CAS 같은 방식을 사용하더라도 성능과의 트레이드오프가 무조건 발생하기 때문

- **동기화를 사용하지 않는 것이 가장 빠르다**.

특히, 컬렉션이 항상 멀티스레드에서만 사용되는 것도 아니기 때문에 **반드시 필요할 때에만 동기화 처리**를 진행하고, 평소에는 컬렉션 클래스를 그대로 사용하는 것이 맞다.

이러한 상황에서 좋은 대안은, `synchronized`를 대신 적용해주는 **프록시**를 만드는 것.

자바는 **컬렉션을 위한 프록시 기능을 제공**하고 있다.

### 자바의 synchronized 프록시

`List<String> list = Collections.synchronizedList(new ArrayList<>());`

컬렉션을 사용하고자 할 때, 위와 같이 `synchronizedList` 를 호출하면 **동시성이 적용된 컬렉션 클래스**를 리턴받을 수 있다.

-  `ArrayList`를 파라미터에 넣어서 `synchronized` 처리를 해달라고 하면,

- 실제로는 `SynchronizedRandomAccessList` 가 리턴되어

- `ArrayList` 에 대한 `synchronized` 프록시 처리를 진행해준다.

- 그 외 `Map, Set` 등 다른 자료구조도 모두 위와 같은 기능이 제공된다.

#### synchronized 프록시 방식의 단점

- **동기화 오버헤드** : `synchronized` 키워드를 사용한다는 자체에서 발생하는 스레드 블록과 컨텍스트 스위칭의 비용

- **전체 컬렉션에 대한 동기화 적용** : **잠금 범위**가 불필요하게 넓어질 수밖에 없다. 경합 범위를 증가시켜, 병렬 처리의 효율성을 저하시킨다.

- **정교한 동기화 불가능** : 특정 부분이나 메서드에 대한 선택적인 동기화 적용이 불가하다. **과도한 동기화**가 이루어진다.

즉, 이 방식은 단순무식하게 모든 메서드에 `synchronized`를 거는 것에 불과하기 때문에,

**동기화에 대한 최적화**까지는 이루어질 수 없다.

자바는 이를 보완하고자 별도의 **동시성 컬렉션**을 제공하게 되었다.

---

## 자바 동시성 컬렉션 - 동시성 컬렉션

### 동시성 컬렉션

자바 1.5부터, `java.util.concurrent` 패키지를 제공함으로써 **고성능 멀티스레드 환경을 지원하는 다양한 동시성 컬렉션 클래스**들을 사용할 수 있게 되었다.

- 더 정교한 잠금 메커니즘을 사용하여 동시 접근을 효율적으로 처리하며,

- 필요한 경우 일부 메서드만 동기화하는 등 동기화 전략이 훨씬 유연하다.

다양한 성능 최적화 기법도 적용되어 있다.

- `synchronized`, `Lock(ReentrantLock)`, `CAS`, 분할 잠금 기술 등 생각할 수 있는 건 다 있다.

### 동시성 컬렉션의 종류

- List
  
  - CopyOnWriteArrayList

- Set
  
  - CopyOnWriteArraySet
  
  - ConcurrentSkipListSet

- Map
  
  - **ConcurrentHashMap**
  
  - ConcurrentSkipListMap

- Queue
  
  - ConcurrentLinkedQueue

- Deque
  
  - ConcurrentLinkedDeque

참고로 `LinkedHashSet`이나 `LinkedHashMap` 같이 **입력 순서를 유지하는** `Set`, `Map` 구현체는 포함되어 있지 않기 때문에,

`synchronized` 프록시를 사용해야 한다.

#### 스레드를 차단하는 블로킹 큐

- BlockingQueue
  
  - ArrayBlockingQueue
  
  - LinkedBlockingQueue
  
  - PriorityBlockingQueue
  
  - SynchronousQueue
    
    - 데이터를 저장하지 않는 블로킹 큐로,
    
    - 생산자와 소비자 간의 **직접적인 핸드오프** 메커니즘을 제공한다.
  
  - DelayQueue

---

## 정리

자바가 제공하는 동시성 컬렉션은 멀티스레드 상황에서 최적의 성능을 낼 수 있도록 다양한 최적화 기법이 적용되어 있다.

- 따라서 `Collections.synchronizedXxx` 보다 좋은 성능을 제공해준다.

동시성은 결국 성능과의 트레이드오프가 존재하기 때문에, **단일 스레드** 환경일 때는 **반드시 일반 컬렉션**을 사용할 수 있도록 해야 한다.

반대로, 멀티스레드 환경에서 일반 컬렉션을 잘못 사용하면 해결이 극히 어려운 버그가 발생할 수 있다.

멀티스레드 환경이라면 **동시성 컬렉션을 적절히 활용**하여 버그를 예방하고, 성능을 최적화할 필요가 있다.


