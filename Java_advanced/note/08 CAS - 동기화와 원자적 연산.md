# CAS - 동기화와 원자적 연산

---

## 원자적 연산

### 개요

**원자적 연산**은 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.

- 중단되지 않고,

- 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는다.

즉, **멀티스레드 환경에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산**을 뜻한다.

#### 예시

```java
volatile int i = 0;
i = 1;         // 원자적 연산이 맞음
i = i + 1;     // 원자적 연산이 아님
```

- `i = i + 1` 은 `i`라는 필드에 대한 접근이 **실제로는 총 2번** 발생한다.

- `i = 1`의 경우 필드에 대한 접근이 단 1번 발생한다.

원자적 연산의 경우, 멀티스레드 환경에서 아무런 문제가 발생하지 않는다.

원자적 연산이 아닌 경우, `synchronized` 블럭이나 `Lock` 등을 사용하여 **안전한 임계 영역**을 만들 필요가 있다.

### AtomicInteger

자바는 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 `AtomicInteger` 클래스를 제공한다.

- 이름 그대로 원자적인 Integer 이다.

```java
    AtomicInteger atomicInteger = new AtomicInteger(0);
    @Override
    public void increment() {
        atomicInteger.incrementAndGet();
    }

    @Override
    public int get() {
        return atomicInteger.get();
    }
```

- `incrementAndGet` 같은 메서드를 사용하면, 마치 `synchronized` 블럭을 적용한 것과 같이 멀티스레드 환경에서 스레드 간섭 없이 증감 연산이 안전하게 수행될 수 있다.

`AtomicInteger` 뿐만 아니라 `Long, Boolean` 등 다양한 `Atomic` 클래스가 존재하니, 필요에 따라 활용하면 된다.

### 성능 검증

예제로, 아래 4개의 코드를 작성했다.

- 아무 장치 없이 `int` 필드에 대한 증가 연산

- `volatil` 부여한 뒤 증가 연산

- `synchronized` 블록을 적용한 증가 연산

- `AtomicInteger` 필드에 대한 증가 연산

일단 정상 작동 여부를 따져보면,

- 1, 2는 비정상 작동

- 3, 4는 정상 작동하며

성능을 검증했을 때

- 1 >>>> 2 > 4 >>> 3 

주목할 점은 `synchronized`와 `AtomicInteger` 간의 성능 차이이다.

- 둘다 멀티스레드 환경에서 대응하여, 원하는 연산을 정확히 수행하고 있지만

- `AtomicInteger` 쪽이 대략 3배는 빠르다.

이러한 차이를 만들어내는 이유는,

`AtomicInteger`의 경우 **락을 사용하지 않고 원자적 연산을 만들어냈기 때문**이다.

---

## CAS 연산

### 락 기반 방식의 문제점

`synchronized` 블록을 사용할 시, 자바는 **락**을 사용하여 임계영역을 보호한다.

- 멀티스레드 환경에서 스레드 블록 상태를 유발할 수밖에 없고,

- 락을 획득하고 해제하는 것 자체도 오버헤드가 있다.

즉, 락을 사용할 시 **직관적이고 안전하지만** **상대적으로 무거울 수밖에 없다.**

### CAS

이러한 문제를 해결하기 위해, **락을 걸지 않고도 원자적인 연산을 수행하는 방법이 필요**했다.

- CAS (Compare-And-Swap, Compare-And-Set)

락을 사용하지 않기 때문에 **락 프리** 기법이라 한다.

락을 완전히 대체할 수는 없고, **작은 단위의 일부 영역**에 사용할 수 있다.

#### compareAndSet()

`AtomicInteger`가 가지고 있는 값을 특정한 값과 비교하여, 동일하면 다른 값으로 변경하라는 극히 단순한 메서드다.

근데 중요한 건 해당 연산이 **CAS**에 해당한다는 점이다.

- 기계적으로 작동 기작을 따져봤을 때 2개의 연산임에도

- 실제로는 **CPU가 1개의 연산, CAS로 인지하고 있다.**

### CPU 하드웨어의 지원

CAS 연산은, 실제 원자적이지 않은 두 개의 연산을 **CPU 하드웨어 차원에서 특별히 하나의 원자적인 연산으로 묶어서 제공하는** 기능이다.

- 소프트웨어가 아닌, **하드웨어**가 제공하는 기능으로 대부분의 현대 CPU들은 CAS 연산을 위한 명령어를 제공해주고 있다.

CPU가 **실제로 2가지 작업**을 수행하는 것은 사실이나, 

CPU에게 **원자적 연산을 하라는 오더가 들어갔기 때문에** CPU 수준에서 해당 **메모리 값**에 대한 **다른 스레드의 변경을 차단**해주는 것이다.

- 어찌 보면 CPU 수준에서 락을 걸었다고 볼 수도 있는데,

- 프로그램에서 락을 거는 것과 달리 하드웨어적인 부분이라 **성능에 거의 영향을 주지 않게 된다**.

- 그래서 **락**이라고 취급하지도 않는다.




