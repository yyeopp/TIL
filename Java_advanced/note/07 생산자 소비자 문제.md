# 생산자 소비자 문제

---

## 생산자 소비자 문제

생산자 소비자 문제는 멀티스레드 프로그래밍에서 자주 발생하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다.

### 기본 개념

- **생산자**(Producer) : 데이터를 생성하는 역할
  
  - ex) 사용자의 입력을 프린터 큐에 전달하는 스레드

- **소비자**(Consumer) : 생성된 데이터를 사용하는 역할
  
  - ex) 프린터 큐에 전달된 데이터를 받아서 출력하는 스레드

- **버퍼**(Buffer) : 생산자가 생성한 데이터를 일시적으로 저장하는 공간
  
  - ex) 프린터 큐

### 문제 상황

#### 생산자가 너무 빠를 때

버퍼가 가득 차서, 더 이상 데이터를 넣을 수 없을 때까지 생산자가 너무 빠르게 데이터를 생성한다.

- 생산자는 소비자가 버퍼를 비워줄 때까지 대기해야 한다.

#### 소비자가 너무 빠를 때

버퍼가 비어서 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.

- 소비자는 버퍼에 새로운 데이터가 들어올 때까지 대기해야 한다.

### 한정된 버퍼 문제

생산자 소비자 문제는 **한정된 버퍼 문제**로도 볼 수 있다.

**bounded-buffer problem**

중간에 있는 **버퍼의 크기가 한정되어 있기 때문에 발생하는 문제**라는 의미이다.

- 버퍼가 **가득 찬 경우** : 생산자 입장에서는 **버퍼에 여유가 생길 때까지 기다리면 되는데**, 이에 대응되어 있지 않으면 데이터를 버리기도 한다.

- 버퍼가 **빈 경우** : 소비자 입장에서는 **버퍼에 데이터가 채워질 때까지 기다리면 되는데**, 이에 대응되어 있지 않으면 `null` 이 반환될 가능성이 있다.

#### 버퍼에 대한 무한 대기 문제

한정된 버퍼 문제를 해결하기 위헤 코드를 구현해볼 수 있는데, 자칫 잘못하면 **무한 대기 문제**를 발생시킬 수 있다.

- 버퍼가 가득차거나 빈 경우에 대해 스레드가 **대기**하도록 하는데,

- `synchronized` 와 함께 조합할 시 **스레드라 인스턴스 모니터 락을 가진 상태에서 대기**하게 되어,

- 서로 다른 스레드 간에 **완벽한 경합 상태**를 유발할 수 있다.

스레드의 **대기**를 구현하고자 한다면, **대기 중에 다른 스레드에게 모니터 락을 양보할 수 있도록** 처리할 필요가 있다.

자바의 `Object.wait()`와 `Object.notify()`를 사용하면, **락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다**.

---

## Object - wait, notify

자바는 `synchronized` 를 사용한 **임게 영역 안에서 락을 가지고 무한 대기하는 문제**를 일찍부터 대응한 상태였다.

무려 Object 클래스에 `wait()`와 `notify()` 메서드를 제공하여 이 문제를 해결하고 있다.

### wait, notify

#### wait()

현재 스레드가 가진 락을 **반납하고 대기**한다.

- 스레드는 WAITING 상태로 전환된다.

- 해당 메서드는 현재 스레드가 메서드에서 **락을 소유하고 있을 때에만** 호출할 수 있다.

- 다른 스레드가 `notify()` 또는 `notifyAll()` 을 호출해줄 때까지 대기 상태가 유지된다.

#### notify()

대기 중인 스레드 중 하나를 깨운다.

- 해당 메서드는 **임계 영역 내에서만** 호출되어야 한다.

- 대기 중인 스레드가 여러 개라면, 그 중 하나가 깨어난다.

#### nofityAll()

대기 중인 **모든** 스레드를 깨운다.

- 해당 메서드는 **임계 영역 내에서만** 호출되어야 한다.

- 대기 중이던 모든 스레드가 락 획득의 기회를 얻게 된다.

### 스레드 대기 집합 (wait set)

모든 객체는 각자의 **모니터 락과 대기 집합**을 가지고 이를 **한 쌍**으로 운영한다.

- 즉, `synchronized`, `Object.wait()`, `Object.notify()`가 모두 하나의 맥락에서 구성되어 있는 것이다.

`synchronized` 임계 영역 안에서 `Object.wait()`를 호출하면, 스레드는 **WAITING** 상태로 들어간다.

- 정확히는 **락**을 반납하면서 **대기 집합**으로 들어간다.

#### notify()와 BLOCKED 상태

`Object.notify()`를 호출하면, **대기 집합에서 WAITING** 중이던 스레드 중 하나가 BLOCKED 상태로 전환된다.

- 대기 중이던 스레드는 **임계 영역** 안에서 대기 중이기 때문에,

- 즉시 실행 (RUNNABLE) 되면 안 된다. **반드시 락을 가져야 한다**.

- BLOCKED 상태가 먼저 됐다가, **락을 획득하는 순간 RUNNABLE** 하는 것이다.

어떤 스레드를 깨우는 지에 대해서는 **알 수 없다**.

- JVM 스펙에서 어떤 스레드를 깨우는 지는 다루고 있지 않다.

- 이에 따라 다소 **비효율적인 동작**이 발생할 여지가 있기는 한데, **일반적으로는** 이것 때문에 로직이 잘못되지는 않지만

- 분명히 해결이 필요한 문제이기는 하다.

### wait, notify의 한계

wait, notify 방식은 **스레드 대기 집합 하나로 생산자, 소비자 스레드를 모두 관리**하고 있다.

- 결과적으로 `notify()` 호출 시 **임의의 스레드가 선택되어 깨어나고**, 이는 **비효율적인 동작**을 유발할 수 있다.

예제 코드를 통해 이러한 현상을 정리해보면,

**같은 종류의 스레드를 깨울 때 비효율이 발생**한다는 사실을 확인할 수 있다.

- 생산자가 생산자를, 소비자가 소비자를 깨울 때.

- 교차로 깨울 수 있다면 이러한 비효율은 발생하지 않을 것.

#### 스레드 기아 (thread starvation)

최악의 경우, `notify()`는 동일한 종류의 스레드만 계속 반복적으로 깨워낼 수 있다.

그러다 보면 특정 종류의 스레드는 **실행 순서를 얻지 못하다가 아주 나중에** 깨어날 수도 있는데, 이러한 상황을 **스레드 기아 상태**라고 한다.

- **락**과는 명백히 다른 상황이다.

- **실행이 가능한 상태**임에도 **순서가 돌아오지 못해서** 발생하는 현상

#### notifyAll()을 사용한다면?

대기 집합에 있는 **모든** 스레드가 깨어난다.

- 같은 종류의 스레드들은 동시에 실행이 불가하기 때문에, 결과적으로 **모두 스레드 대기 집합**으로 돌아가게 된다.

- 결과적으로 순서를 얻지 못하던 다른 종류의 스레드에게 반드시 락이 돌아가게 될 수 있다.

즉, 스레드 기아 문제를 해결할 수 있기는 한데, **동작이 비효율적**인 것은 어쩔 수 없다.

---

## LockCondition

같은 종류의 스레드가 서로 깨우는 **비효율 문제**를 어떻게 해결할 수 있을까?

- 생산자용, 소비자용 대기 집합을 **서로 나누어 분리하고 서로 호출하도록 하면** 이를 깔끔하게 해결할 수 있다.

자바 1.5에서부터 제공된 `concurrent.Lock` 에서는 이 문제를 `LockCondition`으로 해결하고 있다.


