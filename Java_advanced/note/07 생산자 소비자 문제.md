# 생산자 소비자 문제

---

## 생산자 소비자 문제

생산자 소비자 문제는 멀티스레드 프로그래밍에서 자주 발생하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다.

### 기본 개념

- **생산자**(Producer) : 데이터를 생성하는 역할
  
  - ex) 사용자의 입력을 프린터 큐에 전달하는 스레드

- **소비자**(Consumer) : 생성된 데이터를 사용하는 역할
  
  - ex) 프린터 큐에 전달된 데이터를 받아서 출력하는 스레드

- **버퍼**(Buffer) : 생산자가 생성한 데이터를 일시적으로 저장하는 공간
  
  - ex) 프린터 큐

### 문제 상황

#### 생산자가 너무 빠를 때

버퍼가 가득 차서, 더 이상 데이터를 넣을 수 없을 때까지 생산자가 너무 빠르게 데이터를 생성한다.

- 생산자는 소비자가 버퍼를 비워줄 때까지 대기해야 한다.

#### 소비자가 너무 빠를 때

버퍼가 비어서 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.

- 소비자는 버퍼에 새로운 데이터가 들어올 때까지 대기해야 한다.

### 한정된 버퍼 문제

생산자 소비자 문제는 **한정된 버퍼 문제**로도 볼 수 있다.

**bounded-buffer problem**

중간에 있는 **버퍼의 크기가 한정되어 있기 때문에 발생하는 문제**라는 의미이다.

- 버퍼가 **가득 찬 경우** : 생산자 입장에서는 **버퍼에 여유가 생길 때까지 기다리면 되는데**, 이에 대응되어 있지 않으면 데이터를 버리기도 한다.

- 버퍼가 **빈 경우** : 소비자 입장에서는 **버퍼에 데이터가 채워질 때까지 기다리면 되는데**, 이에 대응되어 있지 않으면 `null` 이 반환될 가능성이 있다.

#### 버퍼에 대한 무한 대기 문제

한정된 버퍼 문제를 해결하기 위헤 코드를 구현해볼 수 있는데, 자칫 잘못하면 **무한 대기 문제**를 발생시킬 수 있다.

- 버퍼가 가득차거나 빈 경우에 대해 스레드가 **대기**하도록 하는데,

- `synchronized` 와 함께 조합할 시 **스레드라 인스턴스 모니터 락을 가진 상태에서 대기**하게 되어,

- 서로 다른 스레드 간에 **완벽한 경합 상태**를 유발할 수 있다.

스레드의 **대기**를 구현하고자 한다면, **대기 중에 다른 스레드에게 모니터 락을 양보할 수 있도록** 처리할 필요가 있다.

자바의 `Object.wait()`와 `Object.notify()`를 사용하면, **락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다**.

---

## Object - wait, notify

자바는 `synchronized` 를 사용한 **임게 영역 안에서 락을 가지고 무한 대기하는 문제**를 일찍부터 대응한 상태였다.

무려 Object 클래스에 `wait()`와 `notify()` 메서드를 제공하여 이 문제를 해결하고 있다.

### wait, notify

#### wait()

현재 스레드가 가진 락을 **반납하고 대기**한다.

- 스레드는 WAITING 상태로 전환된다.

- 해당 메서드는 현재 스레드가 메서드에서 **락을 소유하고 있을 때에만** 호출할 수 있다.

- 다른 스레드가 `notify()` 또는 `notifyAll()` 을 호출해줄 때까지 대기 상태가 유지된다.

#### notify()

대기 중인 스레드 중 하나를 깨운다.

- 해당 메서드는 **임계 영역 내에서만** 호출되어야 한다.

- 대기 중인 스레드가 여러 개라면, 그 중 하나가 깨어난다.

#### nofityAll()

대기 중인 **모든** 스레드를 깨운다.

- 해당 메서드는 **임계 영역 내에서만** 호출되어야 한다.

- 대기 중이던 모든 스레드가 락 획득의 기회를 얻게 된다.

### 스레드 대기 집합 (wait set)

모든 객체는 각자의 **모니터 락과 대기 집합**을 가지고 이를 **한 쌍**으로 운영한다.

- 즉, `synchronized`, `Object.wait()`, `Object.notify()`가 모두 하나의 맥락에서 구성되어 있는 것이다.

`synchronized` 임계 영역 안에서 `Object.wait()`를 호출하면, 스레드는 **WAITING** 상태로 들어간다.

- 정확히는 **락**을 반납하면서 **대기 집합**으로 들어간다.

#### notify()와 BLOCKED 상태

`Object.notify()`를 호출하면, **대기 집합에서 WAITING** 중이던 스레드 중 하나가 BLOCKED 상태로 전환된다.

- 대기 중이던 스레드는 **임계 영역** 안에서 대기 중이기 때문에,

- 즉시 실행 (RUNNABLE) 되면 안 된다. **반드시 락을 가져야 한다**.

- BLOCKED 상태가 먼저 됐다가, **락을 획득하는 순간 RUNNABLE** 하는 것이다.

어떤 스레드를 깨우는 지에 대해서는 **알 수 없다**.

- JVM 스펙에서 어떤 스레드를 깨우는 지는 다루고 있지 않다.

- 이에 따라 다소 **비효율적인 동작**이 발생할 여지가 있기는 한데, **일반적으로는** 이것 때문에 로직이 잘못되지는 않지만

- 분명히 해결이 필요한 문제이기는 하다.

### wait, notify의 한계

wait, notify 방식은 **스레드 대기 집합 하나로 생산자, 소비자 스레드를 모두 관리**하고 있다.

- 결과적으로 `notify()` 호출 시 **임의의 스레드가 선택되어 깨어나고**, 이는 **비효율적인 동작**을 유발할 수 있다.

예제 코드를 통해 이러한 현상을 정리해보면,

**같은 종류의 스레드를 깨울 때 비효율이 발생**한다는 사실을 확인할 수 있다.

- 생산자가 생산자를, 소비자가 소비자를 깨울 때.

- 교차로 깨울 수 있다면 이러한 비효율은 발생하지 않을 것.

#### 스레드 기아 (thread starvation)

최악의 경우, `notify()`는 동일한 종류의 스레드만 계속 반복적으로 깨워낼 수 있다.

그러다 보면 특정 종류의 스레드는 **실행 순서를 얻지 못하다가 아주 나중에** 깨어날 수도 있는데, 이러한 상황을 **스레드 기아 상태**라고 한다.

- **락**과는 명백히 다른 상황이다.

- **실행이 가능한 상태**임에도 **순서가 돌아오지 못해서** 발생하는 현상

#### notifyAll()을 사용한다면?

대기 집합에 있는 **모든** 스레드가 깨어난다.

- 같은 종류의 스레드들은 동시에 실행이 불가하기 때문에, 결과적으로 **모두 스레드 대기 집합**으로 돌아가게 된다.

- 결과적으로 순서를 얻지 못하던 다른 종류의 스레드에게 반드시 락이 돌아가게 될 수 있다.

즉, 스레드 기아 문제를 해결할 수 있기는 한데, **동작이 비효율적**인 것은 어쩔 수 없다.

---

## LockCondition

같은 종류의 스레드가 서로 깨우는 **비효율 문제**를 어떻게 해결할 수 있을까?

- 생산자용, 소비자용 대기 집합을 **서로 나누어 분리하고 서로 호출하도록 하면** 이를 깔끔하게 해결할 수 있다.

자바 1.5에서부터 제공된 `concurrent.Lock` 에서는 이 문제를 `LockCondition`으로 해결하고 있다.

### Condition

`synchronized` 대신 `Lock` 과 `ReentrantLock` 을 사용할 수 있다는 점은 앞서 다뤘는데,

이제 `Object.wait()`와 `notify()` 대신에 

`Condition.await()` 와 `Condition.signal()`을 사용한다.

#### Condition

`Condition`은 `ReentrantLock`을 **사용하는 스레드가 대기하는 스레드 대기 공간**이다.

- `lock.newCondition()`을 호출하여 스레드 대기 공간을 생성할 수 있다.

#### condition.await()

`Object.wait()`와 유사한 기능으로, **지정한 condition에 현재 스레드를 WAITING 상태로 보관**한다.

- 정확히는 `ReentrantLock`에서 획득한 락을 반납하고 대기한다.

- 인스턴스 네이티브 모니터 락이 아니다.

#### condition.signal()

`Object.notify()`와 유사한 기능으로, **지정한 condition에서 대기 중인 스레드를 하나 깨운다**.

---

## 생산자 소비자 대기 공간 분리

`Condition`을 사용하면 **생산자와 소비자의 스레드 대기 공간을 분리**하는 것이 가능해진다.

- `await()`와 `signal()`을 호출할 때,

- 생산자 메서드와 소비자 메서드에서 **적절한 Condition을 signal() 하도록 처리**하면 된다.

이를 통해 동종 스레드가 서로를 깨우는 비효율적인 동작을 차단하고, 스레드 기아 현상을 예방할 수 있다.

### Object.notify()와의 차이점

- **Object.notify()**
  
  - 대기 중인 스레드 중 임의의 하나를 선택해서 깨운다.
  
  - 깨어나는 순서는 정의되어 있지 않다.
  
  - `synchronized` 블록 내에서 **모니터 락**을 가지고 있는 스레드가 호출해야 한다.

- **Condition.signal()**
  
  - 대기 중인 스레드 중 하나를 깨운다.
  
  - 일반적으로 **FIFO** 순서로 깨운다.
  
  - `ReentrantLock`을 가지고 있는 스레드가 호출해야 한다.

---

## 스레드의 대기

### synchronized 대기

`synchronized`는 2가지 단계의 대기 상태가 존재한다.

#### 대기1 : 락 획득 대기

`BLOCKED` 상태로 락 획득을 대기한다.

- 이 때 대기하는 락은 **인스턴스의 모니터 락**이다.

`synchronized` 를 시작하는 순간에 락이 없으면 **무한정 대기**한다.

다른 스레드가 `synchronized`를 빠져나갈 때, **자동으로 대기가 풀리면서 락 획득을 시도한다**.

#### 대기2 : wait() 대기

`WAITING` 상태로 락 획득을 대기한다.

스레드가 직접 `wait()`를 호출함으로써, **스레드 대기 집합**에서 대기한다.

다른 스레드가 `notify()`를 **호출했을 때** 스레드 대기 집합에서 빠져나와 락 획득을 시도할 수 있다.

#### 락 대기 집합

**대기 1** 상황에서 `BLOCKED` 상태의 스레드는 정확히는 **락 대기 집합**이라는 자료구조에서 관리되고 있다.

여기서 모니터 락을 기다리는 `BLOCKED` 상태의 스레드들을 관리하며,

자바 내부에 구현되어 있기 때문에 **스레드 대기 집합**과 마찬가지로 개발자가 확인하기는 어렵다.

- `Object.wait()` 를 사용했을 때 **스레드 대기 집합**에서 대기하는 것과 명확히 구분해야 한다.

#### 정리

자바의 모든 객체 인스턴스는, 멀티스레드와 임계 영역을 안전하게 다루기 위해 **내부에 3가지 기본 요소**를 가진다.

- **모니터 락**

- **락 대기 집합**

- **스레드 대기 집합**

락 대기 집합이 **1차** 대기소이고, 스레드 대기 집합이 **2차** 대기소이다.

- **모니터 락**을 가지고 있던 스레드는 `wait()`를 호출하여 락을 반납함과 동시에 2차 대기소인 **스레드 대기 집합**에 들어갈 수 있다.

- 2차 대기소에 들어간 (`wait`) 스레드는, 다른 스레드가 호출한 `notify()`에 의해 **1차** 대기소로 이동할 수 있다.

- 1차 대기소에서 `BLOCKED` 상태로 대기하다가, 최종적으로 **락을 획득**함으로써 1차 대기소를 빠져나와 **임계 영역을 수행**할 수 있다.

### ReentrantLock 대기

`Lock(ReentrantLock)` 또한 2가지 단계의 대기 상태가 존재한다.

#### 대기 1: ReentrantLock 락 획득 대기

`ReentrantLock`의 **대기 큐**에서 관리한다.

`WAITING` 상태로 락 획득을 대기하며,

`lock.lock()`을 호출했을 때 락이 없으면 대기하게 된다.

- **인터럽트** 허용 여부나 **타임아웃** 처리 등도 가능하다.

다른 스레드가 `lock.unlock()`을 호출해주면 대기가 풀리면서 락 획득을 시도한다.

락을 획득하면 대기 큐를 빠져나간다.

#### 대기 2: await() 대기

`condition.await()`를 호출했을 때, `Condition` 객체의 **스레드 대기 공간**에서 관리된다.

`WAITING` 상태로 대기하며,

다른 스레드가 `condition.signal()`을 호출했을 때 `Condition` 객체의 스레드 대기 공간을 빠져나간다.

#### 2단계 대기소

`synchronized`와 마찬가지로, `ReentrantLock`도 대기소가 2단계인 것을 확인할 수 있다.

- `Condition`의 **스레드 대기 공간**

- `ReentrantLock`의 **대기 큐**

1단계 대기소인 **대기 큐**에서 `ReentrantLock`의 락을 획득해야 RUNNABLE로 전환된다는 점에서도 개념적으로 동일하다.

---

## BlockingQueue

자바는 생산자 소비자 문제를 해결하기 위해, `BlockingQueue`라는 특별한 **멀티스레드 자료 구조**를 제공하고 있다.

이름 그대로, 스레드를 **차단**할 수 있는 큐로

- **데이터 추가 차단** : 큐가 가득차면, 데이터 추가 작업을 시도하는 스레드가 차단되고

- **데이터 획득 차단** : 큐가 비어있으면, 획득 작업을 시도하는 스레드가 차단된다.

### 기본 개념

#### 주요 메서드

- 데이터 추가 메서드 : add, offer, put, offer(타임아웃)

- 데이터 획득 메서드 : take(), poll(타임아웃), remove(..)

#### 구현체

- `ArrayBlockingQueue` : 배열 기반으로 구현되어, 버퍼의 크기가 고정됨

- `LinkedBlockingQueue`: 링크 기반으로 구현되어, 버퍼의 크기를 무한정 확장할 수 있다.

### 기능

`BlockingQueue`는 여러 기능을 제공하는데, 이는 멀티스레드 프로그램에서 **다양한 요구사항을 소화**하기 위해서이다.

생산자, 소비자가 적당한 균형을 이루는 것이 바람직하겠으나, 업무적으로는 아주 다양한 상황이 발생할 수 있다.

**큐가 가득찼을 때**를 상정했을 때도, 여러가지 처리방안이 필요한 것이다.

- 예외를 던지고 받아서 처리하거나

- 대기하지 않고 즉시 반환하거나

- 무한정 대기하거나

- 특정 시간만 대기하거나

#### BlockingQueue의 다양한 기능

- Throws Exception - 대기 시 **예외**
  
  - add, remove, element

- Special Value - 대기 시 **즉시 반환**
  
  - offer, poll, peek

- Blocks - 대기
  
  - put, take

- Times Out - 시간 대기
  
  - offer(타임아웃), poll(타임아웃)

참고로 대기, 시간 대기의 모든 메서드는 **인터럽트**를 허용한다.

---

## 정리

#### **Doug Lea**

자바 1.5의 `java.util.concurrent` 패키지의 주요 클래스를 까보면, 거의 모든 코드 작성자에 이 사람의 이름이 적혀 있다.

Doug Lea는 컴퓨터 과학 교수로, 동시성 프로그래밍, 멀티스레딩, 병렬 컴퓨팅, 알고리즘, 데이터 구조 등 분야에서 많은 업적을 만들었다.

특히 JSR-166이라는 자바 `java.util.concurrent` 패키지의 주요 설계 및 구현을 주도했다.

`java.util.concurrent` 패키지는 보기 드문 수준으로 견고하고, 성능 최적화도 잘 되어있으며, 개발자가 쉽고 편리하게 동시성 문제를 다룰 수 있다.

이 사람 덕분에 자바의 동시성 프로그래밍이 크게 발전했고, 결과적으로 현대 자바 프로그래밍에서 핵심적인 부분을 구성했다고 보면 된다.


