# 스레드 제어와 생명 주기

---

## 스레드 기본 정보

- 스레드 생성
  
  - `Thread` 객체를 생성할 때는, `Runnable` 인터페이스의 구현체와 스레드 이름을 전달할 수 있다.
  
  - 스레드 이름을 생략하면 `Thread-0` 같은 임의의 이름으로 생성된다.

- 스레드 객체 정보
  
  - `toString()` 메서드가 **스레드 ID, 스레드 이륾, 우선순위, 스레드 그룹**을 포함하고 있다.

- 스레드 ID
  
  - `threadId()` 
  
  - 스레드의 **고유 식별자**를 반환하는 메서드다.
  
  - JVM 내에서 각 스레드에 대해 유일하며, 생성될 때 할당된다.
  
  - 직접 지정할 수 없다.

- 스레드 이름
  
  - `getName()`
  
  - 직접 지정 가능하며, ID와 달리 중복 가능하다.

- 스레드 우선순위
  
  - `getPriority()`
  
  - 스레드 우선순위를 반환하며, 1이 가장 낮고 10이 가장 높다.
  
  - 기본값은 5이고, 변경 가능하다.
  
  - 물론 우선순위를 개발자가 지정했다고 하더라도 실제 실행 순서는 JVM과 운영체제의 스케줄러가 결정하게 된다.

- 스레드 그룹
  
  - **스레드 그룹**은 스레드를 그룹화하여 관리할 수 있는 기능을 제공한다.
    
    - 모든 스레드는 부모 스레드와 동일한 스레드 그룹에 속한다.
  
  - **메인 스레드**를 제외하면, 모든 스레드는 **다른 스레드에 의해 생성**된다.
    
    - 생성된 스레드는, 생성한 스레드를 **부모**로 간주하게 된다.

- 스레드 상태
  
  - `getState()`
  
  - 스레드의 현재 상태를 뜻한다. 
  
  - 반환되는 값은 `Thread.State` enum에 정의된다.
    
    - **NEW** : 스레드가 아직 시작되지 않음
    
    - **RUNNABLE** : 스레드가 실행 중, 실행될 준비가 됨
    
    - **BLOCKED** : 스레드가 동기화 락을 기다리는 상태
    
    - **WAITING** : 스레드가 다른 스레드의 작업이 완료되기를 기다리는 상태
    
    - **TIMED_WATING** : 스레드가 일정 시간 동안 기다리는 상태
    
    - **TERMINATED** : 스레드가 실행을 마친 상태

---

## 스레드의 생명 주기

### 스레드의 상태

- **NEW** : 스레드가 아직 시작되지 않음

- **RUNNABLE** : 스레드가 실행 중, 실행될 준비가 됨

- **일시 중지 상태들 (Suspended states)**
  
  - **BLOCKED** : 스레드가 **동기화 락**을 기다리는 상태
  
  - **WAITING** : 스레드가 다른 스레드의 작업이 완료되기를 **무기한** 기다리는 상태
  
  - **TIMED_WATING** : 스레드가 **일정 시간 동안** 다른 스레드의 작업을 기다리는 상태

- **TERMINATED** : 스레드가 실행을 마친 상태

자바 스레드의 생명 주기는 여러 **상태**(State)로 나뉜다.

각 상태는 스레드가 실행되고 종료되기까지의 전 과정을 다룬다.

#### NEW

스레드가 생성되고 아직 시작되지 않음.

- `start()` 메서드가 호출되지 않은 상태

#### Runnable

스레드가 실행될 준비가 된 상태.

- `start()` 메서드가 호출된 상태

실제로 CPU에서 실행될 수 있는 상태라는 뜻으로, 그 자체로 **실행 중**이라는 의미가 아니라 **운영체제의 스케줄러가 CPU 시간을 할당하여 실행시켜줄 준비가 되어있는** 상태를 포함한다.

즉, **현재 실행 중**이거나 **스케줄러의 실행 대기열에 포함되어 있는** 상태이다.

- 자바에서는 **둘을 구분할 수가 없다.**

#### Blocked

스레드가 다른 스레드에 의해 **동기화 락**을 기다리는 상태

- `synchronized` 블록에 진입하기 위해 락을 얻어야 하는 경우 등

#### Waiting

스레드가 다른 스레드의 특정 작업이 완료되기를 **무기한** 기다리는 상태

- `wait()`, `join()` 메서드가 호출된 상태

- 다른 스레드가 `notify()` 또는 `notifyAll()` 을 호출하거나, `join()` 이 완료되어야 한다.

#### Timed Waiting

스레드가 **특정 시간 동안** 다른 스레드의 작업이 완료되기를 기다리는 상태.

- `sleep`, `wait`, `join` 메서드를 **시간과 함께** 호출한 상태

#### Terminated

스레드의 실행이 완료된 상태.

정상 종료됐거나, 예외가 발생해서 종료됐거나.

### 자바 스레드의 상태 전이 과정

#### New -> Runnable

#### Runnable <-> Suspended Stated

#### Runnable -> Terminated

---

## 체크 예외 재정의

`Runnable` 인터페이스의 `run()` 메서드를 구현할 때는, `InterruptedException` 예외를 **반드시 잡았어야 한다**.

자바에서 메서드를 재정의할 때는, **예외**와 관련된 규칙이 있다.

- 체크 예외
  
  - 부모 메서드가 던지지 않은 체크 예외는 재정의된 자식 메서드도 던질 수 없다.

- 언체크 예외 (런타임)
  
  - 예외 처리를 강제하지 않으므로 관계없이 던질 수 있다.

이는 자식 클래스가 **더 넓은 범위의 예외를 던졌을 때** 예외 처리의 일관성을 해치고, 예상치 못한 런타임 오류를 초래할 수 있기 때문이다.

- 대표적으로 **다형성**을 활용하는 코드에서 직접적인 문제가 발생할 수 있다.

`Runnable` 인터페이스의 `run()` 메서드는 **아무런 체크 예외를 던지고 있지 않다**.

따라서, 재정의 메서드에서 체크 예외에 해당하는 `InterruptedException`을 던지는 것은 불가능하다.

#### 체크 예외 재정의 규칙 정리

- 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있다.

- 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없다.

#### Runnable 인터페이스의 안전한 예외 처리

체크 예외를 `run()` 메서드에서 던질 수 없도록 강제한 것은, 개발자가 반드시 `InterruptedException` 에 대한 예외 처리를 진행하도록 Java에서 의도한 것이다.

특히 **멀티스레딩** 환경에서는 예외 처리를 강제하여 **스레으듸 안정성과 일관성**을 유지할 수 있다.

하지만, 이러한 기조는 자바 초창기 기조에 해당한다. `Runnable` 인터페이스가 다소 구식이라 어쩔 수 없다.

---

## join

`join()` 메서드를 통해, WAITING 상태가 무엇이고 왜 필요한지 알아본다.


